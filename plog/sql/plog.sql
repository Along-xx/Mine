/*
Navicat MySQL Data Transfer

Source Server         : local
Source Server Version : 50724
Source Host           : localhost:3306
Source Database       : plog

Target Server Type    : MYSQL
Target Server Version : 50724
File Encoding         : 65001

Date: 2020-06-26 08:40:00
*/

SET FOREIGN_KEY_CHECKS=0;

-- ----------------------------
-- Table structure for plog_article
-- ----------------------------
DROP TABLE IF EXISTS `plog_article`;
CREATE TABLE `plog_article` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `user_id` int(11) DEFAULT NULL COMMENT '发表用户',
  `article_content` longtext COMMENT '文章内容html格式',
  `article_content_md` longtext COMMENT '文章内容Markdown格式',
  `article_newstime` datetime DEFAULT NULL COMMENT '发布时间',
  `article_status` int(11) DEFAULT NULL COMMENT '文章状态 0已发布1草稿2回收站',
  `article_summary` varchar(255) DEFAULT NULL COMMENT '文章摘要',
  `article_thumbnail` varchar(255) DEFAULT NULL COMMENT '略缩图',
  `article_title` varchar(255) DEFAULT NULL COMMENT '文章标题',
  `article_type` int(255) DEFAULT NULL COMMENT '文章类型0原创1转载',
  `article_post` varchar(255) DEFAULT NULL COMMENT 'post文章 page页面',
  `article_comment` int(11) DEFAULT NULL COMMENT '是否开启评论 0开启1不开启',
  `article_updatetime` datetime DEFAULT NULL COMMENT '文章最后修改时间',
  `article_url` varchar(255) DEFAULT NULL COMMENT '文章路径',
  `article_views` bigint(20) DEFAULT '0' COMMENT '访问量统计',
  PRIMARY KEY (`id`),
  UNIQUE KEY `plog_ARTICLE_URL` (`article_url`) USING BTREE,
  KEY `plog_ARTICLE_USERID` (`user_id`) USING BTREE
) ENGINE=InnoDB AUTO_INCREMENT=160 DEFAULT CHARSET=utf8;

-- ----------------------------
-- Records of plog_article
-- ----------------------------
INSERT INTO `plog_article` VALUES ('152', null, '<h1>Hello plog!</h1>\n<p>欢迎使用plog进行创作，删除这篇文章后赶紧开始吧。</p>', '# Hello plog!\n欢迎使用plog进行创作，删除这篇文章后赶紧开始吧。', '2020-06-23 16:33:56', '0', '欢迎使用plog进行创作，删除这篇文章后赶紧开始吧。', '/static/img/rand/13.jpg', 'Hello plog!', '0', 'post', '0', '2020-06-23 16:33:56', 'hello-plog', null);
INSERT INTO `plog_article` VALUES ('153', '14', '<h1 id=\"gc-\">GC垃圾回收</h1>\r\n<p>垃圾收集器</p>\r\n<h1 id=\"jmm-\">JMM内存布局</h1>\r\n<ul>\r\n<li>堆</li>\r\n<li>栈</li>\r\n<li>方法区</li>\r\n<li>常量区</li>\r\n</ul>', '# GC垃圾回收\r\n垃圾收集器\r\n# JMM内存布局\r\n* 堆\r\n* 栈\r\n* 方法区\r\n* 常量区', '2020-06-24 10:49:00', '0', '深入了解jvm虚拟机原理', '/upload/2020/6/99146020200625170742148.jpg', '深入jvm虚拟机', '0', 'post', '0', '2020-06-25 17:13:03', '1592966939', null);
INSERT INTO `plog_article` VALUES ('154', '14', '<h1 id=\"-\">锁分类</h1>\r\n<ul>\r\n<li>xxxxxxxxxxxxx<h1 id=\"-\">线程基础</h1>\r\nxxxxxxxxxxxxxxxxxxx<h1 id=\"-\">线程池</h1>\r\n</li>\r\n</ul>', '# 锁分类\r\n* xxxxxxxxxxxxx\r\n# 线程基础\r\nxxxxxxxxxxxxxxxxxxx\r\n# 线程池', '2020-06-24 10:51:28', '0', '锁分类xxxxxxxxxxxxx线程基础xxxxxxxxxxxxxxxxxxx线程池', '/static/img/rand/15.jpg', 'juc并发', '1', 'post', '1', '2020-06-24 10:51:28', '1592967088', null);
INSERT INTO `plog_article` VALUES ('155', '14', '<h1 id=\"hashmap-\">HashMap源码分析</h1>\r\n<p>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</p>\r\n<h1 id=\"hashmap-\">HashMap数据结构</h1>\r\n<p>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</p>\r\n<h1 id=\"-hashmap\">实现自己的HashMap</h1>\r\n<pre><code class=\"lang-java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">MyHashMap</span>&lt;<span class=\"hljs-title\">K</span>, <span class=\"hljs-title\">V</span>&gt; <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title\">IMap</span>&lt;<span class=\"hljs-title\">K</span>, <span class=\"hljs-title\">V</span>&gt; </span>{\r\n    <span class=\"hljs-comment\">//容量</span>\r\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">int</span> length = <span class=\"hljs-number\">16</span>;\r\n    <span class=\"hljs-comment\">//map的容器</span>\r\n    <span class=\"hljs-keyword\">private</span> Node[] buckets = <span class=\"hljs-keyword\">new</span> Node[length];\r\n    <span class=\"hljs-comment\">//map大小</span>\r\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">int</span> size;\r\n\r\n    <span class=\"hljs-meta\">@Override</span>\r\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">clear</span><span class=\"hljs-params\">()</span> </span>{\r\n        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; buckets.length; i++) {\r\n            buckets[i] = <span class=\"hljs-keyword\">null</span>;\r\n        }\r\n        size = <span class=\"hljs-number\">0</span>;\r\n    }\r\n\r\n    <span class=\"hljs-meta\">@Override</span>\r\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">boolean</span> <span class=\"hljs-title\">containsKey</span><span class=\"hljs-params\">(K key)</span> </span>{\r\n        <span class=\"hljs-comment\">//得到key的hash值</span>\r\n        <span class=\"hljs-keyword\">int</span> index = hash(key);\r\n        <span class=\"hljs-comment\">//如果该桶为空直接返回</span>\r\n        <span class=\"hljs-keyword\">if</span> (buckets[index] == <span class=\"hljs-keyword\">null</span>){\r\n            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">false</span>;\r\n        }\r\n        <span class=\"hljs-comment\">//遍历桶匹配key值</span>\r\n        Node&lt;K, V&gt; node = buckets[index];\r\n        <span class=\"hljs-keyword\">while</span> (node != <span class=\"hljs-keyword\">null</span>){\r\n            <span class=\"hljs-keyword\">if</span> (node.key == key || node.key.hashCode() == key.hashCode() &amp;&amp; node.key.equals(key)){\r\n                <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">true</span>;\r\n            }\r\n            node = node.next;\r\n        }\r\n\r\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">false</span>;\r\n    }\r\n\r\n    <span class=\"hljs-meta\">@Override</span>\r\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">boolean</span> <span class=\"hljs-title\">containsValue</span><span class=\"hljs-params\">(V value)</span> </span>{\r\n        <span class=\"hljs-comment\">//遍历桶匹配value值</span>\r\n        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; buckets.length; i++) {\r\n            Node&lt;K, V&gt; node = buckets[i];\r\n            <span class=\"hljs-keyword\">while</span> (node != <span class=\"hljs-keyword\">null</span>){\r\n                <span class=\"hljs-keyword\">if</span> (node.value.equals(value)){\r\n                    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">true</span>;\r\n                }\r\n                node = node.next;\r\n            }\r\n        }\r\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">false</span>;\r\n    }\r\n\r\n    <span class=\"hljs-meta\">@Override</span>\r\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> V <span class=\"hljs-title\">get</span><span class=\"hljs-params\">(K key)</span> </span>{\r\n        <span class=\"hljs-comment\">//得到key的hash值</span>\r\n        <span class=\"hljs-keyword\">int</span> index = hash(key);\r\n        <span class=\"hljs-comment\">//如果该桶为空直接返回</span>\r\n        <span class=\"hljs-keyword\">if</span> (buckets[index] == <span class=\"hljs-keyword\">null</span>){\r\n            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">null</span>;\r\n        }\r\n        <span class=\"hljs-comment\">//遍历桶匹配key值</span>\r\n        Node&lt;K, V&gt; node = buckets[index];\r\n        <span class=\"hljs-keyword\">while</span> (node != <span class=\"hljs-keyword\">null</span>){\r\n            <span class=\"hljs-keyword\">if</span> (node.key == key || node.key.hashCode() == key.hashCode() &amp;&amp; node.key.equals(key)){\r\n                <span class=\"hljs-keyword\">return</span> node.value;\r\n            }\r\n            node = node.next;\r\n        }\r\n\r\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">null</span>;\r\n    }\r\n\r\n    <span class=\"hljs-meta\">@Override</span>\r\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">boolean</span> <span class=\"hljs-title\">isEmpty</span><span class=\"hljs-params\">()</span> </span>{\r\n        <span class=\"hljs-keyword\">return</span> size == <span class=\"hljs-number\">0</span>;\r\n    }\r\n\r\n    <span class=\"hljs-meta\">@Override</span>\r\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> ISet&lt;K&gt; <span class=\"hljs-title\">keySet</span><span class=\"hljs-params\">()</span> </span>{\r\n        ISet&lt;K&gt; set = <span class=\"hljs-keyword\">new</span> MyHashSet&lt;&gt;();\r\n        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; buckets.length; i++) {\r\n            Node&lt;K, V&gt; temp = buckets[i];\r\n            <span class=\"hljs-keyword\">while</span> (temp != <span class=\"hljs-keyword\">null</span>){\r\n                set.add(temp.key);\r\n                temp = temp.next;\r\n            }\r\n        }\r\n        <span class=\"hljs-keyword\">return</span> set;\r\n    }\r\n\r\n    <span class=\"hljs-meta\">@Override</span>\r\n    <span class=\"hljs-keyword\">public</span> V[] values() {\r\n        <span class=\"hljs-comment\">// TODO Auto-generated method stub</span>\r\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">null</span>;\r\n    }\r\n\r\n    <span class=\"hljs-meta\">@Override</span>\r\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">put</span><span class=\"hljs-params\">(K key, V value)</span> </span>{\r\n        Node&lt;K, V&gt; temp = <span class=\"hljs-keyword\">new</span> Node&lt;K, V&gt;(key, value);\r\n        <span class=\"hljs-keyword\">int</span> index = hash(key);\r\n        Node&lt;K, V&gt; node = buckets[index];\r\n        <span class=\"hljs-comment\">//判断该桶中是否有元素</span>\r\n        <span class=\"hljs-keyword\">if</span> (node == <span class=\"hljs-keyword\">null</span>){\r\n            <span class=\"hljs-comment\">//如果为空直接放入该元素</span>\r\n            buckets[index] = temp;\r\n        }<span class=\"hljs-keyword\">else</span>{\r\n            <span class=\"hljs-comment\">//遍历链表到末尾</span>\r\n            <span class=\"hljs-keyword\">while</span> (node != <span class=\"hljs-keyword\">null</span>){\r\n                <span class=\"hljs-comment\">//判重</span>\r\n                <span class=\"hljs-keyword\">if</span> (node.key == key || node.hashCode() == temp.hashCode() &amp;&amp; node.key.equals(temp.key)){\r\n                    <span class=\"hljs-comment\">//如有重复更新value值</span>\r\n                    node.value = value;\r\n                    <span class=\"hljs-keyword\">return</span>;\r\n                }\r\n                node = node.next;\r\n                <span class=\"hljs-keyword\">if</span> (node.next == <span class=\"hljs-keyword\">null</span>){\r\n                    <span class=\"hljs-keyword\">break</span>;\r\n                }\r\n            }\r\n\r\n            <span class=\"hljs-comment\">//将该元素添加到链表末尾</span>\r\n            node.next = temp;\r\n        }\r\n        size++;\r\n    }\r\n\r\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">hash</span><span class=\"hljs-params\">(K key)</span> </span>{\r\n        <span class=\"hljs-keyword\">return</span> key.hashCode() % <span class=\"hljs-number\">16</span>;\r\n    }\r\n\r\n    <span class=\"hljs-meta\">@Override</span>\r\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">putAll</span><span class=\"hljs-params\">(IMap&lt;? extends K, ? extends V&gt; map)</span> </span>{\r\n        <span class=\"hljs-comment\">// TODO Auto-generated method stub</span>\r\n\r\n    }\r\n\r\n    <span class=\"hljs-meta\">@Override</span>\r\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> V <span class=\"hljs-title\">remove</span><span class=\"hljs-params\">(K key)</span> </span>{\r\n        <span class=\"hljs-comment\">//得到key的hash值</span>\r\n        <span class=\"hljs-keyword\">int</span> index = hash(key);\r\n        <span class=\"hljs-comment\">//如果该桶为空直接返回</span>\r\n        <span class=\"hljs-keyword\">if</span> (buckets[index] == <span class=\"hljs-keyword\">null</span>){\r\n            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">null</span>;\r\n        }\r\n        <span class=\"hljs-comment\">//遍历桶匹配key值</span>\r\n        Node&lt;K, V&gt; node = buckets[index];\r\n        Node&lt;K, V&gt; pre = node;\r\n        <span class=\"hljs-keyword\">while</span> (node != <span class=\"hljs-keyword\">null</span>){\r\n            <span class=\"hljs-keyword\">if</span> (node.key == key || node.key.hashCode() == key.hashCode() &amp;&amp; node.key.equals(key)){\r\n                <span class=\"hljs-keyword\">if</span> (node == pre){\r\n                    buckets[index] = <span class=\"hljs-keyword\">null</span>;\r\n                }<span class=\"hljs-keyword\">else</span>{\r\n                    pre.next = node.next;\r\n                }\r\n                size--;\r\n                <span class=\"hljs-keyword\">return</span> node.value;\r\n            }\r\n            pre = node;\r\n            node = node.next;\r\n        }\r\n\r\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">null</span>;\r\n    }\r\n\r\n    <span class=\"hljs-meta\">@Override</span>\r\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">size</span><span class=\"hljs-params\">()</span> </span>{\r\n        <span class=\"hljs-keyword\">return</span> size;\r\n    }\r\n    <span class=\"hljs-meta\">@Override</span>\r\n    <span class=\"hljs-keyword\">public</span> Iterator&lt;Node&lt;K, V&gt;&gt; iterator(){\r\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> Iterator&lt;Node&lt;K, V&gt;&gt;() {\r\n            <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">int</span> i;\r\n            <span class=\"hljs-keyword\">private</span> Node&lt;K, V&gt; p = buckets[i];\r\n            <span class=\"hljs-meta\">@Override</span>\r\n            <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">boolean</span> <span class=\"hljs-title\">hasNext</span><span class=\"hljs-params\">()</span> </span>{\r\n                <span class=\"hljs-keyword\">while</span> (i &lt; length &amp;&amp; p == <span class=\"hljs-keyword\">null</span>){\r\n                    i++;\r\n                    <span class=\"hljs-keyword\">if</span> (i == <span class=\"hljs-number\">16</span>){\r\n                        <span class=\"hljs-keyword\">break</span>;\r\n                    }\r\n                    p = buckets[i];\r\n                }\r\n                <span class=\"hljs-keyword\">return</span> p != <span class=\"hljs-keyword\">null</span>;\r\n            }\r\n\r\n            <span class=\"hljs-meta\">@Override</span>\r\n            <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> Node&lt;K, V&gt; <span class=\"hljs-title\">next</span><span class=\"hljs-params\">()</span> </span>{\r\n                Node&lt;K, V&gt; node = p;\r\n                p = p.next;\r\n                <span class=\"hljs-keyword\">return</span> node;\r\n            }\r\n        };\r\n    }\r\n    <span class=\"hljs-meta\">@Override</span>\r\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> String <span class=\"hljs-title\">toString</span><span class=\"hljs-params\">()</span> </span>{\r\n        StringBuilder res = <span class=\"hljs-keyword\">new</span> StringBuilder(<span class=\"hljs-string\">\"[\"</span>);\r\n        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; buckets.length; i++) {\r\n            Node&lt;K, V&gt; p = buckets[i];\r\n            <span class=\"hljs-keyword\">while</span> (p != <span class=\"hljs-keyword\">null</span>){\r\n                res.append(<span class=\"hljs-string\">\"[\"</span> + p.key + <span class=\"hljs-string\">\",\"</span> + p.value + <span class=\"hljs-string\">\"],\"</span>);\r\n                p = p.next;\r\n            }\r\n        }\r\n        res.append(<span class=\"hljs-string\">\"]\"</span>);\r\n\r\n        <span class=\"hljs-keyword\">return</span> res.toString();\r\n    }\r\n}\r\n\r\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Node</span>&lt;<span class=\"hljs-title\">K</span>, <span class=\"hljs-title\">V</span>&gt;</span>{\r\n    K key;\r\n    V value;\r\n\r\n    Node&lt;K, V&gt; next;\r\n\r\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-title\">Node</span><span class=\"hljs-params\">(K key, V value)</span> </span>{\r\n        <span class=\"hljs-keyword\">super</span>();\r\n        <span class=\"hljs-keyword\">this</span>.key = key;\r\n        <span class=\"hljs-keyword\">this</span>.value = value;\r\n    }\r\n}\r\n</code></pre>', '# HashMap源码分析\r\nxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx\r\n# HashMap数据结构\r\nxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx\r\n# 实现自己的HashMap\r\n```java\r\npublic class MyHashMap<K, V> implements IMap<K, V> {\r\n	//容量\r\n	private int length = 16;\r\n	//map的容器\r\n	private Node[] buckets = new Node[length];\r\n	//map大小\r\n	private int size;\r\n\r\n	@Override\r\n	public void clear() {\r\n		for (int i = 0; i < buckets.length; i++) {\r\n			buckets[i] = null;\r\n		}\r\n		size = 0;\r\n	}\r\n\r\n	@Override\r\n	public boolean containsKey(K key) {\r\n		//得到key的hash值\r\n		int index = hash(key);\r\n		//如果该桶为空直接返回\r\n		if (buckets[index] == null){\r\n			return false;\r\n		}\r\n		//遍历桶匹配key值\r\n		Node<K, V> node = buckets[index];\r\n		while (node != null){\r\n			if (node.key == key || node.key.hashCode() == key.hashCode() && node.key.equals(key)){\r\n				return true;\r\n			}\r\n			node = node.next;\r\n		}\r\n		\r\n		return false;\r\n	}\r\n\r\n	@Override\r\n	public boolean containsValue(V value) {\r\n		//遍历桶匹配value值\r\n		for (int i = 0; i < buckets.length; i++) {\r\n			Node<K, V> node = buckets[i];\r\n			while (node != null){\r\n				if (node.value.equals(value)){\r\n					return true;\r\n				}\r\n				node = node.next;\r\n			}\r\n		}\r\n		return false;\r\n	}\r\n\r\n	@Override\r\n	public V get(K key) {\r\n		//得到key的hash值\r\n		int index = hash(key);\r\n		//如果该桶为空直接返回\r\n		if (buckets[index] == null){\r\n			return null;\r\n		}\r\n		//遍历桶匹配key值\r\n		Node<K, V> node = buckets[index];\r\n		while (node != null){\r\n			if (node.key == key || node.key.hashCode() == key.hashCode() && node.key.equals(key)){\r\n				return node.value;\r\n			}\r\n			node = node.next;\r\n		}\r\n		\r\n		return null;\r\n	}\r\n\r\n	@Override\r\n	public boolean isEmpty() {\r\n		return size == 0;\r\n	}\r\n\r\n	@Override\r\n	public ISet<K> keySet() {\r\n		ISet<K> set = new MyHashSet<>();\r\n		for (int i = 0; i < buckets.length; i++) {\r\n			Node<K, V> temp = buckets[i];\r\n			while (temp != null){\r\n				set.add(temp.key);\r\n				temp = temp.next;\r\n			}\r\n		}\r\n		return set;\r\n	}\r\n\r\n	@Override\r\n	public V[] values() {\r\n		// TODO Auto-generated method stub\r\n		return null;\r\n	}\r\n\r\n	@Override\r\n	public void put(K key, V value) {\r\n		Node<K, V> temp = new Node<K, V>(key, value);\r\n		int index = hash(key);\r\n		Node<K, V> node = buckets[index];\r\n		//判断该桶中是否有元素\r\n		if (node == null){\r\n			//如果为空直接放入该元素\r\n			buckets[index] = temp;\r\n		}else{\r\n			//遍历链表到末尾\r\n			while (node != null){\r\n				//判重\r\n				if (node.key == key || node.hashCode() == temp.hashCode() && node.key.equals(temp.key)){\r\n					//如有重复更新value值\r\n					node.value = value;\r\n					return;\r\n				}\r\n				node = node.next;\r\n				if (node.next == null){\r\n					break;\r\n				}\r\n			}\r\n			\r\n			//将该元素添加到链表末尾\r\n			node.next = temp;\r\n		}\r\n		size++;\r\n	}\r\n\r\n	private int hash(K key) {\r\n		return key.hashCode() % 16;\r\n	}\r\n\r\n	@Override\r\n	public void putAll(IMap<? extends K, ? extends V> map) {\r\n		// TODO Auto-generated method stub\r\n		\r\n	}\r\n\r\n	@Override\r\n	public V remove(K key) {\r\n		//得到key的hash值\r\n		int index = hash(key);\r\n		//如果该桶为空直接返回\r\n		if (buckets[index] == null){\r\n			return null;\r\n		}\r\n		//遍历桶匹配key值\r\n		Node<K, V> node = buckets[index];\r\n		Node<K, V> pre = node;\r\n		while (node != null){\r\n			if (node.key == key || node.key.hashCode() == key.hashCode() && node.key.equals(key)){\r\n				if (node == pre){\r\n					buckets[index] = null;\r\n				}else{\r\n					pre.next = node.next;\r\n				}\r\n				size--;\r\n				return node.value;\r\n			}\r\n			pre = node;\r\n			node = node.next;\r\n		}\r\n		\r\n		return null;\r\n	}\r\n\r\n	@Override\r\n	public int size() {\r\n		return size;\r\n	}\r\n	@Override\r\n	public Iterator<Node<K, V>> iterator(){\r\n		return new Iterator<Node<K, V>>() {\r\n			private int i;\r\n			private Node<K, V> p = buckets[i];\r\n			@Override\r\n			public boolean hasNext() {\r\n				while (i < length && p == null){\r\n					i++;\r\n					if (i == 16){\r\n						break;\r\n					}\r\n					p = buckets[i];\r\n				}\r\n				return p != null;\r\n			}\r\n\r\n			@Override\r\n			public Node<K, V> next() {\r\n				Node<K, V> node = p;\r\n				p = p.next;\r\n				return node;\r\n			}\r\n		};\r\n	}\r\n	@Override\r\n	public String toString() {\r\n		StringBuilder res = new StringBuilder(\"[\");\r\n		for (int i = 0; i < buckets.length; i++) {\r\n			Node<K, V> p = buckets[i];\r\n			while (p != null){\r\n				res.append(\"[\" + p.key + \",\" + p.value + \"],\");\r\n				p = p.next;\r\n			}\r\n		}\r\n		res.append(\"]\");\r\n		\r\n		return res.toString();\r\n	}\r\n}\r\n\r\nclass Node<K, V>{\r\n	K key;\r\n	V value;\r\n	\r\n	Node<K, V> next;\r\n\r\n	public Node(K key, V value) {\r\n		super();\r\n		this.key = key;\r\n		this.value = value;\r\n	}\r\n}\r\n```', '2020-06-24 10:58:13', '0', 'HashMap源码分析xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxHas', '/static/img/rand/7.jpg', 'HashMap', '0', 'post', '0', '2020-06-24 10:58:13', '2020-6-23', null);
INSERT INTO `plog_article` VALUES ('156', '14', '<h3 id=\"-\">分治法</h3>\r\n<ul>\r\n<li>分治法(divide and conquer，D&amp;C) :将原问题划分成若干个规模较小而结构与原问题一致的子问题;递归地解决这些子问题,然后再合并其结果,就得到原问题的解。</li>\r\n<li>容易确定运行时间,是分治算法的优点之一。</li>\r\n<li>分治模式在每一层递归 上都有三个步骤<br>  -分解(Divide) :将原问题分解成一系列子问题;<br>  -解决(Conquer):递归地解各子问题。若子问题足够小,则直接有解;<br>  -合并(Combine):將子问题的结果合并成原问题的解。</li>\r\n</ul>\r\n<h3 id=\"-\">分治法应用</h3>\r\n<h4 id=\"-\">快速排序--重点</h4>\r\n<pre><code class=\"lang-java\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">quickSort</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span>[] arr, <span class=\"hljs-keyword\">int</span> l, <span class=\"hljs-keyword\">int</span> r)</span></span>{\r\n    <span class=\"hljs-keyword\">if</span> (l &lt; r){\r\n        <span class=\"hljs-comment\">//将待排序集合按p分区，p左侧为小于它的元素，右侧为大于它的元素</span>\r\n        <span class=\"hljs-keyword\">int</span> p = partition2(arr, l, r);\r\n\r\n        <span class=\"hljs-comment\">//对左侧分区排序</span>\r\n        quickSort(arr, l, p - <span class=\"hljs-number\">1</span>);\r\n        <span class=\"hljs-comment\">//对右侧分区排序</span>\r\n        quickSort(arr, p + <span class=\"hljs-number\">1</span>, r);\r\n    }\r\n}\r\n\r\n<span class=\"hljs-comment\">//交换数组中的两个元素</span>\r\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">swap</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span>[] arr, <span class=\"hljs-keyword\">int</span> a, <span class=\"hljs-keyword\">int</span> b)</span></span>{\r\n    <span class=\"hljs-keyword\">int</span> t = arr[a];\r\n    arr[a] = arr[b];\r\n    arr[b] = t;\r\n}\r\n</code></pre>\r\n<ul>\r\n<li><p>快速排序的划分方法：</p>\r\n<ol>\r\n<li><p>单向扫描法</p>\r\n<pre><code class=\"lang-java\"><span class=\"hljs-comment\">//单向扫描法</span>\r\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">partition</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span>[] arr, <span class=\"hljs-keyword\">int</span> p, <span class=\"hljs-keyword\">int</span> r)</span> </span>{\r\n <span class=\"hljs-keyword\">int</span> pivot = arr[p];    <span class=\"hljs-comment\">//选取第一个元素为key值</span>\r\n <span class=\"hljs-keyword\">int</span> sp = p + <span class=\"hljs-number\">1</span>;    <span class=\"hljs-comment\">//扫描指针 从左往右扫描</span>\r\n <span class=\"hljs-keyword\">int</span> bigger = r;    <span class=\"hljs-comment\">//bigger指针 右侧为大于key值得元素</span>\r\n <span class=\"hljs-comment\">//sp向右扫描直到和bigger交错</span>\r\n <span class=\"hljs-keyword\">while</span> (sp &lt;= bigger){\r\n     <span class=\"hljs-comment\">//sp一直向右直到找到大于p的元素</span>\r\n     <span class=\"hljs-keyword\">if</span> (arr[sp] &lt;= pivot){\r\n         sp++;\r\n     }<span class=\"hljs-keyword\">else</span>{\r\n         <span class=\"hljs-comment\">//把大于p的元素交换到最右侧</span>\r\n         swap(arr, sp, bigger);\r\n         bigger--;    <span class=\"hljs-comment\">//bigger指针左移，增加一个大于p的元素</span>\r\n     }\r\n }\r\n <span class=\"hljs-comment\">//将选取的key值交换到中间位置</span>\r\n swap(arr, p, bigger);\r\n\r\n <span class=\"hljs-keyword\">return</span> bigger;\r\n}\r\n</code></pre>\r\n</li>\r\n<li><p>双向扫描法</p>\r\n<pre><code class=\"lang-java\"><span class=\"hljs-comment\">//双向扫描法</span>\r\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">partition2</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span>[] arr, <span class=\"hljs-keyword\">int</span> p, <span class=\"hljs-keyword\">int</span> r)</span></span>{\r\n <span class=\"hljs-keyword\">int</span> pivot = arr[p];    <span class=\"hljs-comment\">//把第一个元素作为key值</span>\r\n <span class=\"hljs-keyword\">int</span> left = p + <span class=\"hljs-number\">1</span>;    <span class=\"hljs-comment\">//左指针</span>\r\n <span class=\"hljs-keyword\">int</span> right = r;        <span class=\"hljs-comment\">//右指针</span>\r\n\r\n <span class=\"hljs-keyword\">while</span> (left &lt;= right){\r\n     <span class=\"hljs-comment\">//left向右扫描找到第一个大于key的元素</span>\r\n     <span class=\"hljs-keyword\">while</span> (left &lt;= right &amp;&amp; arr[left] &lt;= pivot){\r\n         left++;\r\n     }\r\n     <span class=\"hljs-comment\">//right向左扫描找到第一个小于key的元素</span>\r\n     <span class=\"hljs-keyword\">while</span> (left &lt;= right &amp;&amp; arr[right] &gt; pivot){\r\n         right--;\r\n     }\r\n     <span class=\"hljs-comment\">//如果left和right没有交错</span>\r\n     <span class=\"hljs-keyword\">if</span> (left &lt; right){\r\n         <span class=\"hljs-comment\">//交换两个元素</span>\r\n         swap(arr, left, right);\r\n     }\r\n }\r\n <span class=\"hljs-comment\">//把key值交换到中间</span>\r\n swap(arr, p, right);\r\n <span class=\"hljs-keyword\">return</span> right;\r\n}\r\n</code></pre>\r\n</li>\r\n<li><p>有相同元素值的快速排序--三分法</p>\r\n<ul>\r\n<li><p>增加e指针，将相同元素放到中间区域</p>\r\n<pre><code class=\"lang-java\"><span class=\"hljs-comment\">//三指针分区法</span>\r\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">quickSort3</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span>[] arr, <span class=\"hljs-keyword\">int</span> i, <span class=\"hljs-keyword\">int</span> j)</span></span>{\r\n<span class=\"hljs-keyword\">if</span> (i &gt;= j){\r\n  <span class=\"hljs-keyword\">return</span>;\r\n}\r\n<span class=\"hljs-keyword\">int</span> key = arr[i];\r\n<span class=\"hljs-keyword\">int</span> sp = i + <span class=\"hljs-number\">1</span>;\r\n<span class=\"hljs-keyword\">int</span> e = sp;\r\n<span class=\"hljs-keyword\">int</span> bigger = j;\r\n<span class=\"hljs-keyword\">while</span> (sp &lt;= bigger){\r\n  <span class=\"hljs-keyword\">if</span> (arr[sp] == key){\r\n      <span class=\"hljs-keyword\">if</span>(e == i + <span class=\"hljs-number\">1</span>)\r\n      e = sp;\r\n      sp++;\r\n  }<span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (arr[sp] &lt; key){\r\n      <span class=\"hljs-keyword\">if</span>(e != i + <span class=\"hljs-number\">1</span>){\r\n\r\n          <span class=\"hljs-keyword\">int</span> t = arr[e];\r\n          arr[e] = arr[sp];\r\n          arr[sp] = t;\r\n          e++;\r\n      }\r\n      sp++;\r\n  }<span class=\"hljs-keyword\">else</span>{\r\n      <span class=\"hljs-keyword\">int</span> t = arr[sp];\r\n      arr[sp] = arr[bigger];\r\n      arr[bigger] = t;\r\n      bigger--;\r\n  }\r\n}\r\n<span class=\"hljs-keyword\">if</span> (arr[e] == key){\r\n  e--;\r\n}<span class=\"hljs-keyword\">else</span>{\r\n  e = bigger;\r\n}\r\n<span class=\"hljs-keyword\">int</span> t = arr[e];\r\narr[e] = key;\r\narr[i] = t;\r\nquickSort3(arr, i, e - <span class=\"hljs-number\">1</span>);\r\nquickSort3(arr, bigger + <span class=\"hljs-number\">1</span>, j);\r\n}\r\n</code></pre>\r\n</li>\r\n</ul>\r\n</li>\r\n</ol>\r\n</li>\r\n<li><p>工程实践中的其他优化(主要针对key元素的选取，找到合适的中间值)：</p>\r\n</li>\r\n<li><p>三点中值法</p>\r\n<pre><code class=\"lang-java\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">partition2</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span>[] arr, <span class=\"hljs-keyword\">int</span> p, <span class=\"hljs-keyword\">int</span> r)</span></span>{\r\n <span class=\"hljs-comment\">//优化：三点中值法 找到中间值作为key</span>\r\n <span class=\"hljs-keyword\">int</span> mid = (p+r)/<span class=\"hljs-number\">2</span>;\r\n <span class=\"hljs-keyword\">int</span> midInd;\r\n\r\n <span class=\"hljs-keyword\">if</span> ((arr[p] &gt; arr[mid] &amp;&amp; arr[p] &lt; arr[r]) || (arr[p] &gt; arr[r] &amp;&amp; arr[p] &lt; arr[mid])){\r\n     midInd = p;        <span class=\"hljs-comment\">//如果p指向中间值</span>\r\n }<span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> ((arr[mid] &gt; arr[p] &amp;&amp; arr[mid] &lt; arr[r]) || (arr[mid] &gt; arr[r] &amp;&amp; arr[mid] &lt; arr[p])){\r\n     midInd = mid;    <span class=\"hljs-comment\">//mid指向中间值</span>\r\n }<span class=\"hljs-keyword\">else</span>{\r\n     midInd = r;        <span class=\"hljs-comment\">//r指向中间值</span>\r\n }\r\n swap(arr, p, midInd);    <span class=\"hljs-comment\">//把三点中的中间值换到key的位置</span>\r\n\r\n <span class=\"hljs-keyword\">int</span> pivot = arr[p];    <span class=\"hljs-comment\">//把第一个元素作为key值</span>\r\n <span class=\"hljs-keyword\">int</span> left = p + <span class=\"hljs-number\">1</span>;    <span class=\"hljs-comment\">//左指针</span>\r\n <span class=\"hljs-keyword\">int</span> right = r;        <span class=\"hljs-comment\">//右指针</span>\r\n\r\n <span class=\"hljs-keyword\">while</span> (left &lt;= right){\r\n     <span class=\"hljs-comment\">//left向右扫描找到第一个大于key的元素</span>\r\n     <span class=\"hljs-keyword\">while</span> (left &lt;= right &amp;&amp; arr[left] &lt;= pivot){\r\n         left++;\r\n     }\r\n     <span class=\"hljs-comment\">//right向左扫描找到第一个小于key的元素</span>\r\n     <span class=\"hljs-keyword\">while</span> (left &lt;= right &amp;&amp; arr[right] &gt; pivot){\r\n         right--;\r\n     }\r\n     <span class=\"hljs-comment\">//如果left和right没有交错</span>\r\n     <span class=\"hljs-keyword\">if</span> (left &lt; right){\r\n         <span class=\"hljs-comment\">//交换两个元素</span>\r\n         swap(arr, left, right);\r\n     }\r\n }\r\n <span class=\"hljs-comment\">//把key值交换到中间</span>\r\n swap(arr, p, right);\r\n <span class=\"hljs-keyword\">return</span> right;\r\n}\r\n</code></pre>\r\n</li>\r\n<li><p>绝对中值法</p>\r\n<pre><code class=\"lang-java\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">getMedian</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span>[] arr, <span class=\"hljs-keyword\">int</span> p, <span class=\"hljs-keyword\">int</span> r)</span> </span>{\r\n<span class=\"hljs-keyword\">if</span> (arr.length == <span class=\"hljs-number\">1</span>)\r\n <span class=\"hljs-keyword\">return</span> arr[p];\r\n<span class=\"hljs-keyword\">int</span> size = r - p + <span class=\"hljs-number\">1</span>;<span class=\"hljs-comment\">// 数组长度</span>\r\n<span class=\"hljs-comment\">//每五个元素一组</span>\r\n<span class=\"hljs-keyword\">int</span> groupSize = (size % <span class=\"hljs-number\">5</span> == <span class=\"hljs-number\">0</span>) ? (size / <span class=\"hljs-number\">5</span>) : (size / <span class=\"hljs-number\">5</span> + <span class=\"hljs-number\">1</span>);\r\n<span class=\"hljs-comment\">//存储各小组的中值</span>\r\n<span class=\"hljs-keyword\">int</span> medians[] = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-keyword\">int</span>[groupSize];\r\n<span class=\"hljs-keyword\">int</span> indexOfMedians = <span class=\"hljs-number\">0</span>;\r\n<span class=\"hljs-comment\">//对每一组进行插入排序</span>\r\n<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> j = <span class=\"hljs-number\">0</span>; j &lt; groupSize; j++) {\r\n <span class=\"hljs-comment\">//单独处理最后一组，因为最后一组可能不满5个元素</span>\r\n <span class=\"hljs-keyword\">if</span> (j == groupSize - <span class=\"hljs-number\">1</span>) {\r\n _3InsertionSort.sort(arr, p + j * <span class=\"hljs-number\">5</span>, r); <span class=\"hljs-comment\">// 排序最后一组</span>\r\n medians[indexOfMedians++] = arr[(p + j * <span class=\"hljs-number\">5</span> + r) / <span class=\"hljs-number\">2</span>]; <span class=\"hljs-comment\">// 最后一组的中间那个</span>\r\n } <span class=\"hljs-keyword\">else</span> {\r\n _3InsertionSort.sort(arr, p + j * <span class=\"hljs-number\">5</span>, p + j * <span class=\"hljs-number\">5</span> + <span class=\"hljs-number\">4</span>);  <span class=\"hljs-comment\">// 排序非最后一组的某个组</span>\r\n medians[indexOfMedians++] = arr[p + j * <span class=\"hljs-number\">5</span> + <span class=\"hljs-number\">2</span>];  <span class=\"hljs-comment\">// 当前组（排序后）的中间那个</span>\r\n }\r\n}\r\n<span class=\"hljs-keyword\">return</span> getMedian(medians, <span class=\"hljs-number\">0</span>, medians.length - <span class=\"hljs-number\">1</span>);\r\n}\r\n</code></pre>\r\n</li>\r\n<li><p>待排序列表较短时，用插入排序</p>\r\n<pre><code class=\"lang-java\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">quickSort</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span>[] arr, <span class=\"hljs-keyword\">int</span> l, <span class=\"hljs-keyword\">int</span> r)</span></span>{\r\n <span class=\"hljs-keyword\">int</span> length = (r - l) + <span class=\"hljs-number\">1</span>;\r\n <span class=\"hljs-comment\">//如果待排序元素小于等于8个则使用插入排序效率更高</span>\r\n <span class=\"hljs-keyword\">if</span> (length &lt;= <span class=\"hljs-number\">8</span>){\r\n     _2_递归基础.insertSort(arr, arr.length - <span class=\"hljs-number\">1</span>);\r\n }<span class=\"hljs-keyword\">else</span>{\r\n     <span class=\"hljs-keyword\">if</span> (l &lt; r){\r\n         <span class=\"hljs-comment\">//将待排序集合按p分区，p左侧为小于它的元素，右侧为大于它的元素</span>\r\n         <span class=\"hljs-keyword\">int</span> p = partition2(arr, l, r);\r\n\r\n         <span class=\"hljs-comment\">//对左侧分区排序</span>\r\n         quickSort(arr, l, p - <span class=\"hljs-number\">1</span>);\r\n         <span class=\"hljs-comment\">//对右侧分区排序</span>\r\n         quickSort(arr, p + <span class=\"hljs-number\">1</span>, r);\r\n     }\r\n }\r\n}\r\n</code></pre>\r\n</li>\r\n</ul>\r\n<h4 id=\"-\">归并排序</h4>\r\n<pre><code class=\"lang-java\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">main</span>(<span class=\"hljs-params\">String[] args</span>) </span>{\r\n    <span class=\"hljs-keyword\">int</span>[] arr = {<span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">5</span>, <span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">9</span>, <span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">7</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">3</span>};\r\n    System.<span class=\"hljs-keyword\">out</span>.println(Arrays.toString(arr));\r\n    mergeSort(arr, <span class=\"hljs-number\">0</span>, arr.length - <span class=\"hljs-number\">1</span>);\r\n    System.<span class=\"hljs-keyword\">out</span>.println(Arrays.toString(arr));\r\n}\r\n<span class=\"hljs-comment\">//归并排序</span>\r\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">mergeSort</span>(<span class=\"hljs-params\"><span class=\"hljs-keyword\">int</span>[] arr, <span class=\"hljs-keyword\">int</span> l, <span class=\"hljs-keyword\">int</span> r</span>)</span>{\r\n    <span class=\"hljs-keyword\">if</span> (l &lt; r){\r\n        <span class=\"hljs-comment\">//得到中间下标</span>\r\n        <span class=\"hljs-keyword\">int</span> mid = l + ((r-l)&gt;&gt;<span class=\"hljs-number\">1</span>);\r\n        <span class=\"hljs-comment\">//左侧排序</span>\r\n        mergeSort(arr, l, mid);\r\n        <span class=\"hljs-comment\">//右侧排序</span>\r\n        mergeSort(arr, mid+<span class=\"hljs-number\">1</span>,r);\r\n        <span class=\"hljs-comment\">//合并</span>\r\n        merge(arr, l, mid, r);\r\n    }\r\n}\r\n<span class=\"hljs-comment\">//将数组中有序的两段[l,mid],[mid+1,r]合并为一段</span>\r\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">merge</span>(<span class=\"hljs-params\"><span class=\"hljs-keyword\">int</span>[] arr, <span class=\"hljs-keyword\">int</span> l, <span class=\"hljs-keyword\">int</span> mid, <span class=\"hljs-keyword\">int</span> r</span>) </span>{\r\n    <span class=\"hljs-keyword\">int</span>[] arrCopy = Arrays.copyOf(arr, arr.length);    <span class=\"hljs-comment\">//拷贝原数组</span>\r\n    <span class=\"hljs-keyword\">int</span> left = l;    <span class=\"hljs-comment\">//左指针指向左边区域开始</span>\r\n    <span class=\"hljs-keyword\">int</span> right = mid+<span class=\"hljs-number\">1</span>;    <span class=\"hljs-comment\">//右指针指向右边开始</span>\r\n    <span class=\"hljs-keyword\">int</span> p = l;    <span class=\"hljs-comment\">//p指向原数组开始位置</span>\r\n\r\n    <span class=\"hljs-comment\">//合并两段有序元素</span>\r\n    <span class=\"hljs-keyword\">while</span> (left &lt;= mid &amp;&amp; right &lt;= r){\r\n        <span class=\"hljs-keyword\">if</span> (arrCopy[left] &lt;= arrCopy[right]){\r\n            arr[p++] = arrCopy[left++];\r\n        }<span class=\"hljs-keyword\">else</span>{\r\n            arr[p++] = arrCopy[right++];\r\n        }\r\n    }\r\n    <span class=\"hljs-comment\">//左边区域没有拷贝完成的情况继续拷贝 右边区域出现此情况不需要拷贝</span>\r\n    <span class=\"hljs-keyword\">while</span> (left &lt;= mid){\r\n        arr[p++] = arrCopy[left++];\r\n    }\r\n}\r\n</code></pre>\r\n<h4 id=\"-\">案例</h4>\r\n<ol>\r\n<li><p>调整数组元素顺序，使奇数位于前半部分，偶数位于后半部分。</p>\r\n<pre><code class=\"lang-java\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">main</span>(<span class=\"hljs-params\">String[] args</span>) </span>{\r\n <span class=\"hljs-keyword\">int</span>[] arr = { <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">8</span>, <span class=\"hljs-number\">5</span>, <span class=\"hljs-number\">9</span>, <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">2</span> };\r\n System.<span class=\"hljs-keyword\">out</span>.println(Arrays.toString(arr));\r\n <span class=\"hljs-keyword\">int</span> l = <span class=\"hljs-number\">0</span>;\r\n <span class=\"hljs-keyword\">int</span> r = arr.length - <span class=\"hljs-number\">1</span>;\r\n\r\n <span class=\"hljs-keyword\">while</span> (l &lt;= r){\r\n     <span class=\"hljs-comment\">//从左边找第一个不是奇数的元素</span>\r\n     <span class=\"hljs-keyword\">while</span> (l &lt;= r &amp;&amp; arr[l] % <span class=\"hljs-number\">2</span> != <span class=\"hljs-number\">0</span>){\r\n         l++;\r\n     }\r\n     <span class=\"hljs-comment\">//从右边找第一个不是偶数的元素</span>\r\n     <span class=\"hljs-keyword\">while</span> (l &lt;= r &amp;&amp; arr[r] % <span class=\"hljs-number\">2</span> == <span class=\"hljs-number\">0</span>){\r\n         r--;\r\n     }\r\n     <span class=\"hljs-comment\">//交换两个元素</span>\r\n     <span class=\"hljs-keyword\">if</span> (l &lt; r)\r\n     QuickSort.swap(arr, l, r);\r\n }\r\n\r\n System.<span class=\"hljs-keyword\">out</span>.println(Arrays.toString(arr));\r\n}\r\n</code></pre>\r\n</li>\r\n<li><p>第k个元素</p>\r\n<ul>\r\n<li>以尽量高的效率求出一个乱序数组中按数值顺序的第k个元素值<pre><code class=\"lang-java\"><span class=\"hljs-comment\">//第k个元素</span>\r\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">selectK</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span>[] arr, <span class=\"hljs-keyword\">int</span> l, <span class=\"hljs-keyword\">int</span> r, <span class=\"hljs-keyword\">int</span> k)</span></span>{\r\n  <span class=\"hljs-comment\">//分区</span>\r\n  <span class=\"hljs-keyword\">int</span> p = QuickSort.partition2(arr, l, r);\r\n  <span class=\"hljs-keyword\">int</span> q = p;\r\n  <span class=\"hljs-comment\">//判断分区下标是否为查找的第k个元素</span>\r\n  <span class=\"hljs-keyword\">if</span> (k == q){\r\n      <span class=\"hljs-keyword\">return</span> arr[q];\r\n  }<span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (k &lt; q){\r\n      <span class=\"hljs-comment\">//在左侧继续查找</span>\r\n      <span class=\"hljs-keyword\">return</span> selectK(arr, l, p - <span class=\"hljs-number\">1</span>, k);\r\n  }<span class=\"hljs-keyword\">else</span>{\r\n      <span class=\"hljs-comment\">//在右侧继续查找</span>\r\n      <span class=\"hljs-keyword\">return</span> selectK(arr, p+<span class=\"hljs-number\">1</span>, r, k);\r\n  }\r\n}\r\n</code></pre>\r\n</li>\r\n</ul>\r\n</li>\r\n<li><p>超过一半的数字</p>\r\n<ul>\r\n<li>数组中有一个数字出现的次数超过了数组长度的一半，找出这个数字。</li>\r\n<li><p>排序后数组的第length/2个元素一定为所求数字。</p>\r\n<pre><code class=\"lang-java\"><span class=\"hljs-comment\">//超过数组一半的数字</span>\r\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">fun</span>(<span class=\"hljs-params\"></span>)</span>{\r\n  <span class=\"hljs-keyword\">int</span>[] arr = {<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">5</span>};\r\n  <span class=\"hljs-comment\">//利用查找第k个元素，最中间的元素一定为超过数组一半的元素</span>\r\n  System.<span class=\"hljs-keyword\">out</span>.println(selectK(arr, <span class=\"hljs-number\">0</span>, arr.length - <span class=\"hljs-number\">1</span>, arr.length / <span class=\"hljs-number\">2</span>));\r\n  <span class=\"hljs-comment\">//消除法</span>\r\n  <span class=\"hljs-keyword\">int</span> num = arr[<span class=\"hljs-number\">0</span>];\r\n  <span class=\"hljs-keyword\">int</span> n = <span class=\"hljs-number\">1</span>;\r\n  <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">1</span>; i &lt; arr.length; i++) {\r\n      <span class=\"hljs-comment\">//如果个数消到0则换下一个元素</span>\r\n      <span class=\"hljs-keyword\">if</span> (n == <span class=\"hljs-number\">0</span>){\r\n          num = arr[i];\r\n          n = <span class=\"hljs-number\">1</span>;\r\n      }\r\n      <span class=\"hljs-comment\">//如果相同则累加，不同则消除</span>\r\n      <span class=\"hljs-keyword\">if</span> (num == arr[i]){\r\n          n++;\r\n      }<span class=\"hljs-keyword\">else</span>{\r\n          n--;\r\n      }\r\n  }\r\n\r\n  System.<span class=\"hljs-keyword\">out</span>.println(num);\r\n}\r\n</code></pre>\r\n</li>\r\n<li><p>寻找水王：出现次数恰好为个数的一半，求出这个数</p>\r\n<pre><code class=\"lang-java\"><span class=\"hljs-comment\">//寻找水王 某个数正好为数组的一半</span>\r\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">fun2</span>(<span class=\"hljs-params\"></span>)</span>{\r\n  <span class=\"hljs-keyword\">int</span>[] arr = {<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">2</span>,<span class=\"hljs-number\">3</span>,<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">4</span>,<span class=\"hljs-number\">5</span>,<span class=\"hljs-number\">1</span>};\r\n\r\n  <span class=\"hljs-keyword\">int</span> num = arr[<span class=\"hljs-number\">0</span>];    <span class=\"hljs-comment\">//存储数组元素</span>\r\n  <span class=\"hljs-keyword\">int</span> n = <span class=\"hljs-number\">0</span>;    <span class=\"hljs-comment\">//元素出现的次数</span>\r\n  <span class=\"hljs-keyword\">int</span> endCount = <span class=\"hljs-number\">0</span>;    <span class=\"hljs-comment\">//最后一个元素出现的次数</span>\r\n\r\n  <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; arr.length; i++) {\r\n      <span class=\"hljs-comment\">//统计最后一个元素出现次数</span>\r\n      <span class=\"hljs-keyword\">if</span> (arr[i] == arr[arr.length - <span class=\"hljs-number\">1</span>]){\r\n          endCount++;\r\n      }\r\n      <span class=\"hljs-comment\">//如果两两元素消除则继续下一元素</span>\r\n      <span class=\"hljs-keyword\">if</span> (n == <span class=\"hljs-number\">0</span>){\r\n          num = arr[i];\r\n          n = <span class=\"hljs-number\">1</span>;\r\n          <span class=\"hljs-keyword\">continue</span>;\r\n      }\r\n      <span class=\"hljs-comment\">//相同累加 不同消减</span>\r\n      <span class=\"hljs-keyword\">if</span> (arr[i] == num){\r\n          n++;\r\n      }<span class=\"hljs-keyword\">else</span>{\r\n          n--;\r\n      }\r\n  }\r\n  <span class=\"hljs-comment\">//正好等于一半的元素一定在最后一个或者消减完之后Num中存储的值</span>\r\n  <span class=\"hljs-keyword\">if</span> (endCount == arr.length / <span class=\"hljs-number\">2</span>){\r\n      System.<span class=\"hljs-keyword\">out</span>.println(arr[arr.length - <span class=\"hljs-number\">1</span>]);\r\n  }<span class=\"hljs-keyword\">else</span>{\r\n      System.<span class=\"hljs-keyword\">out</span>.println(num);\r\n  }\r\n}\r\n</code></pre>\r\n</li>\r\n</ul>\r\n</li>\r\n<li><p>最小可用id</p>\r\n<ul>\r\n<li><p>在非负数组(乱序)中找到最小的可分配的id(从1开编号)，数据量1000000.</p>\r\n<pre><code class=\"lang-java\"><span class=\"hljs-comment\">//最小可用id--&gt;1.排序后判断</span>\r\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">minId</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span>[] arr)</span></span>{\r\n  Arrays.sort(arr);\r\n  <span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">0</span>;\r\n  <span class=\"hljs-keyword\">for</span> (i = <span class=\"hljs-number\">0</span>; i &lt; arr.length; i++) {\r\n      <span class=\"hljs-keyword\">if</span> (i + <span class=\"hljs-number\">1</span> != arr[i])    <span class=\"hljs-keyword\">return</span> i + <span class=\"hljs-number\">1</span>;\r\n  }\r\n\r\n  <span class=\"hljs-keyword\">return</span> i + <span class=\"hljs-number\">1</span>;\r\n}\r\n<span class=\"hljs-comment\">//最小可用id--&gt;2.辅助数组统计</span>\r\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">minId2</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span>[] arr)</span></span>{\r\n  <span class=\"hljs-keyword\">int</span>[] help = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-keyword\">int</span>[arr.length+<span class=\"hljs-number\">1</span>];\r\n\r\n  <span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">0</span>;\r\n  <span class=\"hljs-keyword\">for</span> (i = <span class=\"hljs-number\">0</span>; i &lt; arr.length; i++) {\r\n      <span class=\"hljs-comment\">//防止数组中出现大于下标的数字</span>\r\n      <span class=\"hljs-keyword\">if</span> (arr[i] &lt; help.length)\r\n      help[arr[i]] = <span class=\"hljs-number\">1</span>;\r\n  }\r\n\r\n  <span class=\"hljs-keyword\">for</span> (i = <span class=\"hljs-number\">1</span>; i &lt; help.length; i++) {\r\n      <span class=\"hljs-keyword\">if</span> (help[i] == <span class=\"hljs-number\">0</span>) <span class=\"hljs-keyword\">return</span> i;\r\n  }\r\n\r\n  <span class=\"hljs-keyword\">return</span> i;\r\n}\r\n<span class=\"hljs-comment\">//最小可用id--&gt;3.分区法</span>\r\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">minId3</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span>[] arr, <span class=\"hljs-keyword\">int</span> l, <span class=\"hljs-keyword\">int</span> r)</span></span>{\r\n  <span class=\"hljs-comment\">//l和r交错后结果为l+1</span>\r\n  <span class=\"hljs-keyword\">if</span> (l &gt; r) <span class=\"hljs-keyword\">return</span> l + <span class=\"hljs-number\">1</span>;\r\n  <span class=\"hljs-comment\">//分区</span>\r\n  <span class=\"hljs-keyword\">int</span> mid = QuickSort.partition2(arr, l, r);\r\n  <span class=\"hljs-comment\">//t为第几个元素</span>\r\n  <span class=\"hljs-keyword\">int</span> t = mid + <span class=\"hljs-number\">1</span>;\r\n  <span class=\"hljs-comment\">//如果元素值等于它所在的位置个数则证明左侧连续，需要去右侧找</span>\r\n  <span class=\"hljs-keyword\">if</span> (arr[mid] == t){\r\n      <span class=\"hljs-keyword\">return</span> minId3(arr, mid + <span class=\"hljs-number\">1</span>, r);\r\n  }<span class=\"hljs-keyword\">else</span>{\r\n      <span class=\"hljs-keyword\">return</span> minId3(arr, l, mid - <span class=\"hljs-number\">1</span>);\r\n  }\r\n}\r\n</code></pre>\r\n</li>\r\n</ul>\r\n</li>\r\n</ol>\r\n<h4 id=\"-\">逆序对问题</h4>\r\n<ol>\r\n<li><p>合并有序数组</p>\r\n<ul>\r\n<li><p>给定两个排序后的数组A和B，其中A的末端有足够的缓冲空间容纳B，编写一个方法，将B合并入A并排序。</p>\r\n<pre><code class=\"lang-java\"><span class=\"hljs-comment\">//合并有序数组</span>\r\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">merge</span>(<span class=\"hljs-params\"></span>)</span>{\r\n  <span class=\"hljs-keyword\">int</span>[] arr1 = {<span class=\"hljs-number\">11</span>, <span class=\"hljs-number\">13</span>, <span class=\"hljs-number\">15</span>, <span class=\"hljs-number\">17</span>, <span class=\"hljs-number\">19</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>};\r\n  <span class=\"hljs-keyword\">int</span>[] arr2 = {<span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">6</span>, <span class=\"hljs-number\">8</span>, <span class=\"hljs-number\">10</span>, <span class=\"hljs-number\">11</span>};\r\n\r\n  <span class=\"hljs-keyword\">int</span> p = arr1.length - <span class=\"hljs-number\">1</span>;    <span class=\"hljs-comment\">//指向原数组末尾</span>\r\n  <span class=\"hljs-keyword\">int</span> p1 = <span class=\"hljs-number\">4</span>;    <span class=\"hljs-comment\">//指向原数组有效数据末尾</span>\r\n  <span class=\"hljs-keyword\">int</span> p2 = arr2.length - <span class=\"hljs-number\">1</span>;    <span class=\"hljs-comment\">//指向目标数组末尾</span>\r\n\r\n  <span class=\"hljs-keyword\">while</span> (p1 &gt;= <span class=\"hljs-number\">0</span> &amp;&amp; p2 &gt;= <span class=\"hljs-number\">0</span>){\r\n      <span class=\"hljs-comment\">//判断两个数组中从末尾开始哪个数组元素更大哪个先复制到末尾</span>\r\n      <span class=\"hljs-keyword\">if</span> (arr1[p1] &gt;= arr2[p2]){\r\n          arr1[p--] = arr1[p1--];\r\n      }<span class=\"hljs-keyword\">else</span>{\r\n          arr1[p--] = arr2[p2--];\r\n      }\r\n  }\r\n\r\n  <span class=\"hljs-comment\">//处理某个数组元素未全部拷贝完的情况</span>\r\n  <span class=\"hljs-keyword\">while</span> (p1 &gt;= <span class=\"hljs-number\">0</span>){\r\n      arr1[p--] = arr1[p1--];\r\n  }\r\n  <span class=\"hljs-keyword\">while</span> (p2 &gt;= <span class=\"hljs-number\">0</span>){\r\n      arr1[p--] = arr2[p2--];\r\n  }\r\n\r\n  System.<span class=\"hljs-keyword\">out</span>.println(Arrays.toString(arr1));\r\n}\r\n</code></pre>\r\n</li>\r\n</ul>\r\n</li>\r\n<li><p>逆序对个数</p>\r\n<ul>\r\n<li><p>一个数列，如果左边的数大，右边的数小，则称这两个数为一个逆序对。求出这个数列中有多少个逆序对。</p>\r\n<pre><code class=\"lang-java\"><span class=\"hljs-comment\">//将数组中有序的两段[l,mid],[mid+1,r]合并为一段</span>\r\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">merge</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span>[] arr, <span class=\"hljs-keyword\">int</span> l, <span class=\"hljs-keyword\">int</span> mid, <span class=\"hljs-keyword\">int</span> r)</span> </span>{\r\n  <span class=\"hljs-keyword\">int</span>[] arrCopy = Arrays.copyOf(arr, arr.length);    <span class=\"hljs-comment\">//拷贝原数组</span>\r\n  <span class=\"hljs-keyword\">int</span> left = l;    <span class=\"hljs-comment\">//左指针指向左边区域开始</span>\r\n  <span class=\"hljs-keyword\">int</span> right = mid+<span class=\"hljs-number\">1</span>;    <span class=\"hljs-comment\">//右指针指向右边开始</span>\r\n  <span class=\"hljs-keyword\">int</span> p = l;    <span class=\"hljs-comment\">//p指向原数组开始位置</span>\r\n\r\n  <span class=\"hljs-comment\">//合并两段有序元素</span>\r\n  <span class=\"hljs-keyword\">while</span> (left &lt;= mid &amp;&amp; right &lt;= r){\r\n      <span class=\"hljs-keyword\">if</span> (arrCopy[left] &lt;= arrCopy[right]){\r\n          arr[p++] = arrCopy[left++];\r\n      }<span class=\"hljs-keyword\">else</span>{\r\n          arr[p++] = arrCopy[right++];\r\n          count += mid - left + <span class=\"hljs-number\">1</span>;    <span class=\"hljs-comment\">//统计逆序对个数 只要从右边抓取元素，那么当前逆序对个数为左侧元素的个数</span>\r\n      }\r\n  }\r\n  <span class=\"hljs-comment\">//左边区域没有拷贝完成的情况继续拷贝 右边区域出现此情况不需要拷贝</span>\r\n  <span class=\"hljs-keyword\">while</span> (left &lt;= mid){\r\n      arr[p++] = arrCopy[left++];\r\n  }\r\n}\r\n</code></pre>\r\n</li>\r\n</ul>\r\n</li>\r\n</ol>\r\n<h3 id=\"-\">堆排序</h3>\r\n<ul>\r\n<li>堆（英语：heap)是计算机科学中一类特殊的数据结构的统称。堆通常是一个可以被看做一棵树的数组对象。堆总是满足下列性质：</li>\r\n<li>堆中某个节点的值总是不大于或不小于其父节点的值；</li>\r\n<li>堆总是一棵完全二叉树。</li>\r\n</ul>\r\n<pre><code class=\"lang-java\"><span class=\"hljs-comment\">// 小顶堆调整</span>\r\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">minHeapFixDown</span>(<span class=\"hljs-params\"><span class=\"hljs-keyword\">int</span>[] arr, <span class=\"hljs-keyword\">int</span> index, <span class=\"hljs-keyword\">int</span> n</span>) </span>{\r\n    <span class=\"hljs-comment\">// 找到左右孩子</span>\r\n    <span class=\"hljs-keyword\">int</span> left = index * <span class=\"hljs-number\">2</span> + <span class=\"hljs-number\">1</span>;\r\n    <span class=\"hljs-keyword\">int</span> right = index * <span class=\"hljs-number\">2</span> + <span class=\"hljs-number\">2</span>;\r\n    <span class=\"hljs-comment\">// 如果是叶子节点则返回</span>\r\n    <span class=\"hljs-keyword\">if</span> (left &gt;= n &amp;&amp; right &gt;= n) {\r\n        <span class=\"hljs-keyword\">return</span>;\r\n    }\r\n    <span class=\"hljs-comment\">// 找到左右孩子中较小的那个</span>\r\n    <span class=\"hljs-keyword\">int</span> min = left;\r\n    <span class=\"hljs-keyword\">if</span> (right &gt;= n) {\r\n        min = left; <span class=\"hljs-comment\">// 如果只有左子树则最小值只能为左子树</span>\r\n    } <span class=\"hljs-keyword\">else</span> {\r\n        <span class=\"hljs-keyword\">if</span> (arr[right] &lt; arr[left]) {\r\n            min = right;\r\n        }\r\n    }\r\n    <span class=\"hljs-comment\">// 如果根节点小于两个孩子节点则不需要调整</span>\r\n    <span class=\"hljs-keyword\">if</span> (arr[index] &lt; arr[min]) {\r\n        <span class=\"hljs-keyword\">return</span>;\r\n    }\r\n\r\n    <span class=\"hljs-comment\">// 把较小的元素调整到父节点</span>\r\n    <span class=\"hljs-keyword\">int</span> temp = arr[index];\r\n    arr[index] = arr[min];\r\n    arr[min] = temp;\r\n\r\n    <span class=\"hljs-comment\">// 对哪个子树进行了调整则递归调整该子树</span>\r\n    minHeapFixDown(arr, min, n);\r\n}\r\n\r\n<span class=\"hljs-comment\">// 大顶堆调整</span>\r\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">maxHeapFixDown</span>(<span class=\"hljs-params\"><span class=\"hljs-keyword\">int</span>[] arr, <span class=\"hljs-keyword\">int</span> index, <span class=\"hljs-keyword\">int</span> n</span>) </span>{\r\n    <span class=\"hljs-comment\">// 找到左右孩子</span>\r\n    <span class=\"hljs-keyword\">int</span> left = index * <span class=\"hljs-number\">2</span> + <span class=\"hljs-number\">1</span>;\r\n    <span class=\"hljs-keyword\">int</span> right = index * <span class=\"hljs-number\">2</span> + <span class=\"hljs-number\">2</span>;\r\n    <span class=\"hljs-comment\">// 如果是叶子节点则返回</span>\r\n    <span class=\"hljs-keyword\">if</span> (left &gt;= n &amp;&amp; right &gt;= n) {\r\n        <span class=\"hljs-keyword\">return</span>;\r\n    }\r\n    <span class=\"hljs-comment\">// 找到左右孩子中较大的那个</span>\r\n    <span class=\"hljs-keyword\">int</span> max = left;\r\n    <span class=\"hljs-keyword\">if</span> (right &gt;= n) {\r\n        max = left; <span class=\"hljs-comment\">// 如果只有左子树则最小值只能为左子树</span>\r\n    } <span class=\"hljs-keyword\">else</span> {\r\n        <span class=\"hljs-keyword\">if</span> (arr[right] &gt; arr[left]) {\r\n            max = right;\r\n        }\r\n    }\r\n    <span class=\"hljs-comment\">// 如果根节点小于两个孩子节点则不需要调整</span>\r\n    <span class=\"hljs-keyword\">if</span> (arr[index] &gt; arr[max]) {\r\n        <span class=\"hljs-keyword\">return</span>;\r\n    }\r\n\r\n    <span class=\"hljs-comment\">// 把较大的元素调整到父节点</span>\r\n    <span class=\"hljs-keyword\">int</span> temp = arr[index];\r\n    arr[index] = arr[max];\r\n    arr[max] = temp;\r\n\r\n    <span class=\"hljs-comment\">// 对哪个子树进行了调整则递归调整该子树</span>\r\n    maxHeapFixDown(arr, max, n);\r\n}\r\n\r\n<span class=\"hljs-comment\">// 堆排序</span>\r\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">heapSort</span>(<span class=\"hljs-params\"><span class=\"hljs-keyword\">int</span>[] arr</span>) </span>{\r\n    <span class=\"hljs-comment\">// 把二叉树堆化</span>\r\n    heap(arr);\r\n    <span class=\"hljs-comment\">//堆排序</span>\r\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = arr.length - <span class=\"hljs-number\">1</span>; i &gt;= <span class=\"hljs-number\">0</span>; i--) {\r\n        <span class=\"hljs-comment\">// minHeapFixDown(arr, 0, i+1);</span>\r\n        QuickSort.swap(arr, i, <span class=\"hljs-number\">0</span>);\r\n        maxHeapFixDown(arr, <span class=\"hljs-number\">0</span>, i);\r\n    }\r\n}\r\n\r\n<span class=\"hljs-comment\">// 对二叉树堆化</span>\r\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">heap</span>(<span class=\"hljs-params\"><span class=\"hljs-keyword\">int</span>[] arr</span>) </span>{\r\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = arr.length / <span class=\"hljs-number\">2</span> - <span class=\"hljs-number\">1</span>; i &gt;= <span class=\"hljs-number\">0</span>; i--) {\r\n        maxHeapFixDown(arr, i, arr.length);\r\n    }\r\n    System.<span class=\"hljs-keyword\">out</span>.println(<span class=\"hljs-string\">\"heap:\"</span> + Arrays.toString(arr));\r\n}\r\n</code></pre>\r\n<h3 id=\"-\">计数排序</h3>\r\n<pre><code class=\"lang-java\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">main</span>(<span class=\"hljs-params\">String[] args</span>) </span>{\r\n    <span class=\"hljs-keyword\">int</span>[] arr = { <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">5</span>, <span class=\"hljs-number\">8</span>, <span class=\"hljs-number\">6</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span> };\r\n    System.<span class=\"hljs-keyword\">out</span>.println(Arrays.toString(arr));\r\n    <span class=\"hljs-comment\">//得到数组最大值</span>\r\n    <span class=\"hljs-keyword\">int</span> max = arr[<span class=\"hljs-number\">0</span>];\r\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">1</span>; i &lt; arr.length; i++){\r\n        <span class=\"hljs-keyword\">if</span> (arr[i] &gt; max){\r\n            max = arr[i];\r\n        }\r\n    }\r\n    <span class=\"hljs-comment\">//开辟辅助数组</span>\r\n    <span class=\"hljs-keyword\">int</span>[] help = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-keyword\">int</span>[max+<span class=\"hljs-number\">1</span>];\r\n    <span class=\"hljs-comment\">//下标映射</span>\r\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; arr.length; i++) {\r\n        help[arr[i]]++;\r\n    }\r\n\r\n    <span class=\"hljs-comment\">//根据下标排序</span>\r\n    <span class=\"hljs-keyword\">int</span> p = <span class=\"hljs-number\">0</span>;\r\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; help.length; i++) {\r\n        <span class=\"hljs-keyword\">while</span> (help[i] &gt; <span class=\"hljs-number\">0</span>){\r\n            arr[p++] = i;\r\n            help[i]--;\r\n        }\r\n    }\r\n\r\n    System.<span class=\"hljs-keyword\">out</span>.println(Arrays.toString(arr));\r\n}\r\n</code></pre>\r\n<h3 id=\"-\">桶排序</h3>\r\n<ul>\r\n<li>时间复杂度：O(N)~O(NlogN)</li>\r\n<li><p>实现：</p>\r\n<pre><code class=\"lang-java\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">bucketSort</span>(<span class=\"hljs-params\"><span class=\"hljs-keyword\">int</span>[] arr</span>)</span>{\r\n  <span class=\"hljs-comment\">//得到数组最大值</span>\r\n  <span class=\"hljs-keyword\">int</span> max = CountSort.maxOfArray(arr);\r\n  <span class=\"hljs-comment\">//申明桶空间</span>\r\n  LinkedNode[] bucket = <span class=\"hljs-keyword\">new</span> LinkedNode[arr.length];\r\n  <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; arr.length; i++) {\r\n      <span class=\"hljs-comment\">//根据hash函数得到桶下标</span>\r\n      <span class=\"hljs-keyword\">int</span> index = hash(arr[i], max, arr.length);\r\n      <span class=\"hljs-comment\">//放入桶中</span>\r\n      insert(bucket, arr[i], index);\r\n  }\r\n\r\n  <span class=\"hljs-comment\">//从桶中读出</span>\r\n  <span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">0</span>;\r\n  <span class=\"hljs-keyword\">for</span> (LinkedNode node : bucket) {\r\n      LinkedNode p = node;\r\n      <span class=\"hljs-keyword\">while</span> (p != <span class=\"hljs-literal\">null</span>){\r\n          arr[i++] = p.data;\r\n          p = p.next;\r\n      }\r\n  }\r\n}\r\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">insert</span>(<span class=\"hljs-params\">LinkedNode[] bucket, <span class=\"hljs-keyword\">int</span> data, <span class=\"hljs-keyword\">int</span> index</span>) </span>{\r\n  LinkedNode node = <span class=\"hljs-keyword\">new</span> LinkedNode();\r\n  node.data = data;\r\n  <span class=\"hljs-keyword\">if</span> (bucket[index] == <span class=\"hljs-literal\">null</span>){\r\n      <span class=\"hljs-comment\">//如果这个桶为空则之间赋值元素</span>\r\n      bucket[index] = node;\r\n  }<span class=\"hljs-keyword\">else</span>{\r\n      <span class=\"hljs-comment\">//不为空则找按从小到大找到存放位置</span>\r\n      LinkedNode p = bucket[index];\r\n      LinkedNode pre = p;\r\n      <span class=\"hljs-keyword\">while</span> (p != <span class=\"hljs-literal\">null</span> &amp;&amp; data &gt; p.data){\r\n          pre = p;\r\n          p = p.next;\r\n      }\r\n\r\n      node.next = pre.next;\r\n      pre.next = node;\r\n  }\r\n}\r\n<span class=\"hljs-comment\">//hash函数</span>\r\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">hash</span>(<span class=\"hljs-params\"><span class=\"hljs-keyword\">int</span> i, <span class=\"hljs-keyword\">int</span> max, <span class=\"hljs-keyword\">int</span> length</span>) </span>{\r\n  <span class=\"hljs-keyword\">return</span> (i * length) / (max + <span class=\"hljs-number\">1</span>);\r\n}\r\n</code></pre>\r\n</li>\r\n</ul>\r\n<h3 id=\"-\">基数排序</h3>\r\n<pre><code class=\"lang-java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">RadixSort</span> {\r\n    <span class=\"hljs-comment\">//创建桶  个数为0-9 10个</span>\r\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">static</span> ArrayList&lt;Integer&gt;[] bucket = <span class=\"hljs-keyword\">new</span> ArrayList[<span class=\"hljs-number\">10</span>];\r\n    <span class=\"hljs-comment\">//初始化桶</span>\r\n    <span class=\"hljs-keyword\">static</span> {\r\n        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; bucket.length; i++) {\r\n            bucket[i] = <span class=\"hljs-keyword\">new</span> ArrayList&lt;Integer&gt;();\r\n        }\r\n    }\r\n\r\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">main</span>(<span class=\"hljs-params\">String[] args</span>) </span>{\r\n        <span class=\"hljs-keyword\">int</span>[] arr = { <span class=\"hljs-number\">13</span>, <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">12</span>, <span class=\"hljs-number\">5</span>, <span class=\"hljs-number\">28</span>, <span class=\"hljs-number\">6</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span> };\r\n        <span class=\"hljs-comment\">//得到待排序数组中的最大位数</span>\r\n        <span class=\"hljs-keyword\">int</span> max = CountSort.maxOfArray(arr);\r\n        <span class=\"hljs-keyword\">int</span> num = <span class=\"hljs-number\">0</span>;\r\n        <span class=\"hljs-keyword\">while</span> (max &gt; <span class=\"hljs-number\">0</span>){\r\n            num++;\r\n            max /= <span class=\"hljs-number\">10</span>;\r\n        }\r\n\r\n        <span class=\"hljs-comment\">//依据每一位的大小放入桶中排序</span>\r\n        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">1</span>; i &lt;= num; i++){\r\n            sort(arr, i);\r\n        }\r\n\r\n        System.<span class=\"hljs-keyword\">out</span>.println(Arrays.toString(arr));\r\n    }\r\n\r\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">sort</span>(<span class=\"hljs-params\"><span class=\"hljs-keyword\">int</span>[] arr, <span class=\"hljs-keyword\">int</span> i</span>) </span>{\r\n        <span class=\"hljs-comment\">//根据第i位的大小放入桶中</span>\r\n        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> j = <span class=\"hljs-number\">0</span>; j &lt; arr.length; j++) {\r\n            bucket[(<span class=\"hljs-keyword\">int</span>) ((arr[j] / Math.pow(<span class=\"hljs-number\">10</span>, i<span class=\"hljs-number\">-1</span>))%<span class=\"hljs-number\">10</span>)].<span class=\"hljs-keyword\">add</span>(arr[j]);\r\n        }\r\n\r\n        <span class=\"hljs-comment\">//将桶中的数据放入原数组</span>\r\n        <span class=\"hljs-keyword\">int</span> p = <span class=\"hljs-number\">0</span>;\r\n        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> j = <span class=\"hljs-number\">0</span>; j &lt; bucket.length; j++) {\r\n            <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> k : bucket[j]){\r\n                arr[p++] = k;\r\n            }\r\n        }\r\n\r\n        <span class=\"hljs-comment\">//把桶清空</span>\r\n        clear();\r\n    }\r\n\r\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">clear</span>(<span class=\"hljs-params\"></span>) </span>{\r\n        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> j = <span class=\"hljs-number\">0</span>; j &lt; bucket.length; j++) {\r\n            bucket[j].clear();\r\n        }\r\n    }\r\n\r\n}\r\n</code></pre>\r\n<h3 id=\"-\">相关题解</h3>\r\n<ol>\r\n<li><p>给定已排序数组arr和k ,不重复打印arr中所有相加和为k的不降序二元组<br>如输入arr={-8,-4,-3,0,2,4,5,8,9,10},k=10<br>输出(0,10)(2,8)</p>\r\n</li>\r\n<li><p>解：</p>\r\n<pre><code class=\"lang-java\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">main</span>(<span class=\"hljs-params\">String[] args</span>) </span>{\r\n  <span class=\"hljs-keyword\">int</span>[] arr={<span class=\"hljs-number\">-8</span>,<span class=\"hljs-number\">-4</span>,<span class=\"hljs-number\">-3</span>,<span class=\"hljs-number\">0</span>,<span class=\"hljs-number\">2</span>,<span class=\"hljs-number\">4</span>,<span class=\"hljs-number\">5</span>,<span class=\"hljs-number\">8</span>,<span class=\"hljs-number\">9</span>,<span class=\"hljs-number\">10</span>};\r\n  <span class=\"hljs-keyword\">int</span> n = <span class=\"hljs-number\">10</span>;\r\n  <span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">0</span>;    <span class=\"hljs-comment\">//左指针</span>\r\n  <span class=\"hljs-keyword\">int</span> j = arr.length - <span class=\"hljs-number\">1</span>;    <span class=\"hljs-comment\">//右指针</span>\r\n  <span class=\"hljs-comment\">//从两段向中间扫描</span>\r\n  <span class=\"hljs-keyword\">while</span> (i &lt; j){\r\n      <span class=\"hljs-keyword\">int</span> sum = arr[i] + arr[j];\r\n      <span class=\"hljs-comment\">//判断两数相加是否为n，如果和小于n则i向右寻找更大的数，如果和大于n则j向左寻找更小的数</span>\r\n      <span class=\"hljs-keyword\">if</span> (sum == n){\r\n          System.<span class=\"hljs-keyword\">out</span>.println(<span class=\"hljs-string\">\"(\"</span> + arr[i] + <span class=\"hljs-string\">\",\"</span> + arr[j] + <span class=\"hljs-string\">\")\"</span>);\r\n          i++;\r\n          j--;\r\n      }<span class=\"hljs-function\"><span class=\"hljs-keyword\">else</span> <span class=\"hljs-title\">if</span> (<span class=\"hljs-params\">sum &lt; n</span>)</span>{\r\n          i++;\r\n      }<span class=\"hljs-keyword\">else</span>{\r\n          j--;\r\n      }\r\n  }\r\n}\r\n</code></pre>\r\n</li>\r\n<li><p>扩展:三元组呢?(未解决)</p>\r\n</li>\r\n<li><p>需要排序的子数组</p>\r\n<ul>\r\n<li>给定一个无序数组arr ,求出需要排序的最短子数组长度<br>要求: 0(N)<br>如输入: arr={2,3,7,5,4,6} ,返回4 ,因为只有{7,5,4,6}需要排序</li>\r\n<li><p>解：</p>\r\n<pre><code class=\"lang-java\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">main</span>(<span class=\"hljs-params\">String[] args</span>) </span>{\r\n  <span class=\"hljs-keyword\">int</span>[] arr = { <span class=\"hljs-number\">8</span>, <span class=\"hljs-number\">9</span>, <span class=\"hljs-number\">7</span>, <span class=\"hljs-number\">5</span>, <span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">3</span> };\r\n  System.<span class=\"hljs-keyword\">out</span>.println(Arrays.toString(find(arr)));\r\n  <span class=\"hljs-keyword\">int</span>[] arr2 = { <span class=\"hljs-number\">8</span>, <span class=\"hljs-number\">7</span>, <span class=\"hljs-number\">6</span>, <span class=\"hljs-number\">5</span>, <span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">1</span> };\r\n  System.<span class=\"hljs-keyword\">out</span>.println(Arrays.toString(find(arr2)));\r\n}\r\n\r\n<span class=\"hljs-comment\">// 找到无序子数组(升序)</span>\r\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">int</span>[] <span class=\"hljs-title\">findByAsc</span>(<span class=\"hljs-params\"><span class=\"hljs-keyword\">int</span>[] arr</span>) </span>{\r\n  <span class=\"hljs-keyword\">int</span> p1 = <span class=\"hljs-number\">-1</span>;\r\n  <span class=\"hljs-keyword\">int</span> p2 = <span class=\"hljs-number\">-1</span>;\r\n  <span class=\"hljs-keyword\">int</span> max = arr[<span class=\"hljs-number\">0</span>];\r\n  <span class=\"hljs-comment\">// 寻找右边界</span>\r\n  <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">1</span>; i &lt; arr.length; i++) {\r\n      <span class=\"hljs-comment\">// 找到最大值</span>\r\n      <span class=\"hljs-keyword\">if</span> (arr[i] &gt; max) {\r\n          max = arr[i];\r\n      }\r\n      <span class=\"hljs-comment\">// 只要是在最大值右侧并且小于最大值的一定为无序</span>\r\n      <span class=\"hljs-keyword\">if</span> (max &gt; arr[i]) {\r\n          p2 = i;\r\n      }\r\n  }\r\n  <span class=\"hljs-comment\">// 寻找左边界</span>\r\n  <span class=\"hljs-keyword\">int</span> min = arr[arr.length - <span class=\"hljs-number\">1</span>];\r\n  <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = arr.length - <span class=\"hljs-number\">2</span>; i &gt;= <span class=\"hljs-number\">0</span>; i--) {\r\n      <span class=\"hljs-comment\">// 找到历史最小值</span>\r\n      <span class=\"hljs-keyword\">if</span> (arr[i] &lt; min) {\r\n          min = arr[i];\r\n      }\r\n      <span class=\"hljs-comment\">// 只要是在最小值左侧并且大于最小值的一定无序</span>\r\n      <span class=\"hljs-keyword\">if</span> (arr[i] &gt; min) {\r\n          p1 = i;\r\n      }\r\n  }\r\n\r\n  <span class=\"hljs-keyword\">if</span> (p1 == <span class=\"hljs-number\">-1</span>) {\r\n      <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-keyword\">int</span>[] { <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span> };\r\n  }\r\n\r\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-keyword\">int</span>[] { p1, p2 };\r\n}\r\n\r\n<span class=\"hljs-comment\">// 找到无序子数组(降序)</span>\r\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">int</span>[] <span class=\"hljs-title\">findByDesc</span>(<span class=\"hljs-params\"><span class=\"hljs-keyword\">int</span>[] arr</span>) </span>{\r\n  <span class=\"hljs-keyword\">int</span> p1 = <span class=\"hljs-number\">-1</span>;\r\n  <span class=\"hljs-keyword\">int</span> p2 = <span class=\"hljs-number\">-1</span>;\r\n  <span class=\"hljs-keyword\">int</span> min = arr[<span class=\"hljs-number\">0</span>];\r\n  <span class=\"hljs-comment\">// 寻找右边界</span>\r\n  <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">1</span>; i &lt; arr.length; i++) {\r\n      <span class=\"hljs-comment\">// 找到最小值</span>\r\n      <span class=\"hljs-keyword\">if</span> (arr[i] &lt; min) {\r\n          min = arr[i];\r\n      }\r\n      <span class=\"hljs-comment\">// 只要是在最小值右侧并且大于最小值的一定为无序</span>\r\n      <span class=\"hljs-keyword\">if</span> (min &lt; arr[i]) {\r\n          p2 = i;\r\n      }\r\n  }\r\n  <span class=\"hljs-comment\">// 寻找左边界</span>\r\n  <span class=\"hljs-keyword\">int</span> max = arr[arr.length - <span class=\"hljs-number\">1</span>];\r\n  <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = arr.length - <span class=\"hljs-number\">2</span>; i &gt;= <span class=\"hljs-number\">0</span>; i--) {\r\n      <span class=\"hljs-comment\">// 找到历史最大值</span>\r\n      <span class=\"hljs-keyword\">if</span> (arr[i] &gt; max) {\r\n          max = arr[i];\r\n      }\r\n      <span class=\"hljs-comment\">// 只要是在最大值左侧并且小于最大值的一定无序</span>\r\n      <span class=\"hljs-keyword\">if</span> (arr[i] &lt; max) {\r\n          p1 = i;\r\n      }\r\n  }\r\n\r\n  <span class=\"hljs-keyword\">if</span> (p1 == <span class=\"hljs-number\">-1</span>) {\r\n      <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-keyword\">int</span>[] { <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span> };\r\n  }\r\n\r\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-keyword\">int</span>[] { p1, p2 };\r\n}\r\n\r\n<span class=\"hljs-comment\">// 找到无序子数组(升/降序)</span>\r\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">int</span>[] <span class=\"hljs-title\">find</span>(<span class=\"hljs-params\"><span class=\"hljs-keyword\">int</span>[] arr</span>) </span>{\r\n  <span class=\"hljs-keyword\">int</span>[] asc = findByAsc(arr);\r\n  <span class=\"hljs-keyword\">int</span> ascL = asc[<span class=\"hljs-number\">1</span>] - asc[<span class=\"hljs-number\">0</span>] + <span class=\"hljs-number\">1</span>;\r\n  <span class=\"hljs-keyword\">int</span>[] desc = findByDesc(arr);\r\n  <span class=\"hljs-keyword\">int</span> descL = desc[<span class=\"hljs-number\">1</span>] - desc[<span class=\"hljs-number\">0</span>] + <span class=\"hljs-number\">1</span>;\r\n\r\n  <span class=\"hljs-keyword\">if</span> (ascL &gt;= descL) {\r\n      <span class=\"hljs-keyword\">return</span> desc;\r\n  } <span class=\"hljs-keyword\">else</span> {\r\n      <span class=\"hljs-keyword\">return</span> asc;\r\n  }\r\n}\r\n</code></pre>\r\n</li>\r\n</ul>\r\n</li>\r\n<li><p>前k个数</p>\r\n<ul>\r\n<li>求海量数据(正整数)按逆序排列的前k个数( topK) , 因为数据量太大,不能全部存储在内存中,只能一个一个地从磁盘或者网络<br>上读取数据,请设计一个高效的算法来解决这个问题不限制用户输入数据个数,用户每输入-个数据就回车使得程序可立即获得这个数据,用户输入-1代表输入终止，先输入K ,代表要求得topK</li>\r\n<li>请输出topK ,从小到大,空格分割</li>\r\n<li><p>解：</p>\r\n<pre><code class=\"lang-java\"><span class=\"hljs-comment\">// 迭代方法 O(NK)</span>\r\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">int</span>[] <span class=\"hljs-title\">topK</span>(<span class=\"hljs-params\"></span>) </span>{\r\n  Scanner input = <span class=\"hljs-keyword\">new</span> Scanner(System.<span class=\"hljs-keyword\">in</span>);\r\n  <span class=\"hljs-keyword\">int</span> k = input.nextInt();\r\n  <span class=\"hljs-keyword\">int</span>[] arr = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-keyword\">int</span>[k];\r\n  <span class=\"hljs-keyword\">int</span> n;\r\n  <span class=\"hljs-keyword\">do</span> {\r\n      n = input.nextInt();\r\n      <span class=\"hljs-comment\">//得到数组中的最小值</span>\r\n      <span class=\"hljs-keyword\">int</span> minInd = min(arr);\r\n      <span class=\"hljs-comment\">//如果输入的数大于数组最小值则替换此最小值</span>\r\n      <span class=\"hljs-keyword\">if</span> (n &gt; arr[minInd]) {\r\n          arr[minInd] = n;\r\n      }\r\n  } <span class=\"hljs-keyword\">while</span> (n != <span class=\"hljs-number\">-1</span>);\r\n\r\n  <span class=\"hljs-keyword\">return</span> arr;\r\n}\r\n\r\n<span class=\"hljs-comment\">// 得到数组最小值 O(N)</span>\r\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">min</span>(<span class=\"hljs-params\"><span class=\"hljs-keyword\">int</span>[] arr</span>) </span>{\r\n  <span class=\"hljs-keyword\">int</span> minInd = <span class=\"hljs-number\">0</span>;\r\n  <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">1</span>; i &lt; arr.length; i++) {\r\n      <span class=\"hljs-keyword\">if</span> (arr[i] &lt; arr[minInd]) {\r\n          minInd = i;\r\n      }\r\n  }\r\n\r\n  <span class=\"hljs-keyword\">return</span> minInd;\r\n}\r\n\r\n<span class=\"hljs-comment\">//使用小顶堆 O(NlogK)</span>\r\n<span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">int</span> k;    <span class=\"hljs-comment\">//前k个数字</span>\r\n<span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">int</span>[] heap;    <span class=\"hljs-comment\">//堆内存</span>\r\n<span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">int</span> cnt;    <span class=\"hljs-comment\">//堆中已存在的元素个数</span>\r\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">int</span>[] <span class=\"hljs-title\">topK2</span>(<span class=\"hljs-params\"></span>) </span>{\r\n  Scanner input = <span class=\"hljs-keyword\">new</span> Scanner(System.<span class=\"hljs-keyword\">in</span>);\r\n  k = input.nextInt();\r\n  heap = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-keyword\">int</span>[k];\r\n  <span class=\"hljs-keyword\">int</span> n;\r\n  <span class=\"hljs-keyword\">do</span> {\r\n      n = input.nextInt();\r\n      fun(n);\r\n  } <span class=\"hljs-keyword\">while</span> (n != <span class=\"hljs-number\">-1</span>);\r\n\r\n  <span class=\"hljs-keyword\">return</span> heap;\r\n}\r\n\r\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">fun</span>(<span class=\"hljs-params\"><span class=\"hljs-keyword\">int</span> n</span>) </span>{\r\n  <span class=\"hljs-comment\">//在堆填满之前只需要输入数据</span>\r\n  <span class=\"hljs-keyword\">if</span> (cnt &lt; k - <span class=\"hljs-number\">1</span>){\r\n      heap[cnt++] = n;\r\n      <span class=\"hljs-keyword\">return</span>;\r\n  }\r\n\r\n  <span class=\"hljs-keyword\">if</span> (cnt == k - <span class=\"hljs-number\">1</span>){    <span class=\"hljs-comment\">//当堆填到只剩一个元素时</span>\r\n      heap[cnt++] = n;\r\n      <span class=\"hljs-comment\">//初始化堆</span>\r\n      BinaryTreeAndArray.heap(heap);\r\n  }<span class=\"hljs-keyword\">else</span>{\r\n      <span class=\"hljs-comment\">//如果输入数据大于小顶堆堆顶</span>\r\n      <span class=\"hljs-keyword\">if</span> (n &gt; heap[<span class=\"hljs-number\">0</span>]){\r\n          <span class=\"hljs-comment\">//替换堆顶元素</span>\r\n          heap[<span class=\"hljs-number\">0</span>] = n;    \r\n          <span class=\"hljs-comment\">//调整堆</span>\r\n          BinaryTreeAndArray.minHeapFixDown(heap, <span class=\"hljs-number\">0</span>, heap.length);    \r\n      }\r\n  }\r\n  System.<span class=\"hljs-keyword\">out</span>.println(Arrays.toString(heap));\r\n}\r\n</code></pre>\r\n</li>\r\n</ul>\r\n</li>\r\n<li><p>所有员工年龄排序</p>\r\n<ul>\r\n<li>公司现在要对几万员工的年龄进行排序,因为公司员工的人数非常多,所以要求排序算法的效率要非常高,你能写出这样的程序吗<br>输入:输入可能包含多个测试样例,对于每个测试案例,输入的第一-行为- 一个整数n(1&lt;= n&lt;=1000000) :代表公司内员工的人数。<br>输入的第二行包括n个整数:代表公司内每个员工的年龄。其中，员工年龄<br>age的取值范围为(1&lt;=age&lt;=99)。</li>\r\n<li>输出:对应每个测试案例,请输出排序后的n个员工的年龄，每个年龄后面有一个空格。</li>\r\n<li><p>解：使用计数排序</p>\r\n<pre><code class=\"lang-java\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">main</span>(<span class=\"hljs-params\">String[] args</span>) </span>{\r\n  <span class=\"hljs-comment\">//得到员工年龄</span>\r\n  <span class=\"hljs-keyword\">int</span> ages[] = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-keyword\">int</span>[<span class=\"hljs-number\">10000</span>];\r\n  Random r = <span class=\"hljs-keyword\">new</span> Random();\r\n  <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; ages.length; i++) {\r\n      ages[i] = r.nextInt(<span class=\"hljs-number\">100</span>);\r\n  }\r\n  System.<span class=\"hljs-keyword\">out</span>.println(Arrays.toString(ages));\r\n  <span class=\"hljs-comment\">//放入计数桶中</span>\r\n  <span class=\"hljs-keyword\">int</span>[] bucket = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-keyword\">int</span>[<span class=\"hljs-number\">100</span>];\r\n  <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; ages.length; i++) {\r\n      bucket[ages[i]]++;\r\n  }\r\n\r\n  <span class=\"hljs-comment\">//得到排序结果</span>\r\n  <span class=\"hljs-keyword\">int</span> p = <span class=\"hljs-number\">0</span>;\r\n  <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; bucket.length; i++) {\r\n      <span class=\"hljs-keyword\">while</span> (bucket[i] != <span class=\"hljs-number\">0</span>){\r\n          ages[p++] = i;\r\n          bucket[i]--;\r\n      }\r\n  }\r\n  System.<span class=\"hljs-keyword\">out</span>.println(Arrays.toString(ages));\r\n}\r\n</code></pre>\r\n</li>\r\n</ul>\r\n</li>\r\n<li><p>数组能排成的最小数(特殊排序)</p>\r\n<ul>\r\n<li>输入一个正整数数组,把数组里所有整数拼接起来排成一个数,打印出能拼接出的所有数字中最小的一个。<br>例如输入数组{3,32,321} ,则打印出这3个数字能排成的最小数字为: 321323</li>\r\n<li><p>解：</p>\r\n<pre><code class=\"lang-java\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">main</span>(<span class=\"hljs-params\">String[] args</span>) </span>{\r\n  Integer[] arr = {<span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">32</span>, <span class=\"hljs-number\">321</span>};\r\n\r\n  Arrays.sort(arr, <span class=\"hljs-keyword\">new</span> Comparator&lt;Integer&gt;() {\r\n\r\n      @Override\r\n      <span class=\"hljs-comment\">//两个数的比较规则为相互在前和在后所组成数的大小做比较</span>\r\n      <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">compare</span>(<span class=\"hljs-params\">Integer o1, Integer o2</span>) </span>{\r\n          String s1 = o1 + <span class=\"hljs-string\">\"\"</span> + o2;\r\n          String s2 = o2 + <span class=\"hljs-string\">\"\"</span> + o1;\r\n          <span class=\"hljs-keyword\">return</span> s1.compareTo(s2);\r\n      }\r\n  });\r\n\r\n  StringBuilder res = <span class=\"hljs-keyword\">new</span> StringBuilder();\r\n  <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; arr.length; i++) {\r\n      res.append(arr[i]);\r\n  }\r\n  System.<span class=\"hljs-keyword\">out</span>.println(res.toString());\r\n}\r\n</code></pre>\r\n</li>\r\n</ul>\r\n</li>\r\n<li><p>字符串(数组)的包含</p>\r\n<ul>\r\n<li><p>输入两个字符串str1和str2，请判断str1中的字符是否都存在于str2中。  </p>\r\n<pre><code class=\"lang-java\"><span class=\"hljs-comment\">//s2中所有字符s1是否包含</span>\r\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">boolean</span> <span class=\"hljs-title\">fun</span><span class=\"hljs-params\">(String s1, String s2)</span></span>{\r\n  <span class=\"hljs-keyword\">char</span>[] s1Arr = s1.toCharArray();\r\n  <span class=\"hljs-comment\">//排序</span>\r\n  Arrays.sort(s1Arr);\r\n  <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; s2.length(); i++) {\r\n      <span class=\"hljs-comment\">//使用二分查找</span>\r\n      <span class=\"hljs-keyword\">int</span> index = Arrays.binarySearch(s1Arr, s2.charAt(i));\r\n      <span class=\"hljs-keyword\">if</span> (index &lt; <span class=\"hljs-number\">0</span>){\r\n          <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">false</span>;\r\n      }\r\n  }\r\n\r\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">true</span>;\r\n}\r\n</code></pre>\r\n</li>\r\n</ul>\r\n</li>\r\n</ol>', '### 分治法\r\n\r\n* 分治法(divide and conquer，D&C) :将原问题划分成若干个规模较小而结构与原问题一致的子问题;递归地解决这些子问题,然后再合并其结果,就得到原问题的解。\r\n* 容易确定运行时间,是分治算法的优点之一。\r\n* 分治模式在每一层递归 上都有三个步骤\r\n    -分解(Divide) :将原问题分解成一系列子问题;\r\n    -解决(Conquer):递归地解各子问题。若子问题足够小,则直接有解;\r\n    -合并(Combine):將子问题的结果合并成原问题的解。\r\n\r\n### 分治法应用\r\n\r\n#### 快速排序--重点\r\n    \r\n```java\r\npublic static void quickSort(int[] arr, int l, int r){\r\n    if (l < r){\r\n        //将待排序集合按p分区，p左侧为小于它的元素，右侧为大于它的元素\r\n        int p = partition2(arr, l, r);\r\n    \r\n        //对左侧分区排序\r\n        quickSort(arr, l, p - 1);\r\n        //对右侧分区排序\r\n        quickSort(arr, p + 1, r);\r\n    }\r\n}\r\n\r\n//交换数组中的两个元素\r\nprivate static void swap(int[] arr, int a, int b){\r\n    int t = arr[a];\r\n    arr[a] = arr[b];\r\n    arr[b] = t;\r\n}\r\n```\r\n* 快速排序的划分方法：\r\n    1. 单向扫描法\r\n    ```java\r\n    //单向扫描法\r\n    private static int partition(int[] arr, int p, int r) {\r\n        int pivot = arr[p];	//选取第一个元素为key值\r\n        int sp = p + 1;	//扫描指针 从左往右扫描\r\n        int bigger = r;	//bigger指针 右侧为大于key值得元素\r\n        //sp向右扫描直到和bigger交错\r\n        while (sp <= bigger){\r\n            //sp一直向右直到找到大于p的元素\r\n            if (arr[sp] <= pivot){\r\n                sp++;\r\n            }else{\r\n                //把大于p的元素交换到最右侧\r\n                swap(arr, sp, bigger);\r\n                bigger--;	//bigger指针左移，增加一个大于p的元素\r\n            }\r\n        }\r\n        //将选取的key值交换到中间位置\r\n        swap(arr, p, bigger);\r\n        \r\n        return bigger;\r\n    }\r\n    ```\r\n    2. 双向扫描法\r\n    ```java\r\n    //双向扫描法\r\n    private static int partition2(int[] arr, int p, int r){\r\n        int pivot = arr[p];	//把第一个元素作为key值\r\n        int left = p + 1;	//左指针\r\n        int right = r;		//右指针\r\n        \r\n        while (left <= right){\r\n            //left向右扫描找到第一个大于key的元素\r\n            while (left <= right && arr[left] <= pivot){\r\n                left++;\r\n            }\r\n            //right向左扫描找到第一个小于key的元素\r\n            while (left <= right && arr[right] > pivot){\r\n                right--;\r\n            }\r\n            //如果left和right没有交错\r\n            if (left < right){\r\n                //交换两个元素\r\n                swap(arr, left, right);\r\n            }\r\n        }\r\n        //把key值交换到中间\r\n        swap(arr, p, right);\r\n        return right;\r\n    }\r\n    ```\r\n    3. 有相同元素值的快速排序--三分法\r\n        * 增加e指针，将相同元素放到中间区域\r\n	```java\r\n	//三指针分区法\r\n	static void quickSort3(int[] arr, int i, int j){\r\n		if (i >= j){\r\n			return;\r\n		}\r\n		int key = arr[i];\r\n		int sp = i + 1;\r\n		int e = sp;\r\n		int bigger = j;\r\n		while (sp <= bigger){\r\n			if (arr[sp] == key){\r\n				if(e == i + 1)\r\n				e = sp;\r\n				sp++;\r\n			}else if (arr[sp] < key){\r\n				if(e != i + 1){\r\n					\r\n					int t = arr[e];\r\n					arr[e] = arr[sp];\r\n					arr[sp] = t;\r\n					e++;\r\n				}\r\n				sp++;\r\n			}else{\r\n				int t = arr[sp];\r\n				arr[sp] = arr[bigger];\r\n				arr[bigger] = t;\r\n				bigger--;\r\n			}\r\n		}\r\n		if (arr[e] == key){\r\n			e--;\r\n		}else{\r\n			e = bigger;\r\n		}\r\n		int t = arr[e];\r\n		arr[e] = key;\r\n		arr[i] = t;\r\n		quickSort3(arr, i, e - 1);\r\n		quickSort3(arr, bigger + 1, j);\r\n	}\r\n	```\r\n\r\n* 工程实践中的其他优化(主要针对key元素的选取，找到合适的中间值)：\r\n1. 三点中值法\r\n```java\r\nprivate static int partition2(int[] arr, int p, int r){\r\n    //优化：三点中值法 找到中间值作为key\r\n    int mid = (p+r)/2;\r\n    int midInd;\r\n    \r\n    if ((arr[p] > arr[mid] && arr[p] < arr[r]) || (arr[p] > arr[r] && arr[p] < arr[mid])){\r\n        midInd = p;		//如果p指向中间值\r\n    }else if ((arr[mid] > arr[p] && arr[mid] < arr[r]) || (arr[mid] > arr[r] && arr[mid] < arr[p])){\r\n        midInd = mid;	//mid指向中间值\r\n    }else{\r\n        midInd = r;		//r指向中间值\r\n    }\r\n    swap(arr, p, midInd);	//把三点中的中间值换到key的位置\r\n    \r\n    int pivot = arr[p];	//把第一个元素作为key值\r\n    int left = p + 1;	//左指针\r\n    int right = r;		//右指针\r\n    \r\n    while (left <= right){\r\n        //left向右扫描找到第一个大于key的元素\r\n        while (left <= right && arr[left] <= pivot){\r\n            left++;\r\n        }\r\n        //right向左扫描找到第一个小于key的元素\r\n        while (left <= right && arr[right] > pivot){\r\n            right--;\r\n        }\r\n        //如果left和right没有交错\r\n        if (left < right){\r\n            //交换两个元素\r\n            swap(arr, left, right);\r\n        }\r\n    }\r\n    //把key值交换到中间\r\n    swap(arr, p, right);\r\n    return right;\r\n}\r\n```\r\n2. 绝对中值法\r\n```java\r\npublic static int getMedian(int[] arr, int p, int r) {\r\nif (arr.length == 1)\r\n    return arr[p];\r\nint size = r - p + 1;// 数组长度\r\n//每五个元素一组\r\nint groupSize = (size % 5 == 0) ? (size / 5) : (size / 5 + 1);\r\n//存储各小组的中值\r\nint medians[] = new int[groupSize];\r\nint indexOfMedians = 0;\r\n//对每一组进行插入排序\r\nfor (int j = 0; j < groupSize; j++) {\r\n    //单独处理最后一组，因为最后一组可能不满5个元素\r\n    if (j == groupSize - 1) {\r\n    _3InsertionSort.sort(arr, p + j * 5, r); // 排序最后一组\r\n    medians[indexOfMedians++] = arr[(p + j * 5 + r) / 2]; // 最后一组的中间那个\r\n    } else {\r\n    _3InsertionSort.sort(arr, p + j * 5, p + j * 5 + 4);  // 排序非最后一组的某个组\r\n    medians[indexOfMedians++] = arr[p + j * 5 + 2];  // 当前组（排序后）的中间那个\r\n    }\r\n}\r\nreturn getMedian(medians, 0, medians.length - 1);\r\n}\r\n```\r\n\r\n3. 待排序列表较短时，用插入排序\r\n```java\r\npublic static void quickSort(int[] arr, int l, int r){\r\n    int length = (r - l) + 1;\r\n    //如果待排序元素小于等于8个则使用插入排序效率更高\r\n    if (length <= 8){\r\n        _2_递归基础.insertSort(arr, arr.length - 1);\r\n    }else{\r\n        if (l < r){\r\n            //将待排序集合按p分区，p左侧为小于它的元素，右侧为大于它的元素\r\n            int p = partition2(arr, l, r);\r\n        \r\n            //对左侧分区排序\r\n            quickSort(arr, l, p - 1);\r\n            //对右侧分区排序\r\n            quickSort(arr, p + 1, r);\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n#### 归并排序\r\n\r\n```java\r\npublic static void main(String[] args) {\r\n    int[] arr = {2, 5, 4, 9, 4, 7, 3, 3};\r\n    System.out.println(Arrays.toString(arr));\r\n    mergeSort(arr, 0, arr.length - 1);\r\n    System.out.println(Arrays.toString(arr));\r\n}\r\n//归并排序\r\npublic static void mergeSort(int[] arr, int l, int r){\r\n    if (l < r){\r\n        //得到中间下标\r\n        int mid = l + ((r-l)>>1);\r\n        //左侧排序\r\n        mergeSort(arr, l, mid);\r\n        //右侧排序\r\n        mergeSort(arr, mid+1,r);\r\n        //合并\r\n        merge(arr, l, mid, r);\r\n    }\r\n}\r\n//将数组中有序的两段[l,mid],[mid+1,r]合并为一段\r\nprivate static void merge(int[] arr, int l, int mid, int r) {\r\n    int[] arrCopy = Arrays.copyOf(arr, arr.length);	//拷贝原数组\r\n    int left = l;	//左指针指向左边区域开始\r\n    int right = mid+1;	//右指针指向右边开始\r\n    int p = l;	//p指向原数组开始位置\r\n    \r\n    //合并两段有序元素\r\n    while (left <= mid && right <= r){\r\n        if (arrCopy[left] <= arrCopy[right]){\r\n            arr[p++] = arrCopy[left++];\r\n        }else{\r\n            arr[p++] = arrCopy[right++];\r\n        }\r\n    }\r\n    //左边区域没有拷贝完成的情况继续拷贝 右边区域出现此情况不需要拷贝\r\n    while (left <= mid){\r\n        arr[p++] = arrCopy[left++];\r\n    }\r\n}\r\n```\r\n\r\n#### 案例\r\n\r\n1. 调整数组元素顺序，使奇数位于前半部分，偶数位于后半部分。\r\n```java\r\npublic static void main(String[] args) {\r\n    int[] arr = { 2, 8, 5, 9, 1, 3, 4, 2, 2 };\r\n    System.out.println(Arrays.toString(arr));\r\n    int l = 0;\r\n    int r = arr.length - 1;\r\n    \r\n    while (l <= r){\r\n        //从左边找第一个不是奇数的元素\r\n        while (l <= r && arr[l] % 2 != 0){\r\n            l++;\r\n        }\r\n        //从右边找第一个不是偶数的元素\r\n        while (l <= r && arr[r] % 2 == 0){\r\n            r--;\r\n        }\r\n        //交换两个元素\r\n        if (l < r)\r\n        QuickSort.swap(arr, l, r);\r\n    }\r\n    \r\n    System.out.println(Arrays.toString(arr));\r\n}\r\n```\r\n\r\n2. 第k个元素\r\n    * 以尽量高的效率求出一个乱序数组中按数值顺序的第k个元素值\r\n    ```java\r\n    //第k个元素\r\n	public static int selectK(int[] arr, int l, int r, int k){\r\n		//分区\r\n		int p = QuickSort.partition2(arr, l, r);\r\n		int q = p;\r\n		//判断分区下标是否为查找的第k个元素\r\n		if (k == q){\r\n			return arr[q];\r\n		}else if (k < q){\r\n			//在左侧继续查找\r\n			return selectK(arr, l, p - 1, k);\r\n		}else{\r\n			//在右侧继续查找\r\n			return selectK(arr, p+1, r, k);\r\n		}\r\n	}\r\n    ```\r\n\r\n3. 超过一半的数字\r\n    * 数组中有一个数字出现的次数超过了数组长度的一半，找出这个数字。\r\n    * 排序后数组的第length/2个元素一定为所求数字。\r\n    ```java\r\n    //超过数组一半的数字\r\n	public static void fun(){\r\n		int[] arr = {1, 2, 2, 2, 3, 2, 2, 4, 5};\r\n		//利用查找第k个元素，最中间的元素一定为超过数组一半的元素\r\n		System.out.println(selectK(arr, 0, arr.length - 1, arr.length / 2));\r\n		//消除法\r\n		int num = arr[0];\r\n		int n = 1;\r\n		for (int i = 1; i < arr.length; i++) {\r\n			//如果个数消到0则换下一个元素\r\n			if (n == 0){\r\n				num = arr[i];\r\n				n = 1;\r\n			}\r\n			//如果相同则累加，不同则消除\r\n			if (num == arr[i]){\r\n				n++;\r\n			}else{\r\n				n--;\r\n			}\r\n		}\r\n		\r\n		System.out.println(num);\r\n	}\r\n    ```\r\n    * 寻找水王：出现次数恰好为个数的一半，求出这个数\r\n    ```java\r\n    //寻找水王 某个数正好为数组的一半\r\n	public static void fun2(){\r\n		int[] arr = {1,1,2,3,1,4,5,1};\r\n		\r\n		int num = arr[0];	//存储数组元素\r\n		int n = 0;	//元素出现的次数\r\n		int endCount = 0;	//最后一个元素出现的次数\r\n		\r\n		for (int i = 0; i < arr.length; i++) {\r\n			//统计最后一个元素出现次数\r\n			if (arr[i] == arr[arr.length - 1]){\r\n				endCount++;\r\n			}\r\n			//如果两两元素消除则继续下一元素\r\n			if (n == 0){\r\n				num = arr[i];\r\n				n = 1;\r\n				continue;\r\n			}\r\n			//相同累加 不同消减\r\n			if (arr[i] == num){\r\n				n++;\r\n			}else{\r\n				n--;\r\n			}\r\n		}\r\n		//正好等于一半的元素一定在最后一个或者消减完之后Num中存储的值\r\n		if (endCount == arr.length / 2){\r\n			System.out.println(arr[arr.length - 1]);\r\n		}else{\r\n			System.out.println(num);\r\n		}\r\n	}\r\n    ```\r\n\r\n4. 最小可用id\r\n    * 在非负数组(乱序)中找到最小的可分配的id(从1开编号)，数据量1000000.\r\n    ```java\r\n    //最小可用id-->1.排序后判断\r\n	public static int minId(int[] arr){\r\n		Arrays.sort(arr);\r\n		int i = 0;\r\n		for (i = 0; i < arr.length; i++) {\r\n			if (i + 1 != arr[i])	return i + 1;\r\n		}\r\n		\r\n		return i + 1;\r\n	}\r\n	//最小可用id-->2.辅助数组统计\r\n	public static int minId2(int[] arr){\r\n		int[] help = new int[arr.length+1];\r\n		\r\n		int i = 0;\r\n		for (i = 0; i < arr.length; i++) {\r\n			//防止数组中出现大于下标的数字\r\n			if (arr[i] < help.length)\r\n			help[arr[i]] = 1;\r\n		}\r\n		\r\n		for (i = 1; i < help.length; i++) {\r\n			if (help[i] == 0) return i;\r\n		}\r\n		\r\n		return i;\r\n	}\r\n	//最小可用id-->3.分区法\r\n	public static int minId3(int[] arr, int l, int r){\r\n		//l和r交错后结果为l+1\r\n		if (l > r) return l + 1;\r\n		//分区\r\n		int mid = QuickSort.partition2(arr, l, r);\r\n		//t为第几个元素\r\n		int t = mid + 1;\r\n		//如果元素值等于它所在的位置个数则证明左侧连续，需要去右侧找\r\n		if (arr[mid] == t){\r\n			return minId3(arr, mid + 1, r);\r\n		}else{\r\n			return minId3(arr, l, mid - 1);\r\n		}\r\n	}\r\n    ```\r\n\r\n#### 逆序对问题\r\n\r\n1. 合并有序数组\r\n    * 给定两个排序后的数组A和B，其中A的末端有足够的缓冲空间容纳B，编写一个方法，将B合并入A并排序。\r\n    ```java\r\n    //合并有序数组\r\n	public static void merge(){\r\n		int[] arr1 = {11, 13, 15, 17, 19, 0, 0, 0, 0, 0, 0};\r\n		int[] arr2 = {2, 4, 6, 8, 10, 11};\r\n		\r\n		int p = arr1.length - 1;	//指向原数组末尾\r\n		int p1 = 4;	//指向原数组有效数据末尾\r\n		int p2 = arr2.length - 1;	//指向目标数组末尾\r\n		\r\n		while (p1 >= 0 && p2 >= 0){\r\n			//判断两个数组中从末尾开始哪个数组元素更大哪个先复制到末尾\r\n			if (arr1[p1] >= arr2[p2]){\r\n				arr1[p--] = arr1[p1--];\r\n			}else{\r\n				arr1[p--] = arr2[p2--];\r\n			}\r\n		}\r\n		\r\n		//处理某个数组元素未全部拷贝完的情况\r\n		while (p1 >= 0){\r\n			arr1[p--] = arr1[p1--];\r\n		}\r\n		while (p2 >= 0){\r\n			arr1[p--] = arr2[p2--];\r\n		}\r\n		\r\n		System.out.println(Arrays.toString(arr1));\r\n	}\r\n    ```\r\n2. 逆序对个数\r\n    * 一个数列，如果左边的数大，右边的数小，则称这两个数为一个逆序对。求出这个数列中有多少个逆序对。\r\n    ```java\r\n    //将数组中有序的两段[l,mid],[mid+1,r]合并为一段\r\n	private static void merge(int[] arr, int l, int mid, int r) {\r\n		int[] arrCopy = Arrays.copyOf(arr, arr.length);	//拷贝原数组\r\n		int left = l;	//左指针指向左边区域开始\r\n		int right = mid+1;	//右指针指向右边开始\r\n		int p = l;	//p指向原数组开始位置\r\n		\r\n		//合并两段有序元素\r\n		while (left <= mid && right <= r){\r\n			if (arrCopy[left] <= arrCopy[right]){\r\n				arr[p++] = arrCopy[left++];\r\n			}else{\r\n				arr[p++] = arrCopy[right++];\r\n				count += mid - left + 1;	//统计逆序对个数 只要从右边抓取元素，那么当前逆序对个数为左侧元素的个数\r\n			}\r\n		}\r\n		//左边区域没有拷贝完成的情况继续拷贝 右边区域出现此情况不需要拷贝\r\n		while (left <= mid){\r\n			arr[p++] = arrCopy[left++];\r\n		}\r\n	}\r\n    ```\r\n\r\n### 堆排序\r\n\r\n* 堆（英语：heap)是计算机科学中一类特殊的数据结构的统称。堆通常是一个可以被看做一棵树的数组对象。堆总是满足下列性质：\r\n1. 堆中某个节点的值总是不大于或不小于其父节点的值；\r\n2. 堆总是一棵完全二叉树。\r\n\r\n```java\r\n// 小顶堆调整\r\npublic static void minHeapFixDown(int[] arr, int index, int n) {\r\n    // 找到左右孩子\r\n    int left = index * 2 + 1;\r\n    int right = index * 2 + 2;\r\n    // 如果是叶子节点则返回\r\n    if (left >= n && right >= n) {\r\n        return;\r\n    }\r\n    // 找到左右孩子中较小的那个\r\n    int min = left;\r\n    if (right >= n) {\r\n        min = left; // 如果只有左子树则最小值只能为左子树\r\n    } else {\r\n        if (arr[right] < arr[left]) {\r\n            min = right;\r\n        }\r\n    }\r\n    // 如果根节点小于两个孩子节点则不需要调整\r\n    if (arr[index] < arr[min]) {\r\n        return;\r\n    }\r\n\r\n    // 把较小的元素调整到父节点\r\n    int temp = arr[index];\r\n    arr[index] = arr[min];\r\n    arr[min] = temp;\r\n\r\n    // 对哪个子树进行了调整则递归调整该子树\r\n    minHeapFixDown(arr, min, n);\r\n}\r\n\r\n// 大顶堆调整\r\npublic static void maxHeapFixDown(int[] arr, int index, int n) {\r\n    // 找到左右孩子\r\n    int left = index * 2 + 1;\r\n    int right = index * 2 + 2;\r\n    // 如果是叶子节点则返回\r\n    if (left >= n && right >= n) {\r\n        return;\r\n    }\r\n    // 找到左右孩子中较大的那个\r\n    int max = left;\r\n    if (right >= n) {\r\n        max = left; // 如果只有左子树则最小值只能为左子树\r\n    } else {\r\n        if (arr[right] > arr[left]) {\r\n            max = right;\r\n        }\r\n    }\r\n    // 如果根节点小于两个孩子节点则不需要调整\r\n    if (arr[index] > arr[max]) {\r\n        return;\r\n    }\r\n\r\n    // 把较大的元素调整到父节点\r\n    int temp = arr[index];\r\n    arr[index] = arr[max];\r\n    arr[max] = temp;\r\n\r\n    // 对哪个子树进行了调整则递归调整该子树\r\n    maxHeapFixDown(arr, max, n);\r\n}\r\n\r\n// 堆排序\r\npublic static void heapSort(int[] arr) {\r\n    // 把二叉树堆化\r\n    heap(arr);\r\n    //堆排序\r\n    for (int i = arr.length - 1; i >= 0; i--) {\r\n        // minHeapFixDown(arr, 0, i+1);\r\n        QuickSort.swap(arr, i, 0);\r\n        maxHeapFixDown(arr, 0, i);\r\n    }\r\n}\r\n\r\n// 对二叉树堆化\r\npublic static void heap(int[] arr) {\r\n    for (int i = arr.length / 2 - 1; i >= 0; i--) {\r\n        maxHeapFixDown(arr, i, arr.length);\r\n    }\r\n    System.out.println(\"heap:\" + Arrays.toString(arr));\r\n}\r\n```\r\n\r\n### 计数排序\r\n\r\n```java\r\npublic static void main(String[] args) {\r\n    int[] arr = { 3, 1, 4, 2, 5, 8, 6, 2, 3 };\r\n    System.out.println(Arrays.toString(arr));\r\n    //得到数组最大值\r\n    int max = arr[0];\r\n    for (int i = 1; i < arr.length; i++){\r\n        if (arr[i] > max){\r\n            max = arr[i];\r\n        }\r\n    }\r\n    //开辟辅助数组\r\n    int[] help = new int[max+1];\r\n    //下标映射\r\n    for (int i = 0; i < arr.length; i++) {\r\n        help[arr[i]]++;\r\n    }\r\n    \r\n    //根据下标排序\r\n    int p = 0;\r\n    for (int i = 0; i < help.length; i++) {\r\n        while (help[i] > 0){\r\n            arr[p++] = i;\r\n            help[i]--;\r\n        }\r\n    }\r\n    \r\n    System.out.println(Arrays.toString(arr));\r\n}\r\n```\r\n\r\n### 桶排序\r\n\r\n* 时间复杂度：O(N)~O(NlogN)\r\n* 实现：\r\n```java\r\npublic static void bucketSort(int[] arr){\r\n	//得到数组最大值\r\n	int max = CountSort.maxOfArray(arr);\r\n	//申明桶空间\r\n	LinkedNode[] bucket = new LinkedNode[arr.length];\r\n	for (int i = 0; i < arr.length; i++) {\r\n		//根据hash函数得到桶下标\r\n		int index = hash(arr[i], max, arr.length);\r\n		//放入桶中\r\n		insert(bucket, arr[i], index);\r\n	}\r\n	\r\n	//从桶中读出\r\n	int i = 0;\r\n	for (LinkedNode node : bucket) {\r\n		LinkedNode p = node;\r\n		while (p != null){\r\n			arr[i++] = p.data;\r\n			p = p.next;\r\n		}\r\n	}\r\n}\r\nprivate static void insert(LinkedNode[] bucket, int data, int index) {\r\n	LinkedNode node = new LinkedNode();\r\n	node.data = data;\r\n	if (bucket[index] == null){\r\n		//如果这个桶为空则之间赋值元素\r\n		bucket[index] = node;\r\n	}else{\r\n		//不为空则找按从小到大找到存放位置\r\n		LinkedNode p = bucket[index];\r\n		LinkedNode pre = p;\r\n		while (p != null && data > p.data){\r\n			pre = p;\r\n			p = p.next;\r\n		}\r\n		\r\n		node.next = pre.next;\r\n		pre.next = node;\r\n	}\r\n}\r\n//hash函数\r\nprivate static int hash(int i, int max, int length) {\r\n	return (i * length) / (max + 1);\r\n}\r\n```\r\n\r\n### 基数排序\r\n\r\n```java\r\npublic class RadixSort {\r\n	//创建桶  个数为0-9 10个\r\n	private static ArrayList<Integer>[] bucket = new ArrayList[10];\r\n	//初始化桶\r\n	static {\r\n		for (int i = 0; i < bucket.length; i++) {\r\n			bucket[i] = new ArrayList<Integer>();\r\n		}\r\n	}\r\n\r\n	public static void main(String[] args) {\r\n		int[] arr = { 13, 1, 4, 12, 5, 28, 6, 2, 3 };\r\n		//得到待排序数组中的最大位数\r\n		int max = CountSort.maxOfArray(arr);\r\n		int num = 0;\r\n		while (max > 0){\r\n			num++;\r\n			max /= 10;\r\n		}\r\n		\r\n		//依据每一位的大小放入桶中排序\r\n		for (int i = 1; i <= num; i++){\r\n			sort(arr, i);\r\n		}\r\n		\r\n		System.out.println(Arrays.toString(arr));\r\n	}\r\n\r\n	private static void sort(int[] arr, int i) {\r\n		//根据第i位的大小放入桶中\r\n		for (int j = 0; j < arr.length; j++) {\r\n			bucket[(int) ((arr[j] / Math.pow(10, i-1))%10)].add(arr[j]);\r\n		}\r\n		\r\n		//将桶中的数据放入原数组\r\n		int p = 0;\r\n		for (int j = 0; j < bucket.length; j++) {\r\n			for (int k : bucket[j]){\r\n				arr[p++] = k;\r\n			}\r\n		}\r\n		\r\n		//把桶清空\r\n		clear();\r\n	}\r\n\r\n	private static void clear() {\r\n		for (int j = 0; j < bucket.length; j++) {\r\n			bucket[j].clear();\r\n		}\r\n	}\r\n\r\n}\r\n```\r\n\r\n### 相关题解\r\n\r\n1. 给定已排序数组arr和k ,不重复打印arr中所有相加和为k的不降序二元组\r\n如输入arr={-8,-4,-3,0,2,4,5,8,9,10},k=10\r\n输出(0,10)(2,8)\r\n\r\n* 解：\r\n```java\r\npublic static void main(String[] args) {\r\n    int[] arr={-8,-4,-3,0,2,4,5,8,9,10};\r\n    int n = 10;\r\n    int i = 0;	//左指针\r\n    int j = arr.length - 1;	//右指针\r\n    //从两段向中间扫描\r\n    while (i < j){\r\n        int sum = arr[i] + arr[j];\r\n        //判断两数相加是否为n，如果和小于n则i向右寻找更大的数，如果和大于n则j向左寻找更小的数\r\n        if (sum == n){\r\n            System.out.println(\"(\" + arr[i] + \",\" + arr[j] + \")\");\r\n            i++;\r\n            j--;\r\n        }else if (sum < n){\r\n            i++;\r\n        }else{\r\n            j--;\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n* 扩展:三元组呢?(未解决)\r\n\r\n2. 需要排序的子数组\r\n\r\n    * 给定一个无序数组arr ,求出需要排序的最短子数组长度\r\n    要求: 0(N)\r\n    如输入: arr={2,3,7,5,4,6} ,返回4 ,因为只有{7,5,4,6}需要排序\r\n    * 解：\r\n    ```java\r\n    public static void main(String[] args) {\r\n		int[] arr = { 8, 9, 7, 5, 4, 3 };\r\n		System.out.println(Arrays.toString(find(arr)));\r\n		int[] arr2 = { 8, 7, 6, 5, 4, 2, 3, 1 };\r\n		System.out.println(Arrays.toString(find(arr2)));\r\n	}\r\n\r\n	// 找到无序子数组(升序)\r\n	public static int[] findByAsc(int[] arr) {\r\n		int p1 = -1;\r\n		int p2 = -1;\r\n		int max = arr[0];\r\n		// 寻找右边界\r\n		for (int i = 1; i < arr.length; i++) {\r\n			// 找到最大值\r\n			if (arr[i] > max) {\r\n				max = arr[i];\r\n			}\r\n			// 只要是在最大值右侧并且小于最大值的一定为无序\r\n			if (max > arr[i]) {\r\n				p2 = i;\r\n			}\r\n		}\r\n		// 寻找左边界\r\n		int min = arr[arr.length - 1];\r\n		for (int i = arr.length - 2; i >= 0; i--) {\r\n			// 找到历史最小值\r\n			if (arr[i] < min) {\r\n				min = arr[i];\r\n			}\r\n			// 只要是在最小值左侧并且大于最小值的一定无序\r\n			if (arr[i] > min) {\r\n				p1 = i;\r\n			}\r\n		}\r\n\r\n		if (p1 == -1) {\r\n			return new int[] { 0, 0 };\r\n		}\r\n\r\n		return new int[] { p1, p2 };\r\n	}\r\n\r\n	// 找到无序子数组(降序)\r\n	public static int[] findByDesc(int[] arr) {\r\n		int p1 = -1;\r\n		int p2 = -1;\r\n		int min = arr[0];\r\n		// 寻找右边界\r\n		for (int i = 1; i < arr.length; i++) {\r\n			// 找到最小值\r\n			if (arr[i] < min) {\r\n				min = arr[i];\r\n			}\r\n			// 只要是在最小值右侧并且大于最小值的一定为无序\r\n			if (min < arr[i]) {\r\n				p2 = i;\r\n			}\r\n		}\r\n		// 寻找左边界\r\n		int max = arr[arr.length - 1];\r\n		for (int i = arr.length - 2; i >= 0; i--) {\r\n			// 找到历史最大值\r\n			if (arr[i] > max) {\r\n				max = arr[i];\r\n			}\r\n			// 只要是在最大值左侧并且小于最大值的一定无序\r\n			if (arr[i] < max) {\r\n				p1 = i;\r\n			}\r\n		}\r\n\r\n		if (p1 == -1) {\r\n			return new int[] { 0, 0 };\r\n		}\r\n\r\n		return new int[] { p1, p2 };\r\n	}\r\n\r\n	// 找到无序子数组(升/降序)\r\n	public static int[] find(int[] arr) {\r\n		int[] asc = findByAsc(arr);\r\n		int ascL = asc[1] - asc[0] + 1;\r\n		int[] desc = findByDesc(arr);\r\n		int descL = desc[1] - desc[0] + 1;\r\n\r\n		if (ascL >= descL) {\r\n			return desc;\r\n		} else {\r\n			return asc;\r\n		}\r\n	}\r\n    ```\r\n\r\n3. 前k个数\r\n\r\n    * 求海量数据(正整数)按逆序排列的前k个数( topK) , 因为数据量太大,不能全部存储在内存中,只能一个一个地从磁盘或者网络\r\n    上读取数据,请设计一个高效的算法来解决这个问题不限制用户输入数据个数,用户每输入-个数据就回车使得程序可立即获得这个数据,用户输入-1代表输入终止，先输入K ,代表要求得topK\r\n    * 请输出topK ,从小到大,空格分割\r\n    * 解：\r\n    ```java\r\n    // 迭代方法 O(NK)\r\n	public static int[] topK() {\r\n		Scanner input = new Scanner(System.in);\r\n		int k = input.nextInt();\r\n		int[] arr = new int[k];\r\n		int n;\r\n		do {\r\n			n = input.nextInt();\r\n			//得到数组中的最小值\r\n			int minInd = min(arr);\r\n			//如果输入的数大于数组最小值则替换此最小值\r\n			if (n > arr[minInd]) {\r\n				arr[minInd] = n;\r\n			}\r\n		} while (n != -1);\r\n\r\n		return arr;\r\n	}\r\n\r\n	// 得到数组最小值 O(N)\r\n	private static int min(int[] arr) {\r\n		int minInd = 0;\r\n		for (int i = 1; i < arr.length; i++) {\r\n			if (arr[i] < arr[minInd]) {\r\n				minInd = i;\r\n			}\r\n		}\r\n\r\n		return minInd;\r\n	}\r\n	\r\n	//使用小顶堆 O(NlogK)\r\n	static int k;	//前k个数字\r\n	static int[] heap;	//堆内存\r\n	static int cnt;	//堆中已存在的元素个数\r\n	public static int[] topK2() {\r\n		Scanner input = new Scanner(System.in);\r\n		k = input.nextInt();\r\n		heap = new int[k];\r\n		int n;\r\n		do {\r\n			n = input.nextInt();\r\n			fun(n);\r\n		} while (n != -1);\r\n\r\n		return heap;\r\n	}\r\n\r\n	private static void fun(int n) {\r\n		//在堆填满之前只需要输入数据\r\n		if (cnt < k - 1){\r\n			heap[cnt++] = n;\r\n			return;\r\n		}\r\n		\r\n		if (cnt == k - 1){	//当堆填到只剩一个元素时\r\n			heap[cnt++] = n;\r\n			//初始化堆\r\n			BinaryTreeAndArray.heap(heap);\r\n		}else{\r\n			//如果输入数据大于小顶堆堆顶\r\n			if (n > heap[0]){\r\n				//替换堆顶元素\r\n				heap[0] = n;	\r\n				//调整堆\r\n				BinaryTreeAndArray.minHeapFixDown(heap, 0, heap.length);	\r\n			}\r\n		}\r\n		System.out.println(Arrays.toString(heap));\r\n	}\r\n    ```\r\n\r\n4. 所有员工年龄排序\r\n\r\n    * 公司现在要对几万员工的年龄进行排序,因为公司员工的人数非常多,所以要求排序算法的效率要非常高,你能写出这样的程序吗\r\n    输入:输入可能包含多个测试样例,对于每个测试案例,输入的第一-行为- 一个整数n(1<= n<=1000000) :代表公司内员工的人数。\r\n    输入的第二行包括n个整数:代表公司内每个员工的年龄。其中，员工年龄\r\n    age的取值范围为(1<=age<=99)。\r\n    * 输出:对应每个测试案例,请输出排序后的n个员工的年龄，每个年龄后面有一个空格。\r\n    * 解：使用计数排序\r\n	```java\r\n	public static void main(String[] args) {\r\n		//得到员工年龄\r\n		int ages[] = new int[10000];\r\n		Random r = new Random();\r\n		for (int i = 0; i < ages.length; i++) {\r\n			ages[i] = r.nextInt(100);\r\n		}\r\n		System.out.println(Arrays.toString(ages));\r\n		//放入计数桶中\r\n		int[] bucket = new int[100];\r\n		for (int i = 0; i < ages.length; i++) {\r\n			bucket[ages[i]]++;\r\n		}\r\n		\r\n		//得到排序结果\r\n		int p = 0;\r\n		for (int i = 0; i < bucket.length; i++) {\r\n			while (bucket[i] != 0){\r\n				ages[p++] = i;\r\n				bucket[i]--;\r\n			}\r\n		}\r\n		System.out.println(Arrays.toString(ages));\r\n	}\r\n	```\r\n\r\n5. 数组能排成的最小数(特殊排序)\r\n    * 输入一个正整数数组,把数组里所有整数拼接起来排成一个数,打印出能拼接出的所有数字中最小的一个。\r\n    例如输入数组{3,32,321} ,则打印出这3个数字能排成的最小数字为: 321323\r\n    * 解：\r\n    ```java\r\n    public static void main(String[] args) {\r\n		Integer[] arr = {3, 32, 321};\r\n		\r\n		Arrays.sort(arr, new Comparator<Integer>() {\r\n\r\n			@Override\r\n			//两个数的比较规则为相互在前和在后所组成数的大小做比较\r\n			public int compare(Integer o1, Integer o2) {\r\n				String s1 = o1 + \"\" + o2;\r\n				String s2 = o2 + \"\" + o1;\r\n				return s1.compareTo(s2);\r\n			}\r\n		});\r\n		\r\n		StringBuilder res = new StringBuilder();\r\n		for (int i = 0; i < arr.length; i++) {\r\n			res.append(arr[i]);\r\n		}\r\n		System.out.println(res.toString());\r\n	}\r\n    ```    \r\n\r\n6. 字符串(数组)的包含\r\n    * 输入两个字符串str1和str2，请判断str1中的字符是否都存在于str2中。  \r\n    ```java\r\n    //s2中所有字符s1是否包含\r\n	public static boolean fun(String s1, String s2){\r\n		char[] s1Arr = s1.toCharArray();\r\n		//排序\r\n		Arrays.sort(s1Arr);\r\n		for (int i = 0; i < s2.length(); i++) {\r\n			//使用二分查找\r\n			int index = Arrays.binarySearch(s1Arr, s2.charAt(i));\r\n			if (index < 0){\r\n				return false;\r\n			}\r\n		}\r\n		\r\n		return true;\r\n	}\r\n    ```', '2020-06-24 11:08:09', '0', '分治法分治法(divideandconquer，D&amp;C):将原问题划分成若干个规模较小而结构', '/static/img/rand/9.jpg', '排序', '0', 'post', '0', '2020-06-24 11:08:09', '1592968089', null);
INSERT INTO `plog_article` VALUES ('157', '14', '<h3 id=\"-\">树的基本概念及实现</h3>\r\n<h4 id=\"-\">树的实现</h4>\r\n<h5 id=\"-\">操作定义</h5>\r\n<pre><code class=\"lang-java\"><span class=\"hljs-comment\">/**\r\n * 树接口\r\n * <span class=\"hljs-doctag\">@author</span> 96047\r\n *\r\n * <span class=\"hljs-doctag\">@param</span> &lt;E&gt;\r\n */</span>\r\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">interface</span> <span class=\"hljs-title\">ITree</span>&lt;<span class=\"hljs-title\">E</span>&gt; </span>{\r\n    <span class=\"hljs-comment\">//节点数</span>\r\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">size</span><span class=\"hljs-params\">()</span></span>;\r\n\r\n    <span class=\"hljs-comment\">//获取根节点</span>\r\n    <span class=\"hljs-function\">TreeNode&lt;E&gt; <span class=\"hljs-title\">getRoot</span><span class=\"hljs-params\">()</span></span>;\r\n\r\n    <span class=\"hljs-comment\">//获取n的父节点</span>\r\n    <span class=\"hljs-function\">TreeNode&lt;E&gt; <span class=\"hljs-title\">getParent</span><span class=\"hljs-params\">(TreeNode&lt;E&gt; n)</span></span>;\r\n\r\n    <span class=\"hljs-comment\">//获取第一个儿子</span>\r\n    <span class=\"hljs-function\">TreeNode&lt;E&gt; <span class=\"hljs-title\">getFirstChild</span><span class=\"hljs-params\">(TreeNode&lt;E&gt; p)</span></span>;\r\n\r\n    <span class=\"hljs-comment\">//获取n的下一个兄弟</span>\r\n    <span class=\"hljs-function\">TreeNode&lt;E&gt; <span class=\"hljs-title\">getNextSibling</span><span class=\"hljs-params\">(TreeNode&lt;E&gt; n)</span></span>;\r\n\r\n    <span class=\"hljs-comment\">//子树高度</span>\r\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">getHight</span><span class=\"hljs-params\">(TreeNode&lt;E&gt; n)</span></span>;\r\n\r\n    <span class=\"hljs-comment\">//插入子节点</span>\r\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">insertChild</span><span class=\"hljs-params\">(TreeNode&lt;E&gt; n, TreeNode&lt;E&gt; child)</span></span>;\r\n\r\n    <span class=\"hljs-comment\">//删除第i个子节点</span>\r\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">deleteChild</span><span class=\"hljs-params\">(TreeNode&lt;E&gt; n, <span class=\"hljs-keyword\">int</span> i)</span></span>;\r\n\r\n    <span class=\"hljs-comment\">//先序遍历</span>\r\n    List&lt;TreeNode&lt;E&gt;&gt; preOrder(TreeNode&lt;E&gt; n);\r\n\r\n    <span class=\"hljs-comment\">//后序遍历</span>\r\n    List&lt;TreeNode&lt;E&gt;&gt; postOrder(TreeNode&lt;E&gt; n);\r\n\r\n    <span class=\"hljs-comment\">//层序遍历</span>\r\n    List&lt;List&lt;TreeNode&lt;E&gt;&gt;&gt; levelOrder(TreeNode&lt;E&gt; n);\r\n\r\n    List&lt;List&lt;TreeNode&lt;E&gt;&gt;&gt; levelOrder();\r\n}\r\n</code></pre>\r\n<h5 id=\"-\">节点定义</h5>\r\n<pre><code class=\"lang-java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">TreeNode</span>&lt;E&gt; {</span>\r\n    <span class=\"hljs-keyword\">public</span> E data;\r\n    <span class=\"hljs-keyword\">public</span> TreeNode&lt;E&gt; parent;\r\n    <span class=\"hljs-keyword\">public</span> List&lt;TreeNode&lt;E&gt;&gt; children;\r\n\r\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-title\">TreeNode</span><span class=\"hljs-params\">(E data, TreeNode&lt;E&gt; parent)</span></span>{\r\n        <span class=\"hljs-keyword\">this</span>.data = data;\r\n        <span class=\"hljs-keyword\">this</span>.parent = parent;\r\n    }\r\n\r\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-title\">TreeNode</span><span class=\"hljs-params\">(E data)</span></span>{\r\n        <span class=\"hljs-keyword\">this</span>.data = data;\r\n    }\r\n\r\n    @<span class=\"hljs-function\">Override\r\n    <span class=\"hljs-keyword\">public</span> String <span class=\"hljs-title\">toString</span><span class=\"hljs-params\">()</span> </span>{\r\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">\"data = \"</span> + data;\r\n    }\r\n}\r\n</code></pre>\r\n<h5 id=\"-\">实现</h5>\r\n<pre><code class=\"lang-java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">MyTree</span>&lt;<span class=\"hljs-title\">E</span>&gt; <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title\">ITree</span>&lt;<span class=\"hljs-title\">E</span>&gt; </span>{\r\n    <span class=\"hljs-keyword\">private</span> TreeNode&lt;E&gt; root;\r\n    <span class=\"hljs-keyword\">private</span> int size;\r\n\r\n    <span class=\"hljs-keyword\">public</span> MyTree(TreeNode&lt;E&gt; root){\r\n        this.root = root;\r\n        size++;\r\n    }\r\n\r\n    @Override\r\n    <span class=\"hljs-keyword\">public</span> int size() {\r\n        <span class=\"hljs-keyword\">return</span> size;\r\n    }\r\n\r\n    @Override\r\n    <span class=\"hljs-keyword\">public</span> TreeNode&lt;E&gt; getRoot() {\r\n        <span class=\"hljs-keyword\">return</span> root;\r\n    }\r\n\r\n    @Override\r\n    <span class=\"hljs-keyword\">public</span> TreeNode&lt;E&gt; getParent(TreeNode&lt;E&gt; n) {\r\n        <span class=\"hljs-keyword\">if</span> (n == <span class=\"hljs-keyword\">null</span>){\r\n            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">null</span>;\r\n        }<span class=\"hljs-keyword\">else</span>{\r\n            <span class=\"hljs-keyword\">return</span> n.<span class=\"hljs-keyword\">parent</span>;\r\n        }\r\n    }\r\n\r\n    @Override\r\n    <span class=\"hljs-keyword\">public</span> TreeNode&lt;E&gt; getFirstChild(TreeNode&lt;E&gt; p) {\r\n        <span class=\"hljs-keyword\">if</span> (p == <span class=\"hljs-keyword\">null</span> || p.children == <span class=\"hljs-keyword\">null</span>){\r\n            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">null</span>;\r\n        }<span class=\"hljs-keyword\">else</span>{\r\n            <span class=\"hljs-keyword\">return</span> p.children.get(<span class=\"hljs-number\">0</span>);\r\n        }\r\n    }\r\n\r\n    @Override\r\n    <span class=\"hljs-keyword\">public</span> TreeNode&lt;E&gt; getNextSibling(TreeNode&lt;E&gt; n) {\r\n        <span class=\"hljs-keyword\">if</span> (n == <span class=\"hljs-keyword\">null</span> || n.<span class=\"hljs-keyword\">parent</span> == <span class=\"hljs-keyword\">null</span>){\r\n            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">null</span>;\r\n        }<span class=\"hljs-keyword\">else</span>{\r\n            int index = n.<span class=\"hljs-keyword\">parent</span>.children.indexOf(n);\r\n            TreeNode&lt;E&gt; t = n.<span class=\"hljs-keyword\">parent</span>.children.get(index + <span class=\"hljs-number\">1</span>);\r\n            <span class=\"hljs-keyword\">return</span> t;\r\n        }\r\n    }\r\n\r\n    @Override\r\n    <span class=\"hljs-keyword\">public</span> int getHight(TreeNode&lt;E&gt; n) {\r\n        <span class=\"hljs-keyword\">if</span> (n.children == <span class=\"hljs-keyword\">null</span>){\r\n            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;\r\n        }\r\n        int h = <span class=\"hljs-number\">0</span>;\r\n        <span class=\"hljs-keyword\">for</span> (TreeNode&lt;E&gt; t : n.children){\r\n            h = Math.max(h, getHight(t));\r\n        }\r\n\r\n        <span class=\"hljs-keyword\">return</span> h + <span class=\"hljs-number\">1</span>;\r\n    }\r\n\r\n    @Override\r\n    <span class=\"hljs-keyword\">public</span> void insertChild(TreeNode&lt;E&gt; n, TreeNode&lt;E&gt; child) {\r\n        <span class=\"hljs-keyword\">if</span> (n.children == <span class=\"hljs-keyword\">null</span>){\r\n            n.children = <span class=\"hljs-keyword\">new</span> ArrayList&lt;TreeNode&lt;E&gt;&gt;();\r\n        }\r\n        n.children.add(child);\r\n        child.<span class=\"hljs-keyword\">parent</span> = n;\r\n        size++;\r\n    }\r\n\r\n    @Override\r\n    <span class=\"hljs-keyword\">public</span> void deleteChild(TreeNode&lt;E&gt; n, int i) {\r\n        n.children.remove(i);\r\n        size--;\r\n    }\r\n\r\n    @Override\r\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">List</span>&lt;TreeNode&lt;E&gt;&gt; preOrder(TreeNode&lt;E&gt; n) {\r\n        <span class=\"hljs-keyword\">if</span> (n.children == <span class=\"hljs-keyword\">null</span>){\r\n            <span class=\"hljs-keyword\">List</span>&lt;TreeNode&lt;E&gt;&gt; <span class=\"hljs-keyword\">list</span> = <span class=\"hljs-keyword\">new</span> ArrayList&lt;TreeNode&lt;E&gt;&gt;();\r\n            <span class=\"hljs-keyword\">list</span>.add(n);\r\n\r\n            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">list</span>;\r\n        }\r\n        <span class=\"hljs-keyword\">List</span>&lt;TreeNode&lt;E&gt;&gt; <span class=\"hljs-keyword\">list</span> = <span class=\"hljs-keyword\">new</span> ArrayList&lt;TreeNode&lt;E&gt;&gt;();\r\n        <span class=\"hljs-comment\">//遍历根</span>\r\n        <span class=\"hljs-keyword\">list</span>.add(n);\r\n        <span class=\"hljs-comment\">//得到子层遍历结果</span>\r\n        <span class=\"hljs-keyword\">List</span>&lt;TreeNode&lt;E&gt;&gt; listC = <span class=\"hljs-keyword\">null</span>;\r\n        <span class=\"hljs-keyword\">for</span> (TreeNode&lt;E&gt; t : n.children){\r\n            listC = preOrder(t);\r\n            <span class=\"hljs-keyword\">list</span>.addAll(listC);\r\n        }\r\n\r\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">list</span>;\r\n    }\r\n\r\n    @Override\r\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">List</span>&lt;TreeNode&lt;E&gt;&gt; postOrder(TreeNode&lt;E&gt; n) {\r\n        <span class=\"hljs-keyword\">if</span> (n.children == <span class=\"hljs-keyword\">null</span>){\r\n            <span class=\"hljs-keyword\">List</span>&lt;TreeNode&lt;E&gt;&gt; <span class=\"hljs-keyword\">list</span> = <span class=\"hljs-keyword\">new</span> ArrayList&lt;TreeNode&lt;E&gt;&gt;();\r\n            <span class=\"hljs-keyword\">list</span>.add(n);\r\n            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">list</span>;\r\n        }\r\n        <span class=\"hljs-comment\">//得到子层遍历结果</span>\r\n        <span class=\"hljs-keyword\">List</span>&lt;TreeNode&lt;E&gt;&gt; <span class=\"hljs-keyword\">list</span> = <span class=\"hljs-keyword\">new</span> ArrayList&lt;TreeNode&lt;E&gt;&gt;();\r\n        <span class=\"hljs-keyword\">for</span> (TreeNode&lt;E&gt; t : n.children){\r\n            <span class=\"hljs-keyword\">list</span>.addAll(postOrder(t));\r\n        }\r\n        <span class=\"hljs-comment\">//加入根</span>\r\n        <span class=\"hljs-keyword\">list</span>.add(n);\r\n\r\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">list</span>;\r\n    }\r\n\r\n    @Override\r\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">List</span>&lt;<span class=\"hljs-keyword\">List</span>&lt;TreeNode&lt;E&gt;&gt;&gt; levelOrder(TreeNode&lt;E&gt; n) {\r\n        <span class=\"hljs-keyword\">List</span>&lt;<span class=\"hljs-keyword\">List</span>&lt;TreeNode&lt;E&gt;&gt;&gt; res = <span class=\"hljs-keyword\">new</span> ArrayList&lt;<span class=\"hljs-keyword\">List</span>&lt;TreeNode&lt;E&gt;&gt;&gt;();\r\n        <span class=\"hljs-keyword\">List</span>&lt;TreeNode&lt;E&gt;&gt; <span class=\"hljs-keyword\">list</span> = <span class=\"hljs-keyword\">new</span> ArrayList&lt;TreeNode&lt;E&gt;&gt;();\r\n        <span class=\"hljs-comment\">//初始化队列</span>\r\n        Queue&lt;TreeNode&lt;E&gt;&gt; queue = <span class=\"hljs-keyword\">new</span> LinkedList&lt;TreeNode&lt;E&gt;&gt;();\r\n        queue.add(n);\r\n        <span class=\"hljs-comment\">//双指针记录层级关系</span>\r\n        TreeNode&lt;E&gt; p = n;    <span class=\"hljs-comment\">//游标指针</span>\r\n        TreeNode&lt;E&gt; last = n;    <span class=\"hljs-comment\">//该层最后一个元素</span>\r\n\r\n        <span class=\"hljs-keyword\">while</span> (!queue.isEmpty()){\r\n            <span class=\"hljs-comment\">//弹出一个</span>\r\n            TreeNode&lt;E&gt; t = queue.poll();\r\n            <span class=\"hljs-keyword\">list</span>.add(t);\r\n\r\n            <span class=\"hljs-comment\">//加入n个</span>\r\n            <span class=\"hljs-keyword\">if</span> (t.children != <span class=\"hljs-keyword\">null</span>){\r\n                <span class=\"hljs-keyword\">for</span> (TreeNode&lt;E&gt; tn : t.children){\r\n                    queue.add(tn);\r\n                    p = tn;    <span class=\"hljs-comment\">//游标指针指向新加入队列的最后一个元素</span>\r\n                }\r\n            }\r\n            <span class=\"hljs-comment\">//如果弹出的元素是该层最后一个元素</span>\r\n            <span class=\"hljs-keyword\">if</span> (t == last){\r\n                last = p;    <span class=\"hljs-comment\">//last指向下一层最后一个元素</span>\r\n                res.add(<span class=\"hljs-keyword\">list</span>);    <span class=\"hljs-comment\">//该层遍历结果加入总结果集</span>\r\n                <span class=\"hljs-keyword\">list</span> = <span class=\"hljs-keyword\">new</span> ArrayList&lt;TreeNode&lt;E&gt;&gt;();    <span class=\"hljs-comment\">//初始化新一层结果集</span>\r\n            }\r\n        }\r\n\r\n        <span class=\"hljs-keyword\">return</span> res;\r\n    }\r\n\r\n    @Override\r\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">List</span>&lt;<span class=\"hljs-keyword\">List</span>&lt;TreeNode&lt;E&gt;&gt;&gt; levelOrder() {\r\n        <span class=\"hljs-keyword\">return</span> levelOrder(root);\r\n    }\r\n\r\n}\r\n</code></pre>\r\n<h5 id=\"-\">测试</h5>\r\n<pre><code class=\"lang-java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">TestTree</span> {\r\n\r\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">main</span>(<span class=\"hljs-params\">String[] args</span>) </span>{\r\n        TreeNode&lt;Integer&gt; root = <span class=\"hljs-keyword\">new</span> TreeNode&lt;Integer&gt;(<span class=\"hljs-number\">0</span>);\r\n        MyTree&lt;Integer&gt; tree = <span class=\"hljs-keyword\">new</span> MyTree&lt;&gt;(root);\r\n\r\n        TreeNode&lt;Integer&gt; node1 = <span class=\"hljs-keyword\">new</span> TreeNode&lt;Integer&gt;(<span class=\"hljs-number\">1</span>);\r\n        tree.insertChild(root, node1);\r\n        TreeNode&lt;Integer&gt; node2 = <span class=\"hljs-keyword\">new</span> TreeNode&lt;Integer&gt;(<span class=\"hljs-number\">2</span>);\r\n        tree.insertChild(root, node2);\r\n        TreeNode&lt;Integer&gt; node3 = <span class=\"hljs-keyword\">new</span> TreeNode&lt;Integer&gt;(<span class=\"hljs-number\">3</span>);\r\n        tree.insertChild(root, node3);\r\n\r\n        TreeNode&lt;Integer&gt; node11 = <span class=\"hljs-keyword\">new</span> TreeNode&lt;Integer&gt;(<span class=\"hljs-number\">11</span>);\r\n        tree.insertChild(node1, node11);\r\n        TreeNode&lt;Integer&gt; node12 = <span class=\"hljs-keyword\">new</span> TreeNode&lt;Integer&gt;(<span class=\"hljs-number\">12</span>);\r\n        tree.insertChild(node1, node12);\r\n        TreeNode&lt;Integer&gt; node13 = <span class=\"hljs-keyword\">new</span> TreeNode&lt;Integer&gt;(<span class=\"hljs-number\">13</span>);\r\n        tree.insertChild(node1, node13);\r\n\r\n        TreeNode&lt;Integer&gt; node111 = <span class=\"hljs-keyword\">new</span> TreeNode&lt;Integer&gt;(<span class=\"hljs-number\">111</span>);\r\n        tree.insertChild(node11, node111);\r\n        TreeNode&lt;Integer&gt; node1111 = <span class=\"hljs-keyword\">new</span> TreeNode&lt;Integer&gt;(<span class=\"hljs-number\">1111</span>);\r\n        tree.insertChild(node111, node1111);\r\n        TreeNode&lt;Integer&gt; node11111 = <span class=\"hljs-keyword\">new</span> TreeNode&lt;Integer&gt;(<span class=\"hljs-number\">11111</span>);\r\n        tree.insertChild(node1111, node11111);\r\n\r\n        List&lt;TreeNode&lt;Integer&gt;&gt; list = tree.preOrder(root);\r\n        System.<span class=\"hljs-keyword\">out</span>.println(list);\r\n\r\n        list = tree.postOrder(root);\r\n        System.<span class=\"hljs-keyword\">out</span>.println(list);\r\n\r\n        System.<span class=\"hljs-keyword\">out</span>.println(tree.size());\r\n        System.<span class=\"hljs-keyword\">out</span>.println(tree.getHight(root));\r\n        System.<span class=\"hljs-keyword\">out</span>.println(tree.getFirstChild(node111));\r\n        System.<span class=\"hljs-keyword\">out</span>.println(tree.getNextSibling(node12));\r\n        System.<span class=\"hljs-keyword\">out</span>.println(tree.getParent(node111));\r\n        tree.deleteChild(node1, <span class=\"hljs-number\">2</span>);\r\n        System.<span class=\"hljs-keyword\">out</span>.println(tree.preOrder(root));\r\n        System.<span class=\"hljs-keyword\">out</span>.println(tree.size());\r\n\r\n        <span class=\"hljs-keyword\">for</span> (List&lt;TreeNode&lt;Integer&gt;&gt; l : tree.levelOrder()){\r\n            System.<span class=\"hljs-keyword\">out</span>.println(l);\r\n        }\r\n    }\r\n}\r\n</code></pre>\r\n<h3 id=\"-\">二叉树的基本概念及实现</h3>\r\n<h4 id=\"-\">二叉树的性值</h4>\r\n<ol>\r\n<li>在非空二叉树中，第i层的结点总数不超过 , i&gt;=1；</li>\r\n<li>深度为h的二叉树最多有 个结点(h&gt;=1)，最少有h个结点；</li>\r\n<li>对于任意一棵二叉树，如果其叶结点数为N0，而度数为2的结点总数为N2，则N0=N2+1；</li>\r\n<li>具有n个结点的完全二叉树的深度为 （注：[ ]表示向下取整）</li>\r\n<li>有N个结点的完全二叉树各结点如果用顺序方式存储，则结点之间有如下关系：<br>若I为结点编号则 如果I&gt;1，则其父结点的编号为I/2；<br>如果2<em>I&lt;=N，则其左孩子（即左子树的根结点）的编号为2</em>I；若2<em>I&gt;N，则无左孩子；<br>如果2</em>I+1&lt;=N，则其右孩子的结点编号为2<em>I+1；若2</em>I+1&gt;N，则无右孩子。</li>\r\n</ol>\r\n<h3 id=\"-\">二叉查找树</h3>\r\n<h4 id=\"-\">操作定义</h4>\r\n<pre><code class=\"lang-java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">interface</span> <span class=\"hljs-title\">IBinarySearchTree</span>&lt;<span class=\"hljs-title\">K</span>, <span class=\"hljs-title\">V</span>&gt; </span>{\r\n    <span class=\"hljs-comment\">//插入一个节点</span>\r\n    <span class=\"hljs-function\">BSTNode&lt;K, V&gt; <span class=\"hljs-title\">insert</span><span class=\"hljs-params\">(K key, V value)</span></span>;\r\n\r\n    <span class=\"hljs-comment\">//中序遍历</span>\r\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">inOrder</span><span class=\"hljs-params\">(Consumer&lt;K&gt; con)</span></span>;\r\n\r\n    <span class=\"hljs-comment\">//查找value</span>\r\n    <span class=\"hljs-function\">V <span class=\"hljs-title\">lookUpValue</span><span class=\"hljs-params\">(K key)</span></span>;\r\n\r\n    <span class=\"hljs-comment\">//获取最大关键字</span>\r\n    <span class=\"hljs-function\">K <span class=\"hljs-title\">max</span><span class=\"hljs-params\">()</span></span>;\r\n\r\n    <span class=\"hljs-comment\">//获取最小关键字</span>\r\n    <span class=\"hljs-function\">K <span class=\"hljs-title\">min</span><span class=\"hljs-params\">()</span></span>;\r\n\r\n    <span class=\"hljs-comment\">//删除节点</span>\r\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">remove</span><span class=\"hljs-params\">(K key)</span></span>;\r\n\r\n    <span class=\"hljs-comment\">//第一个比k大的节点</span>\r\n    <span class=\"hljs-function\">K <span class=\"hljs-title\">successor</span><span class=\"hljs-params\">(K key)</span></span>;\r\n\r\n    <span class=\"hljs-comment\">//前一个比K小的节点</span>\r\n    <span class=\"hljs-function\">K <span class=\"hljs-title\">predecessor</span><span class=\"hljs-params\">(K key)</span></span>;\r\n\r\n    <span class=\"hljs-comment\">//二叉树是否平衡</span>\r\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">boolean</span> <span class=\"hljs-title\">isBalance</span><span class=\"hljs-params\">()</span></span>;\r\n\r\n    <span class=\"hljs-comment\">//节点数</span>\r\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">getSize</span><span class=\"hljs-params\">()</span></span>;\r\n\r\n    <span class=\"hljs-comment\">//高度</span>\r\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">getHeight</span><span class=\"hljs-params\">()</span></span>;\r\n\r\n    <span class=\"hljs-comment\">//层序遍历</span>\r\n    List&lt;List&lt;BSTNode&lt;K, V&gt;&gt;&gt; levelOrder();\r\n}\r\n</code></pre>\r\n<h4 id=\"-\">节点定义</h4>\r\n<pre><code class=\"lang-java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">BSTNode</span>&lt;<span class=\"hljs-title\">K</span>, <span class=\"hljs-title\">V</span>&gt; </span>{\r\n    <span class=\"hljs-keyword\">public</span> K key;\r\n    <span class=\"hljs-keyword\">public</span> V vlaue;\r\n    <span class=\"hljs-keyword\">public</span> BSTNode&lt;K, V&gt; left;\r\n    <span class=\"hljs-keyword\">public</span> BSTNode&lt;K, V&gt; right;\r\n    <span class=\"hljs-keyword\">public</span> BSTNode&lt;K, V&gt; parent;\r\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">boolean</span> isLeftChild;\r\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">int</span> height;\r\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">int</span> num;\r\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">boolean</span> isRed = <span class=\"hljs-keyword\">true</span>;\r\n\r\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-title\">BSTNode</span><span class=\"hljs-params\">(K key, V vlaue, BSTNode&lt;K, V&gt; left, BSTNode&lt;K, V&gt; right, BSTNode&lt;K, V&gt; parent)</span> </span>{\r\n        <span class=\"hljs-keyword\">super</span>();\r\n        <span class=\"hljs-keyword\">this</span>.key = key;\r\n        <span class=\"hljs-keyword\">this</span>.vlaue = vlaue;\r\n        <span class=\"hljs-keyword\">this</span>.left = left;\r\n        <span class=\"hljs-keyword\">this</span>.right = right;\r\n        <span class=\"hljs-keyword\">this</span>.parent = parent;\r\n    }\r\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-title\">BSTNode</span><span class=\"hljs-params\">(K key, V vlaue)</span> </span>{\r\n        <span class=\"hljs-keyword\">super</span>();\r\n        <span class=\"hljs-keyword\">this</span>.key = key;\r\n        <span class=\"hljs-keyword\">this</span>.vlaue = vlaue;\r\n    }\r\n    <span class=\"hljs-meta\">@Override</span>\r\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> String <span class=\"hljs-title\">toString</span><span class=\"hljs-params\">()</span> </span>{\r\n        StringBuilder res = <span class=\"hljs-keyword\">new</span> StringBuilder();\r\n        <span class=\"hljs-keyword\">if</span> (isRed){\r\n            res.append(<span class=\"hljs-string\">\"[\"</span> + key + <span class=\"hljs-string\">\"]\"</span>);\r\n        }<span class=\"hljs-keyword\">else</span>{\r\n            res.append(<span class=\"hljs-string\">\"(\"</span> + key + <span class=\"hljs-string\">\")\"</span>);\r\n        }\r\n        <span class=\"hljs-keyword\">if</span> (parent != <span class=\"hljs-keyword\">null</span>){\r\n            res.append(<span class=\"hljs-string\">\"&lt;--\"</span> + parent.key);\r\n        }\r\n        <span class=\"hljs-keyword\">return</span> res.toString();\r\n    }\r\n}\r\n</code></pre>\r\n<h4 id=\"-\">实现</h4>\r\n<pre><code class=\"lang-java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">BinarySearchTree</span>&lt;<span class=\"hljs-title\">K</span>, <span class=\"hljs-title\">V</span>&gt; <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title\">IBinarySearchTree</span>&lt;<span class=\"hljs-title\">K</span>, <span class=\"hljs-title\">V</span>&gt; </span>{\r\n    <span class=\"hljs-keyword\">protected</span> BSTNode&lt;K, V&gt; root;\r\n    <span class=\"hljs-keyword\">protected</span> <span class=\"hljs-keyword\">int</span> size;\r\n    <span class=\"hljs-keyword\">protected</span> Comparator&lt;K&gt; comparator;\r\n\r\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-title\">BinarySearchTree</span><span class=\"hljs-params\">(BSTNode&lt;K, V&gt; root)</span> </span>{\r\n        <span class=\"hljs-keyword\">super</span>();\r\n        <span class=\"hljs-keyword\">this</span>.root = root;\r\n    }\r\n\r\n    <span class=\"hljs-meta\">@Override</span>\r\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> BSTNode&lt;K, V&gt; <span class=\"hljs-title\">insert</span><span class=\"hljs-params\">(K key, V value)</span> </span>{\r\n        <span class=\"hljs-keyword\">if</span> (!(key <span class=\"hljs-keyword\">instanceof</span> Comparable)) {\r\n            <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> ClassCastException();\r\n        }\r\n        BSTNode&lt;K, V&gt; p = <span class=\"hljs-keyword\">null</span>;\r\n        BSTNode&lt;K, V&gt; cur = root;\r\n        <span class=\"hljs-comment\">// 找到应该插入的位置的父节点</span>\r\n        <span class=\"hljs-keyword\">while</span> (cur != <span class=\"hljs-keyword\">null</span>) {\r\n            p = cur;\r\n            <span class=\"hljs-keyword\">if</span> (compare(cur.key, key) &lt; <span class=\"hljs-number\">0</span>) {\r\n                cur = cur.right;\r\n            } <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (compare(cur.key, key) &gt; <span class=\"hljs-number\">0</span>) {\r\n                cur = cur.left;\r\n            } <span class=\"hljs-keyword\">else</span> {\r\n                cur.vlaue = value;\r\n                <span class=\"hljs-keyword\">return</span> cur;\r\n            }\r\n        }\r\n        cur = <span class=\"hljs-keyword\">new</span> BSTNode&lt;K, V&gt;(key, value);\r\n        <span class=\"hljs-comment\">// 如果树为空</span>\r\n        <span class=\"hljs-keyword\">if</span> (p == <span class=\"hljs-keyword\">null</span>) {\r\n            root = cur;\r\n        } <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (compare(p.key, key) &gt; <span class=\"hljs-number\">0</span>) {\r\n            p.left = cur;\r\n            cur.isLeftChild = <span class=\"hljs-keyword\">true</span>;\r\n        } <span class=\"hljs-keyword\">else</span> {\r\n            p.right = cur;\r\n            cur.isLeftChild = <span class=\"hljs-keyword\">false</span>;\r\n        }\r\n        cur.parent = p;\r\n        size++;\r\n        updateHight(cur);\r\n        <span class=\"hljs-keyword\">return</span> cur;\r\n    }\r\n\r\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">protected</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">updateHight</span><span class=\"hljs-params\">(BSTNode&lt;K, V&gt; cur)</span> </span>{\r\n        <span class=\"hljs-keyword\">if</span> (cur.parent == <span class=\"hljs-keyword\">null</span>) {\r\n            <span class=\"hljs-keyword\">return</span>;\r\n        }\r\n        BSTNode&lt;K, V&gt; p = cur.parent;\r\n        <span class=\"hljs-keyword\">if</span> (cur.height == p.height) {\r\n            p.height++;\r\n            updateHight(p);\r\n        }\r\n    }\r\n\r\n    <span class=\"hljs-meta\">@Override</span>\r\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">inOrder</span><span class=\"hljs-params\">(Consumer&lt;K&gt; con)</span> </span>{\r\n        <span class=\"hljs-keyword\">if</span> (root != <span class=\"hljs-keyword\">null</span>) {\r\n            inOrder(root, con);\r\n        }\r\n    }\r\n\r\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">protected</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">inOrder</span><span class=\"hljs-params\">(BSTNode&lt;K, V&gt; cur, Consumer&lt;K&gt; con)</span> </span>{\r\n        <span class=\"hljs-keyword\">if</span> (cur == <span class=\"hljs-keyword\">null</span>)\r\n            <span class=\"hljs-keyword\">return</span>;\r\n        inOrder(cur.left, con);\r\n        con.accept(cur.key);\r\n        inOrder(cur.right, con);\r\n    }\r\n\r\n    <span class=\"hljs-meta\">@Override</span>\r\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> V <span class=\"hljs-title\">lookUpValue</span><span class=\"hljs-params\">(K key)</span> </span>{\r\n        <span class=\"hljs-keyword\">return</span> lookupNode(key).vlaue;\r\n    }\r\n\r\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">protected</span> BSTNode&lt;K, V&gt; <span class=\"hljs-title\">lookupNode</span><span class=\"hljs-params\">(K key)</span> </span>{\r\n        BSTNode&lt;K, V&gt; cur = root;\r\n        <span class=\"hljs-keyword\">while</span> (cur != <span class=\"hljs-keyword\">null</span>) {\r\n            <span class=\"hljs-keyword\">if</span> (compare(cur.key, key) == <span class=\"hljs-number\">0</span>) {\r\n                <span class=\"hljs-keyword\">return</span> cur;\r\n            } <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (compare(cur.key, key) &gt; <span class=\"hljs-number\">0</span>) {\r\n                cur = cur.left;\r\n            } <span class=\"hljs-keyword\">else</span> {\r\n                cur = cur.right;\r\n            }\r\n        }\r\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">null</span>;\r\n    }\r\n\r\n    <span class=\"hljs-meta\">@Override</span>\r\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> K <span class=\"hljs-title\">max</span><span class=\"hljs-params\">()</span> </span>{\r\n        <span class=\"hljs-keyword\">return</span> maxNode(root).key;\r\n    }\r\n\r\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">protected</span> BSTNode&lt;K, V&gt; <span class=\"hljs-title\">maxNode</span><span class=\"hljs-params\">(BSTNode&lt;K, V&gt; p)</span> </span>{\r\n        <span class=\"hljs-keyword\">while</span> (p.right != <span class=\"hljs-keyword\">null</span>)\r\n            p = p.right;\r\n        <span class=\"hljs-keyword\">return</span> p;\r\n    }\r\n\r\n    <span class=\"hljs-meta\">@Override</span>\r\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> K <span class=\"hljs-title\">min</span><span class=\"hljs-params\">()</span> </span>{\r\n        <span class=\"hljs-keyword\">return</span> minNode(root).key;\r\n    }\r\n\r\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">protected</span> BSTNode&lt;K, V&gt; <span class=\"hljs-title\">minNode</span><span class=\"hljs-params\">(BSTNode&lt;K, V&gt; p)</span> </span>{\r\n        <span class=\"hljs-keyword\">while</span> (p.left != <span class=\"hljs-keyword\">null</span>)\r\n            p = p.left;\r\n        <span class=\"hljs-keyword\">return</span> p;\r\n    }\r\n\r\n    <span class=\"hljs-meta\">@Override</span>\r\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">remove</span><span class=\"hljs-params\">(K key)</span> </span>{\r\n        BSTNode&lt;K, V&gt; p = lookupNode(key);\r\n        <span class=\"hljs-comment\">// 没找到</span>\r\n        <span class=\"hljs-keyword\">if</span> (p == <span class=\"hljs-keyword\">null</span>) {\r\n            <span class=\"hljs-keyword\">return</span>;\r\n        }\r\n        <span class=\"hljs-comment\">// 只有一个根节点</span>\r\n        <span class=\"hljs-keyword\">if</span> (p.parent == <span class=\"hljs-keyword\">null</span>) {\r\n            root = <span class=\"hljs-keyword\">null</span>;\r\n            size--;\r\n            <span class=\"hljs-keyword\">return</span>;\r\n        }\r\n        <span class=\"hljs-comment\">// 叶子节点</span>\r\n        <span class=\"hljs-keyword\">if</span> (p.left == <span class=\"hljs-keyword\">null</span> &amp;&amp; p.right == <span class=\"hljs-keyword\">null</span>) {\r\n            <span class=\"hljs-keyword\">if</span> (p.isLeftChild) {\r\n                p.parent.left = <span class=\"hljs-keyword\">null</span>;\r\n            } <span class=\"hljs-keyword\">else</span> {\r\n                p.parent.right = <span class=\"hljs-keyword\">null</span>;\r\n            }\r\n            p.parent = <span class=\"hljs-keyword\">null</span>;\r\n            p = <span class=\"hljs-keyword\">null</span>;\r\n            size--;\r\n            <span class=\"hljs-keyword\">return</span>;\r\n        }\r\n        <span class=\"hljs-comment\">// 有一个孩子</span>\r\n        <span class=\"hljs-keyword\">if</span> (p.left == <span class=\"hljs-keyword\">null</span>) {\r\n            <span class=\"hljs-keyword\">if</span> (p.isLeftChild) {\r\n                p.parent.left = p.right;\r\n                p.isLeftChild = <span class=\"hljs-keyword\">true</span>;\r\n                p.right.parent = p.parent;\r\n            } <span class=\"hljs-keyword\">else</span> {\r\n                p.parent.right = p.right;\r\n                p.right.parent = p.parent;\r\n            }\r\n            p.parent = <span class=\"hljs-keyword\">null</span>;\r\n            p = <span class=\"hljs-keyword\">null</span>;\r\n            size--;\r\n            <span class=\"hljs-keyword\">return</span>;\r\n        }\r\n        <span class=\"hljs-keyword\">if</span> (p.right == <span class=\"hljs-keyword\">null</span>) {\r\n            <span class=\"hljs-keyword\">if</span> (p.isLeftChild) {\r\n                p.parent.left = p.left;\r\n                p.isLeftChild = <span class=\"hljs-keyword\">true</span>;\r\n            } <span class=\"hljs-keyword\">else</span> {\r\n                p.parent.right = p.left;\r\n                p.isLeftChild = <span class=\"hljs-keyword\">false</span>;\r\n            }\r\n            p.left.parent = p.parent;\r\n            p.parent = <span class=\"hljs-keyword\">null</span>;\r\n            p = <span class=\"hljs-keyword\">null</span>;\r\n            size--;\r\n            <span class=\"hljs-keyword\">return</span>;\r\n        }\r\n        <span class=\"hljs-comment\">// 有两个孩子</span>\r\n        BSTNode&lt;K, V&gt; minOfRight = minNode(p.right);\r\n        p.key = minOfRight.key;\r\n        p.vlaue = minOfRight.vlaue;\r\n        remove(minOfRight.key);\r\n    }\r\n\r\n    <span class=\"hljs-meta\">@Override</span>\r\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> K <span class=\"hljs-title\">successor</span><span class=\"hljs-params\">(K key)</span> </span>{\r\n        BSTNode&lt;K, V&gt; p = lookupNode(key);\r\n        <span class=\"hljs-keyword\">if</span> (p == <span class=\"hljs-keyword\">null</span>)    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">null</span>;\r\n        <span class=\"hljs-keyword\">if</span> (p.right != <span class=\"hljs-keyword\">null</span>){\r\n            <span class=\"hljs-comment\">//右子树中最小的元素</span>\r\n            <span class=\"hljs-keyword\">return</span> minNode(p.right).key;\r\n        }\r\n        <span class=\"hljs-comment\">//向上找第一个是左孩子的节点的父节点</span>\r\n        <span class=\"hljs-keyword\">while</span> (p != <span class=\"hljs-keyword\">null</span> &amp;&amp; !p.isLeftChild){\r\n            p = p.parent;\r\n        }\r\n        <span class=\"hljs-keyword\">return</span> p == <span class=\"hljs-keyword\">null</span> ? <span class=\"hljs-keyword\">null</span>:p.parent.key;\r\n    }\r\n\r\n    <span class=\"hljs-meta\">@Override</span>\r\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> K <span class=\"hljs-title\">predecessor</span><span class=\"hljs-params\">(K key)</span> </span>{\r\n        BSTNode&lt;K, V&gt; p = lookupNode(key);\r\n        <span class=\"hljs-keyword\">if</span> (p == <span class=\"hljs-keyword\">null</span>)    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">null</span>;\r\n        <span class=\"hljs-keyword\">if</span> (p.left != <span class=\"hljs-keyword\">null</span>){\r\n            <span class=\"hljs-comment\">//左子树中最大的元素</span>\r\n            <span class=\"hljs-keyword\">return</span> maxNode(p.left).key;\r\n        }\r\n        <span class=\"hljs-comment\">//向上找第一个是右孩子的节点的父节点</span>\r\n        <span class=\"hljs-keyword\">while</span> (p != <span class=\"hljs-keyword\">null</span> &amp;&amp; p.isLeftChild){\r\n            p = p.parent;\r\n        }\r\n        <span class=\"hljs-keyword\">return</span> p == <span class=\"hljs-keyword\">null</span> ? <span class=\"hljs-keyword\">null</span>:p.parent.key;\r\n    }\r\n\r\n    <span class=\"hljs-meta\">@Override</span>\r\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">boolean</span> <span class=\"hljs-title\">isBalance</span><span class=\"hljs-params\">()</span> </span>{\r\n        <span class=\"hljs-keyword\">return</span> !unBalance(root);\r\n    }\r\n\r\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">protected</span> <span class=\"hljs-keyword\">boolean</span> <span class=\"hljs-title\">unBalance</span><span class=\"hljs-params\">(BSTNode&lt;K, V&gt; n)</span></span>{\r\n        <span class=\"hljs-keyword\">if</span> (n == <span class=\"hljs-keyword\">null</span>) <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">false</span>;\r\n        <span class=\"hljs-keyword\">int</span> x = Math.abs(getHight(n.left) - getHight(n.right));\r\n        <span class=\"hljs-keyword\">return</span> x &gt; <span class=\"hljs-number\">1</span> || unBalance(n.left) || unBalance(n.right);\r\n    }\r\n\r\n    <span class=\"hljs-meta\">@Override</span>\r\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">getSize</span><span class=\"hljs-params\">()</span> </span>{\r\n        <span class=\"hljs-keyword\">return</span> size;\r\n    }\r\n\r\n    <span class=\"hljs-meta\">@Override</span>\r\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">getHeight</span><span class=\"hljs-params\">()</span></span>{\r\n        <span class=\"hljs-keyword\">return</span> getHight(root);\r\n    }\r\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">protected</span> <span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">getHight</span><span class=\"hljs-params\">(BSTNode&lt;K, V&gt; p)</span> </span>{\r\n        <span class=\"hljs-keyword\">if</span> (p == <span class=\"hljs-keyword\">null</span>){\r\n            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;\r\n        }\r\n        <span class=\"hljs-keyword\">int</span> max = Math.max(getHight(p.left), getHight(p.right));\r\n        <span class=\"hljs-keyword\">return</span> max + <span class=\"hljs-number\">1</span>;\r\n    }\r\n\r\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">protected</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">rightRotate</span><span class=\"hljs-params\">(BSTNode&lt;K, V&gt; g, BSTNode&lt;K, V&gt; p)</span> </span>{\r\n        BSTNode&lt;K, V&gt; gp = g.parent;\r\n        <span class=\"hljs-keyword\">boolean</span> gb = g.isLeftChild;\r\n\r\n        g.parent = p;\r\n        g.isLeftChild = <span class=\"hljs-keyword\">false</span>;\r\n\r\n\r\n        <span class=\"hljs-comment\">//处理B</span>\r\n        <span class=\"hljs-keyword\">if</span> (p.right != <span class=\"hljs-keyword\">null</span>){\r\n            g.left = p.right;\r\n            g.left.isLeftChild = <span class=\"hljs-keyword\">true</span>;\r\n            g.left.parent = g;\r\n        }<span class=\"hljs-keyword\">else</span>{\r\n            g.left = <span class=\"hljs-keyword\">null</span>;\r\n        }\r\n        p.right = g;\r\n\r\n        <span class=\"hljs-comment\">//处理p</span>\r\n        <span class=\"hljs-keyword\">if</span> (gp != <span class=\"hljs-keyword\">null</span>){\r\n            p.parent = gp;\r\n            p.isLeftChild = gb;\r\n            <span class=\"hljs-comment\">//处理上一级</span>\r\n            <span class=\"hljs-keyword\">if</span> (gb){\r\n                p.parent.left = p;\r\n            }<span class=\"hljs-keyword\">else</span>{\r\n                p.parent.right = p;\r\n            }\r\n        }<span class=\"hljs-keyword\">else</span>{\r\n            root = p;\r\n            p.parent = <span class=\"hljs-keyword\">null</span>;\r\n        }\r\n    }\r\n\r\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">protected</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">leftRotate</span><span class=\"hljs-params\">(BSTNode&lt;K, V&gt; g, BSTNode&lt;K, V&gt; p)</span> </span>{\r\n        BSTNode&lt;K, V&gt; gp = g.parent;\r\n        <span class=\"hljs-keyword\">boolean</span> gb = g.isLeftChild;\r\n\r\n        g.parent = p;\r\n        g.isLeftChild = <span class=\"hljs-keyword\">true</span>;\r\n\r\n\r\n        <span class=\"hljs-comment\">//处理B</span>\r\n        <span class=\"hljs-keyword\">if</span> (p.left != <span class=\"hljs-keyword\">null</span>){\r\n            g.right = p.left;\r\n            g.right.isLeftChild = <span class=\"hljs-keyword\">false</span>;\r\n            g.right.parent = g;\r\n        }<span class=\"hljs-keyword\">else</span>{\r\n            g.right = <span class=\"hljs-keyword\">null</span>;\r\n        }\r\n        p.left = g;\r\n\r\n        <span class=\"hljs-comment\">//处理p</span>\r\n        <span class=\"hljs-keyword\">if</span> (gp != <span class=\"hljs-keyword\">null</span>){\r\n            p.parent = gp;\r\n            p.isLeftChild = gb;\r\n            <span class=\"hljs-comment\">//处理上一级</span>\r\n            <span class=\"hljs-keyword\">if</span> (gb){\r\n                p.parent.left = p;\r\n            }<span class=\"hljs-keyword\">else</span>{\r\n                p.parent.right = p;\r\n            }\r\n        }<span class=\"hljs-keyword\">else</span>{\r\n            root = p;\r\n            p.parent = <span class=\"hljs-keyword\">null</span>;\r\n        }\r\n    }\r\n\r\n    <span class=\"hljs-meta\">@Override</span>\r\n    <span class=\"hljs-keyword\">public</span> List&lt;List&lt;BSTNode&lt;K, V&gt;&gt;&gt; levelOrder() {\r\n        BSTNode&lt;K, V&gt; p = root;\r\n        List&lt;List&lt;BSTNode&lt;K, V&gt;&gt;&gt; res = <span class=\"hljs-keyword\">new</span> ArrayList&lt;&gt;();\r\n        List&lt;BSTNode&lt;K, V&gt;&gt; list = <span class=\"hljs-keyword\">new</span> ArrayList&lt;BSTNode&lt;K,V&gt;&gt;();\r\n        Queue&lt;BSTNode&lt;K, V&gt;&gt; queue = <span class=\"hljs-keyword\">new</span> LinkedList&lt;BSTNode&lt;K,V&gt;&gt;();\r\n        queue.add(p);\r\n        BSTNode&lt;K, V&gt; last = p;\r\n        BSTNode&lt;K, V&gt; n = p;\r\n\r\n        <span class=\"hljs-keyword\">while</span> (!queue.isEmpty()){\r\n            <span class=\"hljs-comment\">//弹出一个</span>\r\n            p = queue.poll();\r\n            list.add(p);\r\n            <span class=\"hljs-comment\">//进入n个</span>\r\n            <span class=\"hljs-keyword\">if</span> (p.left != <span class=\"hljs-keyword\">null</span>){\r\n                p.left.num = p.num * <span class=\"hljs-number\">2</span>;\r\n                queue.add(p.left);\r\n                n = p.left;\r\n            }\r\n            <span class=\"hljs-keyword\">if</span> (p.right != <span class=\"hljs-keyword\">null</span>){\r\n                p.right.num = p.num * <span class=\"hljs-number\">2</span> + <span class=\"hljs-number\">1</span>;\r\n                queue.add(p.right);\r\n                n = p.right;\r\n            }\r\n            <span class=\"hljs-keyword\">if</span> (p == last){\r\n                res.add(list);\r\n                list = <span class=\"hljs-keyword\">new</span> ArrayList&lt;&gt;();\r\n                last = n;\r\n            }\r\n        }\r\n\r\n        <span class=\"hljs-keyword\">return</span> res;\r\n    }\r\n\r\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">protected</span> <span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">compare</span><span class=\"hljs-params\">(K key1, K key2)</span> </span>{\r\n        <span class=\"hljs-comment\">// 判断是否有自定义比较器</span>\r\n        <span class=\"hljs-keyword\">if</span> (comparator == <span class=\"hljs-keyword\">null</span>) {\r\n            <span class=\"hljs-keyword\">return</span> ((Comparable) key1).compareTo((Comparable) key2);\r\n        } <span class=\"hljs-keyword\">else</span> {\r\n            <span class=\"hljs-keyword\">return</span> comparator.compare(key1, key2);\r\n        }\r\n    }\r\n}\r\n</code></pre>\r\n<ul>\r\n<li>当二叉查找树成为斜树时，它的查找效率会从O(logn)退化到O(N),因此需要尽量保持二叉查找树的平衡。</li>\r\n</ul>\r\n<h4 id=\"-\">二叉平衡树</h4>\r\n<ul>\r\n<li>AVL是最先发明的自平衡二叉查找树</li>\r\n<li>AVL树所有节点的平衡因子(高度最大差)的绝对值不大于1，需要在BST的基础上在插入和删除时维护平衡即可。</li>\r\n<li>AVL is a BST.</li>\r\n</ul>\r\n<h5 id=\"-\">新增操作</h5>\r\n<p><img src=\"/images/lanqiao/avl.png\" alt=\"\"><br><img src=\"/images/lanqiao/avl2.png\" alt=\"\"></p>\r\n<h5 id=\"-\">删除操作</h5>\r\n<p><img src=\"/images/lanqiao/avl3.png\" alt=\"\"></p>\r\n<h5 id=\"-\">实现</h5>\r\n<pre><code class=\"lang-java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">AVLTree</span>&lt;<span class=\"hljs-title\">K</span>, <span class=\"hljs-title\">V</span>&gt; <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">BinarySearchTree</span>&lt;<span class=\"hljs-title\">K</span>, <span class=\"hljs-title\">V</span>&gt; <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title\">IBinarySearchTree</span>&lt;<span class=\"hljs-title\">K</span>, <span class=\"hljs-title\">V</span>&gt; </span>{\r\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-title\">AVLTree</span><span class=\"hljs-params\">(BSTNode&lt;K, V&gt; root)</span> </span>{\r\n        <span class=\"hljs-keyword\">super</span>(root);\r\n    }\r\n\r\n    <span class=\"hljs-meta\">@Override</span>\r\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> BSTNode&lt;K, V&gt; <span class=\"hljs-title\">insert</span><span class=\"hljs-params\">(K key, V value)</span> </span>{\r\n        <span class=\"hljs-comment\">//插入节点</span>\r\n        BSTNode&lt;K, V&gt; node = <span class=\"hljs-keyword\">super</span>.insert(key, value);\r\n        <span class=\"hljs-comment\">//找到不平衡的节点坐标</span>\r\n        BSTNode&lt;K, V&gt;[] gps = findUnBalance(node);\r\n        <span class=\"hljs-keyword\">if</span> (gps != <span class=\"hljs-keyword\">null</span>){\r\n            <span class=\"hljs-comment\">//重新调整平衡</span>\r\n            reBalance(gps);\r\n        }\r\n        <span class=\"hljs-keyword\">return</span> node;\r\n    }\r\n    <span class=\"hljs-comment\">//根据gps将二叉树调整平衡</span>\r\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">reBalance</span><span class=\"hljs-params\">(BSTNode&lt;K, V&gt;[] gps)</span> </span>{\r\n        <span class=\"hljs-keyword\">if</span> (gps == <span class=\"hljs-keyword\">null</span>) <span class=\"hljs-keyword\">return</span>;\r\n        BSTNode&lt;K, V&gt; g = gps[<span class=\"hljs-number\">0</span>];\r\n        BSTNode&lt;K, V&gt; p = gps[<span class=\"hljs-number\">1</span>];\r\n        BSTNode&lt;K, V&gt; s = gps[<span class=\"hljs-number\">2</span>];\r\n\r\n        <span class=\"hljs-comment\">//判型</span>\r\n        <span class=\"hljs-keyword\">if</span> (p.isLeftChild &amp;&amp; s.isLeftChild){    <span class=\"hljs-comment\">//左左型</span>\r\n            rightRotate(g, p);\r\n        }<span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (!p.isLeftChild &amp;&amp; !s.isLeftChild){ <span class=\"hljs-comment\">//右右型</span>\r\n            leftRotate(g, p);\r\n        }<span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (p.isLeftChild &amp;&amp; !s.isLeftChild){    <span class=\"hljs-comment\">//左右型</span>\r\n            leftRotate(p, s);\r\n            rightRotate(g, s);\r\n        }<span class=\"hljs-keyword\">else</span>{    <span class=\"hljs-comment\">//右左型</span>\r\n            rightRotate(p, s);\r\n            leftRotate(g, s);\r\n        }\r\n    }\r\n\r\n    <span class=\"hljs-comment\">//向上寻找到第一个不平衡的祖先</span>\r\n    <span class=\"hljs-keyword\">private</span> BSTNode&lt;K, V&gt;[] findUnBalance(BSTNode&lt;K, V&gt; node) {\r\n        <span class=\"hljs-keyword\">if</span> (node == <span class=\"hljs-keyword\">null</span>) <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">null</span>;\r\n        BSTNode&lt;K, V&gt; s = node;\r\n        <span class=\"hljs-keyword\">if</span> (node.parent == <span class=\"hljs-keyword\">null</span>) <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">null</span>;\r\n        BSTNode&lt;K, V&gt; p = node.parent;\r\n        <span class=\"hljs-keyword\">if</span> (p.parent == <span class=\"hljs-keyword\">null</span>) <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">null</span>;\r\n        BSTNode&lt;K, V&gt; g = p.parent;\r\n        <span class=\"hljs-keyword\">if</span> (unBalance(g)){\r\n            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> BSTNode[]{g, p, s};\r\n        }<span class=\"hljs-keyword\">else</span>{\r\n            <span class=\"hljs-keyword\">return</span> findUnBalance(p);\r\n        }\r\n    }\r\n\r\n    <span class=\"hljs-meta\">@Override</span>\r\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">remove</span><span class=\"hljs-params\">(K key)</span> </span>{\r\n        BSTNode&lt;K, V&gt; node = lookupNode(key);\r\n        <span class=\"hljs-keyword\">if</span> (node == <span class=\"hljs-keyword\">null</span>)     <span class=\"hljs-keyword\">return</span>;\r\n\r\n        <span class=\"hljs-keyword\">if</span> (node.left == <span class=\"hljs-keyword\">null</span> &amp;&amp; node.right == <span class=\"hljs-keyword\">null</span>){\r\n            <span class=\"hljs-comment\">//如果是叶子节点直接删除后重新调整平衡</span>\r\n            <span class=\"hljs-keyword\">super</span>.remove(key);\r\n            reBalance(node.parent);\r\n        }<span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (node.left == <span class=\"hljs-keyword\">null</span>){\r\n            <span class=\"hljs-comment\">//如果只有右孩子,在右侧找最小值替换当前节点，然后删除右侧最小值节点</span>\r\n            BSTNode&lt;K, V&gt; su = minNode(node.right);\r\n            <span class=\"hljs-keyword\">super</span>.remove(su.key);\r\n            node.key = su.key;\r\n            node.vlaue = su.vlaue;\r\n            reBalance(su.parent);\r\n        }<span class=\"hljs-keyword\">else</span>{\r\n            <span class=\"hljs-comment\">//如果只有左孩子或有左右孩子，在左侧找最大值替换当前节点，然后删除左侧最大值节点</span>\r\n            BSTNode&lt;K, V&gt; pr = maxNode(node.left);\r\n            <span class=\"hljs-keyword\">super</span>.remove(pr.key);\r\n            node.key = pr.key;\r\n            node.vlaue = pr.vlaue;\r\n            reBalance(pr.parent);\r\n        }\r\n    }\r\n\r\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">reBalance</span><span class=\"hljs-params\">(BSTNode&lt;K, V&gt; p)</span> </span>{\r\n        <span class=\"hljs-keyword\">if</span> (p == <span class=\"hljs-keyword\">null</span>)    <span class=\"hljs-keyword\">return</span>;\r\n\r\n        <span class=\"hljs-keyword\">int</span> leftHeight = getHight(p.left);\r\n        <span class=\"hljs-keyword\">int</span> rightHeight = getHight(p.right);\r\n\r\n        <span class=\"hljs-keyword\">if</span> (leftHeight - rightHeight &gt; <span class=\"hljs-number\">1</span>){\r\n            <span class=\"hljs-comment\">//左侧高</span>\r\n            rightRotate(p, p.left);\r\n            reBalance(p.left);\r\n        }<span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (rightHeight - leftHeight &gt; <span class=\"hljs-number\">1</span>){\r\n            <span class=\"hljs-comment\">//右侧高</span>\r\n            leftRotate(p, p.right);\r\n            reBalance(p.right);\r\n        }<span class=\"hljs-keyword\">else</span>{\r\n            reBalance(p.parent);\r\n        }\r\n    }\r\n}\r\n</code></pre>\r\n<h4 id=\"-\">红黑树</h4>\r\n<ul>\r\n<li>要求不那么严格的平衡树一红黑树</li>\r\n<li>(1).节点都有颜色标记,且只能是红色或黑色。</li>\r\n<li>(2).根是黑色。</li>\r\n<li>(3).所有叶子都是黑色(叶子是NIL/nill_节点,不保存实际的数据)。</li>\r\n<li>(4).每个红色节点必须有两个黑色的子节点,也可以表述为从每个叶子到根的所有路径上不能有两个连续的红色节点。</li>\r\n<li>(5).从任一节点到其每个叶子的所有简单路径都包含相同数目的黑色节点。</li>\r\n<li>根黑，红黑,叶黑,红不连,同黑</li>\r\n</ul>\r\n<h5 id=\"-\">新增节点</h5>\r\n<p><img src=\"/images/lanqiao/rbt.png\" alt=\"\"><br><img src=\"/images/lanqiao/rbt2.png\" alt=\"\"></p>\r\n<h5 id=\"-\">删除节点</h5>\r\n<p><img src=\"/images/lanqiao/rbt3.png\" alt=\"\"></p>\r\n<ul>\r\n<li>红黑树删除及修复<br> 1、双支转单支<br> 2、删除D，并顶替N<br> 3、D为黑，需修复<br> 4、N为红，很简单（N变黑即可）<br> N为黑，系列复杂的修复</li>\r\n</ul>\r\n<h5 id=\"-\">实现</h5>\r\n<pre><code class=\"lang-java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">RedBlackTree</span>&lt;<span class=\"hljs-title\">K</span>, <span class=\"hljs-title\">V</span>&gt; <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">BinarySearchTree</span>&lt;<span class=\"hljs-title\">K</span>, <span class=\"hljs-title\">V</span>&gt; <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title\">IBinarySearchTree</span>&lt;<span class=\"hljs-title\">K</span>, <span class=\"hljs-title\">V</span>&gt; </span>{\r\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">final</span> boolean RED = <span class=\"hljs-keyword\">true</span>;\r\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">final</span> boolean BLACK = <span class=\"hljs-keyword\">false</span>;\r\n\r\n    <span class=\"hljs-keyword\">public</span> RedBlackTree(BSTNode&lt;K, V&gt; root) {\r\n        super(root);\r\n        colorBlack(root);\r\n    }\r\n\r\n    @Override\r\n    <span class=\"hljs-keyword\">public</span> BSTNode&lt;K, V&gt; insert(K key, V value) {\r\n        <span class=\"hljs-comment\">//插入节点</span>\r\n        BSTNode&lt;K, V&gt; node = super.insert(key, value);\r\n        <span class=\"hljs-comment\">//调整插入节点后的红黑树</span>\r\n        adjust(node);\r\n        <span class=\"hljs-comment\">//根节点染黑</span>\r\n        colorBlack(root);\r\n        size++;\r\n        <span class=\"hljs-keyword\">return</span> node;\r\n    }\r\n\r\n    <span class=\"hljs-comment\">//插入新节点后重新调整红黑树</span>\r\n    <span class=\"hljs-keyword\">private</span> void adjust(BSTNode&lt;K, V&gt; node){\r\n        <span class=\"hljs-keyword\">if</span> (node == <span class=\"hljs-keyword\">null</span>)     <span class=\"hljs-keyword\">return</span>;\r\n        BSTNode&lt;K, V&gt; <span class=\"hljs-keyword\">parent</span> = node.<span class=\"hljs-keyword\">parent</span>;\r\n        <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">parent</span> == <span class=\"hljs-keyword\">null</span>)    <span class=\"hljs-keyword\">return</span>;\r\n        <span class=\"hljs-comment\">//如果父节点为红色破坏了红不连的规则</span>\r\n        <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">parent</span>.isRed == RED){\r\n            BSTNode&lt;K, V&gt; grand = <span class=\"hljs-keyword\">parent</span>.<span class=\"hljs-keyword\">parent</span>;\r\n            BSTNode&lt;K, V&gt; uncle = <span class=\"hljs-keyword\">parent</span>.isLeftChild ? <span class=\"hljs-keyword\">parent</span>.<span class=\"hljs-keyword\">parent</span>.right : <span class=\"hljs-keyword\">parent</span>.<span class=\"hljs-keyword\">parent</span>.left;\r\n\r\n            <span class=\"hljs-keyword\">if</span> (uncle != <span class=\"hljs-keyword\">null</span> &amp;&amp; uncle.isRed == RED){\r\n                <span class=\"hljs-comment\">//如果uncle为红，gpu反色</span>\r\n                colorRed(grand);\r\n                colorBlack(<span class=\"hljs-keyword\">parent</span>);\r\n                colorBlack(uncle);\r\n                adjust(grand);\r\n            }<span class=\"hljs-keyword\">else</span>{\r\n                <span class=\"hljs-comment\">//uncle为黑的情况</span>\r\n                <span class=\"hljs-keyword\">if</span> (node.isLeftChild &amp;&amp; <span class=\"hljs-keyword\">parent</span>.isLeftChild){\r\n                    <span class=\"hljs-comment\">//左左型 pg反色 向右旋转</span>\r\n                    colorBlack(<span class=\"hljs-keyword\">parent</span>);\r\n                    colorRed(grand);\r\n                    rightRotate(grand, <span class=\"hljs-keyword\">parent</span>);\r\n                }<span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">parent</span>.isLeftChild &amp;&amp; !node.isLeftChild){\r\n                    <span class=\"hljs-comment\">//左右型 沿着p旋转 变成左左型</span>\r\n                    leftRotate(<span class=\"hljs-keyword\">parent</span>, node);\r\n                    adjust(<span class=\"hljs-keyword\">parent</span>);\r\n                }<span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (!<span class=\"hljs-keyword\">parent</span>.isLeftChild &amp;&amp; node.isLeftChild){\r\n                    <span class=\"hljs-comment\">//右左型 沿着p旋转 变成右右型</span>\r\n                    rightRotate(<span class=\"hljs-keyword\">parent</span>, node);\r\n                    adjust(<span class=\"hljs-keyword\">parent</span>);\r\n                }<span class=\"hljs-keyword\">else</span>{\r\n                    <span class=\"hljs-comment\">//右右型 pg反色 向左旋转</span>\r\n                    colorBlack(<span class=\"hljs-keyword\">parent</span>);\r\n                    colorRed(grand);\r\n                    leftRotate(grand, <span class=\"hljs-keyword\">parent</span>);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    <span class=\"hljs-keyword\">private</span> void colorRed(BSTNode&lt;K, V&gt; node){\r\n        <span class=\"hljs-keyword\">if</span> (node != <span class=\"hljs-keyword\">null</span>)    node.isRed = RED;\r\n    }\r\n\r\n    <span class=\"hljs-keyword\">private</span> void colorBlack(BSTNode&lt;K, V&gt; node){\r\n        <span class=\"hljs-keyword\">if</span> (node != <span class=\"hljs-keyword\">null</span>)    node.isRed = BLACK;\r\n    }\r\n\r\n    @Override\r\n    <span class=\"hljs-keyword\">public</span> void remove(K key) {\r\n        BSTNode&lt;K, V&gt; del = lookupNode(key);\r\n        <span class=\"hljs-keyword\">if</span> (del == <span class=\"hljs-keyword\">null</span>)    <span class=\"hljs-keyword\">return</span>;\r\n\r\n        <span class=\"hljs-comment\">//如果有左右孩子 转移为单支或叶子节点</span>\r\n        <span class=\"hljs-keyword\">if</span> (del.left != <span class=\"hljs-keyword\">null</span> &amp;&amp; del.right != <span class=\"hljs-keyword\">null</span>){\r\n            <span class=\"hljs-comment\">//从右子树中找到最小值</span>\r\n            BSTNode&lt;K, V&gt; n = lookupNode(successor(key));\r\n            del.key = n.key;\r\n            del.vlaue = n.vlaue;\r\n            <span class=\"hljs-comment\">//del指向最小值节点 为待删除节点</span>\r\n            del = n;\r\n        }\r\n\r\n        <span class=\"hljs-comment\">//此时待删除节点一定为单支或者叶子节点</span>\r\n        <span class=\"hljs-comment\">//找到顶替节点</span>\r\n        BSTNode&lt;K, V&gt; n = <span class=\"hljs-keyword\">null</span>;\r\n        <span class=\"hljs-keyword\">if</span> (del.left != <span class=\"hljs-keyword\">null</span>){\r\n            n = del.left;\r\n        }<span class=\"hljs-keyword\">else</span>{\r\n            n = del.right;\r\n        }\r\n\r\n        <span class=\"hljs-keyword\">if</span> (n == <span class=\"hljs-keyword\">null</span>){    <span class=\"hljs-comment\">//待删除节点为叶子</span>\r\n            <span class=\"hljs-keyword\">if</span> (del.<span class=\"hljs-keyword\">parent</span> == <span class=\"hljs-keyword\">null</span>){\r\n                <span class=\"hljs-comment\">//待删除节点为根节点</span>\r\n                root = <span class=\"hljs-keyword\">null</span>;\r\n                <span class=\"hljs-keyword\">return</span>;\r\n            }\r\n            <span class=\"hljs-comment\">//如果删除的叶子节点为黑色需要先修复</span>\r\n            <span class=\"hljs-keyword\">if</span> (del.isRed == BLACK){\r\n                repair(del);\r\n            }\r\n            <span class=\"hljs-comment\">//删除叶子</span>\r\n            <span class=\"hljs-keyword\">if</span> (del.<span class=\"hljs-keyword\">parent</span>.isLeftChild){\r\n                del.<span class=\"hljs-keyword\">parent</span>.left = <span class=\"hljs-keyword\">null</span>;\r\n            }<span class=\"hljs-keyword\">else</span>{\r\n                del.<span class=\"hljs-keyword\">parent</span>.right = <span class=\"hljs-keyword\">null</span>;\r\n            }\r\n            del.<span class=\"hljs-keyword\">parent</span> = <span class=\"hljs-keyword\">null</span>;\r\n            del = <span class=\"hljs-keyword\">null</span>;\r\n        }<span class=\"hljs-keyword\">else</span>{\r\n            <span class=\"hljs-comment\">//单支 使用孩子节点顶替待删除节点</span>\r\n            n.<span class=\"hljs-keyword\">parent</span> = del.<span class=\"hljs-keyword\">parent</span>;\r\n            <span class=\"hljs-keyword\">if</span> (n.<span class=\"hljs-keyword\">parent</span> == <span class=\"hljs-keyword\">null</span>){\r\n                root = n;\r\n                colorBlack(root);\r\n            }\r\n            n.isLeftChild = del.isLeftChild;\r\n            <span class=\"hljs-keyword\">if</span> (n.isLeftChild){\r\n                n.<span class=\"hljs-keyword\">parent</span>.left = n;\r\n            }<span class=\"hljs-keyword\">else</span>{\r\n                n.<span class=\"hljs-keyword\">parent</span>.right = n;\r\n            }\r\n            del.left = del.right = del.<span class=\"hljs-keyword\">parent</span> = <span class=\"hljs-keyword\">null</span>;\r\n\r\n            <span class=\"hljs-keyword\">if</span> (del.isRed == BLACK){\r\n                repair(n);\r\n            }\r\n        }\r\n        size--;\r\n    }\r\n\r\n    <span class=\"hljs-comment\">//删除后修复红黑树</span>\r\n    <span class=\"hljs-keyword\">private</span> void repair(BSTNode&lt;K, V&gt; n) {\r\n        <span class=\"hljs-keyword\">if</span> (n.isRed == RED){\r\n            <span class=\"hljs-comment\">//顶替节点为红色直接染黑</span>\r\n            colorBlack(n);\r\n        }<span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (n.<span class=\"hljs-keyword\">parent</span> != <span class=\"hljs-keyword\">null</span>){\r\n            <span class=\"hljs-comment\">//n为黑 double black 有若干种情况</span>\r\n            case2(n);\r\n        }\r\n    }\r\n\r\n    <span class=\"hljs-comment\">//sib is red 父兄反色     旋转</span>\r\n    <span class=\"hljs-keyword\">private</span> void case2(BSTNode&lt;K, V&gt; n) {\r\n        BSTNode&lt;K, V&gt; sib = getSib(n);\r\n        <span class=\"hljs-keyword\">if</span> (sib.isRed){\r\n            colorBlack(sib);\r\n            colorRed(n.<span class=\"hljs-keyword\">parent</span>);\r\n            <span class=\"hljs-keyword\">if</span> (n == n.<span class=\"hljs-keyword\">parent</span>.left){\r\n                leftRotate(n.<span class=\"hljs-keyword\">parent</span>, sib);\r\n            }<span class=\"hljs-keyword\">else</span>{\r\n                rightRotate(n.<span class=\"hljs-keyword\">parent</span>, sib);\r\n            }\r\n        }\r\n        case3(n);\r\n    }\r\n\r\n    <span class=\"hljs-comment\">//parent is black 且sib双子为黑  sib-&gt;red 递归p-&gt;case1</span>\r\n    <span class=\"hljs-keyword\">private</span> void case3(BSTNode&lt;K, V&gt; n) {\r\n        BSTNode&lt;K, V&gt; sib = getSib(n);\r\n        boolean sibL = sib.left == <span class=\"hljs-keyword\">null</span> ? BLACK : sib.left.isRed;\r\n        boolean sibR = sib.right == <span class=\"hljs-keyword\">null</span> ? BLACK : sib.right.isRed;\r\n        <span class=\"hljs-keyword\">if</span> (n.<span class=\"hljs-keyword\">parent</span>.isRed == BLACK &amp;&amp; sibL == BLACK &amp;&amp; sibR == BLACK){\r\n            colorRed(sib);\r\n            repair(n.<span class=\"hljs-keyword\">parent</span>);\r\n        }<span class=\"hljs-keyword\">else</span>{\r\n            case4(n);\r\n        }\r\n    }\r\n\r\n    <span class=\"hljs-comment\">//双子为黑 父亲为红 父兄反色</span>\r\n    <span class=\"hljs-keyword\">private</span> void case4(BSTNode&lt;K, V&gt; n) {\r\n        BSTNode&lt;K, V&gt; sib = getSib(n);\r\n        boolean sibL = sib.left == <span class=\"hljs-keyword\">null</span> ? <span class=\"hljs-keyword\">true</span> : sib.left.isRed;\r\n        boolean sibR = sib.right == <span class=\"hljs-keyword\">null</span> ? <span class=\"hljs-keyword\">true</span> : sib.right.isRed;\r\n        <span class=\"hljs-keyword\">if</span> (n.<span class=\"hljs-keyword\">parent</span>.isRed == RED &amp;&amp; sibL == BLACK &amp;&amp; sibR == BLACK){\r\n            colorRed(sib);\r\n            colorBlack(n.<span class=\"hljs-keyword\">parent</span>);\r\n        }<span class=\"hljs-keyword\">else</span>{\r\n            case5(n);\r\n        }\r\n    }\r\n\r\n    <span class=\"hljs-comment\">//兄弟向内的孩子为红，通过旋转转移为case6：向外的孩子为红</span>\r\n    <span class=\"hljs-keyword\">private</span> void case5(BSTNode&lt;K, V&gt; n) {\r\n        BSTNode&lt;K, V&gt; sib = getSib(n);\r\n        boolean sibL = sib.left == <span class=\"hljs-keyword\">null</span> ? <span class=\"hljs-keyword\">true</span> : sib.left.isRed;\r\n        boolean sibR = sib.right == <span class=\"hljs-keyword\">null</span> ? <span class=\"hljs-keyword\">true</span> : sib.right.isRed;\r\n        <span class=\"hljs-keyword\">if</span> (n.isLeftChild &amp;&amp; sibR == BLACK){\r\n            colorBlack(sib.left);\r\n            colorRed(sib);\r\n            rightRotate(sib, sib.left);\r\n        }<span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (!n.isLeftChild &amp;&amp; sibL == BLACK){\r\n            colorBlack(sib.right);\r\n            colorRed(sib);\r\n            rightRotate(sib, sib.right);\r\n        }\r\n        case6(n);\r\n    }\r\n\r\n    <span class=\"hljs-comment\">//兄弟向外的孩子为红 兄弟染为父节点的颜色 父节点染黑 父节点旋转</span>\r\n    <span class=\"hljs-keyword\">private</span> void case6(BSTNode&lt;K, V&gt; n) {\r\n        BSTNode&lt;K, V&gt; sib = getSib(n);\r\n        sib.isRed = n.<span class=\"hljs-keyword\">parent</span>.isRed;\r\n        colorBlack(n.<span class=\"hljs-keyword\">parent</span>);\r\n        <span class=\"hljs-keyword\">if</span> (n.isLeftChild){\r\n            colorBlack(sib.right);\r\n            leftRotate(n.<span class=\"hljs-keyword\">parent</span>, sib);\r\n        }<span class=\"hljs-keyword\">else</span>{\r\n            colorBlack(sib.left);\r\n            rightRotate(n.<span class=\"hljs-keyword\">parent</span>, sib);\r\n        }\r\n    }\r\n\r\n    <span class=\"hljs-keyword\">private</span> BSTNode&lt;K, V&gt; getSib(BSTNode&lt;K, V&gt; n){\r\n        <span class=\"hljs-keyword\">if</span> (n.isLeftChild){\r\n            <span class=\"hljs-keyword\">return</span> n.<span class=\"hljs-keyword\">parent</span>.right;\r\n        }<span class=\"hljs-keyword\">else</span>{\r\n            <span class=\"hljs-keyword\">return</span> n.<span class=\"hljs-keyword\">parent</span>.left;\r\n        }\r\n    }\r\n\r\n    @Override\r\n    <span class=\"hljs-keyword\">public</span> String toString() {\r\n        StringBuilder sb = <span class=\"hljs-keyword\">new</span> StringBuilder();\r\n        <span class=\"hljs-keyword\">List</span>&lt;<span class=\"hljs-keyword\">List</span>&lt;BSTNode&lt;K, V&gt;&gt;&gt; res = levelOrder();\r\n        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">List</span>&lt;BSTNode&lt;K, V&gt;&gt; <span class=\"hljs-keyword\">list</span> : res) {\r\n            <span class=\"hljs-keyword\">for</span> (BSTNode&lt;K, V&gt; bstNode : <span class=\"hljs-keyword\">list</span>) {\r\n                sb.append(bstNode + <span class=\"hljs-string\">\"\\t\"</span>);\r\n            }\r\n            sb.append(<span class=\"hljs-string\">\"\\n\"</span>);\r\n        }\r\n        <span class=\"hljs-keyword\">return</span> sb.toString();\r\n    }\r\n}\r\n</code></pre>\r\n<h3 id=\"-\">二叉树补充</h3>\r\n<ol>\r\n<li><p>叶子节点的个数</p>\r\n<pre><code class=\"lang-java\"> <span class=\"hljs-comment\">//求二叉树叶子节点的个数</span>\r\n <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">leafNumber</span>(<span class=\"hljs-params\">BSTNode&lt;K, V&gt; node</span>)</span>{\r\n     <span class=\"hljs-keyword\">if</span> (node == <span class=\"hljs-literal\">null</span>)    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;\r\n     <span class=\"hljs-keyword\">if</span> (node.left == <span class=\"hljs-literal\">null</span> &amp;&amp; node.right == <span class=\"hljs-literal\">null</span>)    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">1</span>;\r\n\r\n     <span class=\"hljs-keyword\">return</span> leafNumber(node.left) + leafNumber(node.right);\r\n }\r\n</code></pre>\r\n</li>\r\n<li><p>第k层的节点数</p>\r\n<ul>\r\n<li><p>层序遍历，给每层相应编号，第k层编号范围：[2(k-1)~2(k)-1]</p>\r\n<pre><code class=\"lang-java\"><span class=\"hljs-comment\">//二叉树第k层节点数目</span>\r\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">levelKNum</span>(<span class=\"hljs-params\">BSTNode&lt;K, V&gt; root, <span class=\"hljs-keyword\">int</span> k</span>)</span>{\r\n  <span class=\"hljs-comment\">//得到层序遍历下第k层的编号范围</span>\r\n  <span class=\"hljs-keyword\">int</span> min = (<span class=\"hljs-keyword\">int</span>) Math.pow(<span class=\"hljs-number\">2</span>, k - <span class=\"hljs-number\">1</span>);\r\n  <span class=\"hljs-keyword\">int</span> max = (<span class=\"hljs-keyword\">int</span>) Math.pow(<span class=\"hljs-number\">2</span>, k) - <span class=\"hljs-number\">1</span>;\r\n\r\n  <span class=\"hljs-comment\">//初始化队列辅助宽搜</span>\r\n  Queue&lt;BSTNode&lt;K, V&gt;&gt; qu = <span class=\"hljs-keyword\">new</span> LinkedList&lt;&gt;();\r\n  root.num = <span class=\"hljs-number\">1</span>;\r\n  qu.<span class=\"hljs-keyword\">add</span>(root);\r\n  <span class=\"hljs-keyword\">int</span> count = <span class=\"hljs-number\">0</span>;\r\n  <span class=\"hljs-keyword\">while</span> (!qu.isEmpty()){\r\n      BSTNode&lt;K, V&gt; t = qu.poll();\r\n      <span class=\"hljs-keyword\">if</span> (t.left != <span class=\"hljs-literal\">null</span>){\r\n          t.left.num = t.num * <span class=\"hljs-number\">2</span>;\r\n          qu.<span class=\"hljs-keyword\">add</span>(t.left);\r\n      }\r\n      <span class=\"hljs-keyword\">if</span> (t.right != <span class=\"hljs-literal\">null</span>){\r\n          t.right.num = t.num * <span class=\"hljs-number\">2</span> + <span class=\"hljs-number\">1</span>;\r\n          qu.<span class=\"hljs-keyword\">add</span>(t.right);\r\n      }\r\n      <span class=\"hljs-comment\">//判断节点编号是否在k层编号范围内</span>\r\n      <span class=\"hljs-keyword\">if</span> (t.num &gt;= min &amp;&amp; t.num &lt;= max){\r\n          count++;\r\n      }\r\n      <span class=\"hljs-keyword\">if</span> (t.num &gt; max){\r\n          <span class=\"hljs-keyword\">break</span>;\r\n      }\r\n  }\r\n\r\n  <span class=\"hljs-keyword\">return</span> count;\r\n}\r\n</code></pre>\r\n</li>\r\n</ul>\r\n</li>\r\n<li><p>是否完全二叉树</p>\r\n<pre><code class=\"lang-java\"> <span class=\"hljs-comment\">//判断是否为完全二叉树</span>\r\n <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> boolean <span class=\"hljs-title\">isCBT</span><span class=\"hljs-params\">()</span></span>{\r\n     <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">1</span>; i &lt;= getHeight(); i++){\r\n         <span class=\"hljs-comment\">//完全二叉树每层节点数目</span>\r\n         <span class=\"hljs-keyword\">int</span> num = (<span class=\"hljs-keyword\">int</span>) Math.<span class=\"hljs-built_in\">pow</span>(<span class=\"hljs-number\">2</span>, i - <span class=\"hljs-number\">1</span>);\r\n         <span class=\"hljs-comment\">//和实际节点数目比较</span>\r\n         <span class=\"hljs-keyword\">if</span> (num != levelKNum(root, i)){\r\n             <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span>;\r\n         }\r\n     }\r\n\r\n     <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span>;\r\n }\r\n</code></pre>\r\n</li>\r\n<li><p>两棵二叉树是否相同，是否互为镜像</p>\r\n<pre><code class=\"lang-java\"> <span class=\"hljs-comment\">//两棵二叉树是否完全相同</span>\r\n <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">boolean</span> <span class=\"hljs-title\">equal</span><span class=\"hljs-params\">(BSTNode&lt;K, V&gt; me, BSTNode&lt;K, V&gt; other)</span></span>{\r\n     <span class=\"hljs-keyword\">if</span> (me == <span class=\"hljs-keyword\">null</span> &amp;&amp; other == <span class=\"hljs-keyword\">null</span>)    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">true</span>;\r\n     <span class=\"hljs-keyword\">if</span> (me == <span class=\"hljs-keyword\">null</span> || other == <span class=\"hljs-keyword\">null</span>)    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">false</span>;\r\n\r\n     <span class=\"hljs-keyword\">return</span> me.key == other.key &amp;&amp; equal(me.left, other.left) &amp;&amp; equal(me.right, other.right);\r\n }\r\n</code></pre>\r\n<pre><code class=\"lang-java\"> <span class=\"hljs-comment\">//两棵二叉树是否互为镜像</span>\r\n <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">boolean</span> <span class=\"hljs-title\">image</span><span class=\"hljs-params\">(BSTNode&lt;K, V&gt; me, BSTNode&lt;K, V&gt; other)</span></span>{\r\n     <span class=\"hljs-keyword\">if</span> (me == <span class=\"hljs-keyword\">null</span> &amp;&amp; other == <span class=\"hljs-keyword\">null</span>)    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">true</span>;\r\n     <span class=\"hljs-keyword\">if</span> (me == <span class=\"hljs-keyword\">null</span> || other == <span class=\"hljs-keyword\">null</span>)    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">false</span>;\r\n\r\n     <span class=\"hljs-keyword\">return</span> me.key == other.key &amp;&amp; equal(me.left, other.right) &amp;&amp; equal(me.right, other.left);\r\n }\r\n</code></pre>\r\n</li>\r\n<li><p>翻转二叉树</p>\r\n<pre><code class=\"lang-java\"> <span class=\"hljs-comment\">//翻转二叉树</span>\r\n <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">turn</span>(<span class=\"hljs-params\">BSTNode&lt;K, V&gt; node</span>)</span>{\r\n     <span class=\"hljs-keyword\">if</span> (node == <span class=\"hljs-literal\">null</span>)    <span class=\"hljs-keyword\">return</span>;\r\n\r\n     turn(node.left);\r\n     turn(node.right);\r\n     BSTNode&lt;K, V&gt; t = node.left;\r\n     node.left = node.right;\r\n     node.right = t;\r\n }\r\n</code></pre>\r\n</li>\r\n<li>前序遍历</li>\r\n<li>后序遍历</li>\r\n<li><p>BST区间搜索</p>\r\n<pre><code class=\"lang-java\"> <span class=\"hljs-comment\">//bst区间搜索</span>\r\n <span class=\"hljs-keyword\">List</span>&lt;BSTNode&lt;K, V&gt;&gt; <span class=\"hljs-keyword\">list</span> = <span class=\"hljs-keyword\">new</span> ArrayList&lt;&gt;();\r\n <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">List</span>&lt;BSTNode&lt;K, V&gt;&gt; search(BSTNode&lt;K, V&gt; node, int min, int max){\r\n     <span class=\"hljs-keyword\">if</span> (node == <span class=\"hljs-keyword\">null</span>){\r\n         <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">null</span>;\r\n     }\r\n\r\n     <span class=\"hljs-keyword\">if</span> (((Comparable)node.key).compareTo(min) &gt;= <span class=\"hljs-number\">0</span> &amp;&amp; ((Comparable)node.key).compareTo(max) &lt;= <span class=\"hljs-number\">0</span>){\r\n         <span class=\"hljs-keyword\">list</span>.add(node);\r\n     }\r\n     <span class=\"hljs-comment\">//如果查找值还在范围内 就继续向下查找</span>\r\n     <span class=\"hljs-keyword\">if</span> (((Comparable)node.key).compareTo(min) &gt; <span class=\"hljs-number\">0</span>){\r\n         search(node.left, min, max);\r\n     }\r\n     <span class=\"hljs-keyword\">if</span> (((Comparable)node.key).compareTo(max) &lt; <span class=\"hljs-number\">0</span>){\r\n         search(node.right, min, max);\r\n     }\r\n     <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">list</span>;\r\n }\r\n</code></pre>\r\n</li>\r\n</ol>\r\n<h3 id=\"-\">前缀树</h3>\r\n<ul>\r\n<li>Trie;又称单词查找树;是一-种树形结构;用于保存大量的字符串。它的优点是:利用字符串的公共前缀来节约存储空间</li>\r\n<li>Trie 树主要是利用词的公共前缀缩小查词范围、通过状态间的映射关系避免了字符的遍历,从而达到高效检索的目的。</li>\r\n</ul>\r\n<h4 id=\"-\">节点定义</h4>\r\n<pre><code class=\"lang-java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">TrieNode</span> </span>{\r\n    <span class=\"hljs-comment\">//节点次序</span>\r\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">int</span> level;\r\n    <span class=\"hljs-keyword\">public</span> TrieNode[] children = <span class=\"hljs-keyword\">new</span> TrieNode[<span class=\"hljs-number\">26</span>];\r\n    <span class=\"hljs-keyword\">public</span> TrieNode parent;\r\n    <span class=\"hljs-comment\">//是否为单词末尾</span>\r\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">boolean</span> isLast;\r\n    <span class=\"hljs-comment\">//出现频率</span>\r\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">int</span> fre = <span class=\"hljs-number\">1</span>;\r\n}\r\n</code></pre>\r\n<h4 id=\"-\">实现</h4>\r\n<pre><code class=\"lang-java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Trie</span> {\r\n    TrieNode root;\r\n\r\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-title\">Trie</span>(<span class=\"hljs-params\"></span>)</span>{\r\n        root = <span class=\"hljs-keyword\">new</span> TrieNode();\r\n    }\r\n    <span class=\"hljs-comment\">//插入单词</span>\r\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">insert</span>(<span class=\"hljs-params\">String str</span>)</span>{\r\n        <span class=\"hljs-keyword\">char</span>[] chars = str.toCharArray();\r\n        TrieNode p = root;\r\n        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; chars.length; i++) {\r\n            TrieNode t = p.children[chars[i] - <span class=\"hljs-string\">\'a\'</span>];\r\n            <span class=\"hljs-keyword\">if</span> (t == <span class=\"hljs-literal\">null</span>){\r\n                t = <span class=\"hljs-keyword\">new</span> TrieNode();\r\n                t.level = chars[i] - <span class=\"hljs-string\">\'a\'</span>;\r\n                t.parent = p;\r\n                p.children[chars[i] - <span class=\"hljs-string\">\'a\'</span>] = t;\r\n            }<span class=\"hljs-keyword\">else</span>{\r\n                t.fre++;\r\n            }\r\n                p = t;\r\n        }\r\n\r\n        p.isLast = <span class=\"hljs-literal\">true</span>;\r\n    }\r\n    <span class=\"hljs-comment\">//查找前缀为prefix的单词</span>\r\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">search</span>(<span class=\"hljs-params\">String prefix</span>)</span>{\r\n        <span class=\"hljs-keyword\">char</span>[] chars = prefix.toCharArray();\r\n        TrieNode p = root;\r\n        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; chars.length; i++) {\r\n            TrieNode t = p.children[chars[i] - <span class=\"hljs-string\">\'a\'</span>];\r\n            <span class=\"hljs-keyword\">if</span> (t == <span class=\"hljs-literal\">null</span>){\r\n                <span class=\"hljs-keyword\">return</span>;\r\n            }<span class=\"hljs-keyword\">else</span>{\r\n                p = t;\r\n            }\r\n        }\r\n\r\n        print(<span class=\"hljs-string\">\"\"</span>, p);\r\n    }\r\n    <span class=\"hljs-comment\">//打印以p为起点的所有单词</span>\r\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">print</span>(<span class=\"hljs-params\">String prefix, TrieNode p</span>) </span>{\r\n        <span class=\"hljs-keyword\">if</span> (p.isLast &amp;&amp; prefix.length() &gt; <span class=\"hljs-number\">0</span>){\r\n            System.<span class=\"hljs-keyword\">out</span>.println(prefix + <span class=\"hljs-string\">\" \"</span> + p.fre);\r\n        }\r\n        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; <span class=\"hljs-number\">26</span>; i++) {\r\n            <span class=\"hljs-keyword\">if</span> (p.children[i] != <span class=\"hljs-literal\">null</span>){\r\n                print(prefix + (<span class=\"hljs-keyword\">char</span>)(<span class=\"hljs-string\">\'a\'</span> + p.children[i].level), p.children[i]);\r\n            }\r\n        }\r\n    }\r\n    <span class=\"hljs-comment\">//打印整个前缀树中所有单词</span>\r\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">printAll</span>(<span class=\"hljs-params\"></span>)</span>{\r\n        print(<span class=\"hljs-string\">\"\"</span>, root);\r\n    }\r\n}\r\n</code></pre>\r\n<h3 id=\"-\">题解</h3>\r\n<ol>\r\n<li>给定一棵二叉树，求其最小深度。最小深度是节点数沿最短路径从根节点到最近的叶节点。<a href=\"https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/\">LeetCode</a></li>\r\n</ol>\r\n<pre><code class=\"lang-java\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">minDepth</span>(<span class=\"hljs-params\">TreeNode root</span>) </span>{\r\n    <span class=\"hljs-keyword\">if</span> (root == <span class=\"hljs-literal\">null</span>)   <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;\r\n    <span class=\"hljs-keyword\">int</span> left = minDepth(root.left);\r\n    <span class=\"hljs-keyword\">int</span> right = minDepth(root.right);\r\n    <span class=\"hljs-keyword\">if</span> (root.left == <span class=\"hljs-literal\">null</span> || root.right == <span class=\"hljs-literal\">null</span>){\r\n        <span class=\"hljs-keyword\">return</span> (<span class=\"hljs-keyword\">int</span>)Math.max(left, right) + <span class=\"hljs-number\">1</span>;\r\n    }\r\n    <span class=\"hljs-keyword\">return</span> (<span class=\"hljs-keyword\">int</span>)Math.min(left, right) + <span class=\"hljs-number\">1</span>;\r\n}\r\n</code></pre>\r\n<ol>\r\n<li><a href=\"https://leetcode-cn.com/problems/sum-root-to-leaf-numbers/\">求根到叶子节点数字之和</a></li>\r\n</ol>\r\n<pre><code class=\"lang-java\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">sumNumbers</span>(<span class=\"hljs-params\">TreeNode root</span>) </span>{\r\n    <span class=\"hljs-keyword\">if</span> (root == <span class=\"hljs-literal\">null</span>){\r\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;\r\n    }\r\n    f(root, <span class=\"hljs-string\">\"\"</span>);\r\n    <span class=\"hljs-keyword\">int</span> sum = <span class=\"hljs-number\">0</span>;\r\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; list.size(); i++){\r\n        <span class=\"hljs-keyword\">int</span> t = Integer.parseInt(list.<span class=\"hljs-keyword\">get</span>(i));\r\n        sum += t;\r\n    }\r\n\r\n    <span class=\"hljs-keyword\">return</span> sum;\r\n}\r\nList&lt;String&gt; list = <span class=\"hljs-keyword\">new</span> ArrayList&lt;&gt;();\r\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">f</span>(<span class=\"hljs-params\">TreeNode root, String pre</span>)</span>{\r\n    pre = pre + root.val;\r\n    <span class=\"hljs-keyword\">if</span> (root.left == <span class=\"hljs-literal\">null</span> &amp;&amp; root.right == <span class=\"hljs-literal\">null</span>){\r\n        list.<span class=\"hljs-keyword\">add</span>(pre);\r\n    }\r\n    <span class=\"hljs-keyword\">if</span> (root.left != <span class=\"hljs-literal\">null</span>){\r\n        f(root.left, pre);\r\n    }\r\n    <span class=\"hljs-keyword\">if</span> (root.right != <span class=\"hljs-literal\">null</span>){\r\n        f(root.right, pre);\r\n    }\r\n}\r\n</code></pre>\r\n<ol>\r\n<li><a href=\"https://leetcode-cn.com/problems/balanced-binary-tree/\">平衡二叉树</a></li>\r\n</ol>\r\n<pre><code class=\"lang-java\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">boolean</span> <span class=\"hljs-title\">isBalanced</span><span class=\"hljs-params\">(TreeNode root)</span> </span>{\r\n    <span class=\"hljs-keyword\">if</span> (root == <span class=\"hljs-keyword\">null</span>) <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">true</span>;\r\n    <span class=\"hljs-keyword\">int</span> x = Math.abs(getHight(root.left) - getHight(root.right));\r\n    <span class=\"hljs-keyword\">return</span> x &lt;= <span class=\"hljs-number\">1</span> &amp;&amp; isBalanced(root.left) &amp;&amp; isBalanced(root.right);\r\n}\r\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">getHight</span><span class=\"hljs-params\">(TreeNode p)</span> </span>{\r\n    <span class=\"hljs-keyword\">if</span> (p == <span class=\"hljs-keyword\">null</span>){\r\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;\r\n    }\r\n    <span class=\"hljs-keyword\">int</span> max = Math.max(getHight(p.left), getHight(p.right));\r\n    <span class=\"hljs-keyword\">return</span> max + <span class=\"hljs-number\">1</span>;\r\n}\r\n</code></pre>\r\n<ol>\r\n<li><a href=\"https://leetcode-cn.com/problems/minimum-height-tree-lcci/\">最小高度树</a></li>\r\n</ol>\r\n<pre><code class=\"lang-java\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> TreeNode <span class=\"hljs-title\">sortedArrayToBST</span>(<span class=\"hljs-params\"><span class=\"hljs-keyword\">int</span>[] nums</span>) </span>{\r\n    <span class=\"hljs-keyword\">return</span> f(nums, <span class=\"hljs-number\">0</span>, nums.length - <span class=\"hljs-number\">1</span>);\r\n}\r\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> TreeNode <span class=\"hljs-title\">f</span>(<span class=\"hljs-params\"><span class=\"hljs-keyword\">int</span>[] nums, <span class=\"hljs-keyword\">int</span> i, <span class=\"hljs-keyword\">int</span> j</span>)</span>{\r\n    <span class=\"hljs-keyword\">if</span> (i &gt; j){\r\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">null</span>;\r\n    }\r\n    <span class=\"hljs-keyword\">int</span> mid = (i + j) / <span class=\"hljs-number\">2</span>;\r\n    TreeNode left = f(nums, i, mid - <span class=\"hljs-number\">1</span>);\r\n    TreeNode right = f(nums, mid + <span class=\"hljs-number\">1</span>, j);\r\n    TreeNode node = <span class=\"hljs-keyword\">new</span> TreeNode(nums[mid]);\r\n    node.left = left;\r\n    node.right = right;\r\n    <span class=\"hljs-keyword\">return</span> node;\r\n}\r\n</code></pre>\r\n<ol>\r\n<li><a href=\"https://leetcode-cn.com/problems/list-of-depth-lcci/\">特定深度节点链表</a></li>\r\n</ol>\r\n<pre><code class=\"lang-java\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> ListNode[] <span class=\"hljs-title\">listOfDepth</span>(<span class=\"hljs-params\">TreeNode tree</span>) </span>{\r\n    List res = <span class=\"hljs-keyword\">new</span> ArrayList();\r\n    ListNode node = <span class=\"hljs-keyword\">new</span> ListNode(<span class=\"hljs-number\">-1</span>);\r\n    Queue&lt;TreeNode&gt; qu = <span class=\"hljs-keyword\">new</span> LinkedList&lt;TreeNode&gt;();\r\n    qu.<span class=\"hljs-keyword\">add</span>(tree);\r\n    TreeNode p = tree;\r\n    TreeNode last = tree;\r\n    boolean f = <span class=\"hljs-literal\">true</span>;\r\n    <span class=\"hljs-keyword\">while</span> (!qu.isEmpty()){\r\n        TreeNode t = qu.poll();\r\n        node.next = <span class=\"hljs-keyword\">new</span> ListNode(t.val);\r\n        <span class=\"hljs-keyword\">if</span> (f){\r\n            res.<span class=\"hljs-keyword\">add</span>(node);\r\n            f = !f;\r\n        }\r\n        node = node.next;\r\n\r\n        <span class=\"hljs-keyword\">if</span> (t.left != <span class=\"hljs-literal\">null</span>){\r\n            qu.<span class=\"hljs-keyword\">add</span>(t.left);\r\n            p = t.left;\r\n        }\r\n        <span class=\"hljs-keyword\">if</span> (t.right != <span class=\"hljs-literal\">null</span>){\r\n            qu.<span class=\"hljs-keyword\">add</span>(t.right);\r\n            p = t.right;\r\n        }\r\n        <span class=\"hljs-keyword\">if</span> (t == last){\r\n            f = <span class=\"hljs-literal\">true</span>;\r\n            last = p;\r\n            node = <span class=\"hljs-keyword\">new</span> ListNode(<span class=\"hljs-number\">-1</span>);\r\n        }\r\n    }\r\n\r\n    ListNode[] ln = <span class=\"hljs-keyword\">new</span> ListNode[res.size()];\r\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; ln.length; i++) {\r\n        ln[i] = ((ListNode) res.<span class=\"hljs-keyword\">get</span>(i)).next;\r\n    }\r\n\r\n    <span class=\"hljs-keyword\">return</span> ln;\r\n}\r\n</code></pre>\r\n<ol>\r\n<li><p><a href=\"https://leetcode-cn.com/problems/legal-binary-search-tree-lcci/\">合法二叉搜索树</a></p>\r\n</li>\r\n<li><p>中序遍历bst 判断遍历结果是否有序</p>\r\n</li>\r\n</ol>\r\n<pre><code class=\"lang-java\"><span class=\"hljs-keyword\">public</span> boolean isValidBST(TreeNode root) {\r\n    <span class=\"hljs-keyword\">if</span> (root == <span class=\"hljs-keyword\">null</span> )  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">true</span>;\r\n    inOrder(root);\r\n    <span class=\"hljs-keyword\">for</span> (int i = <span class=\"hljs-number\">0</span>; i &lt; <span class=\"hljs-keyword\">list</span>.size() - <span class=\"hljs-number\">1</span>; i++) {\r\n        <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">list</span>.get(i) &gt; <span class=\"hljs-keyword\">list</span>.get(i + <span class=\"hljs-number\">1</span>)){\r\n            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">false</span>;\r\n        }\r\n    }\r\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">true</span>;\r\n}\r\n<span class=\"hljs-keyword\">List</span>&lt;Integer&gt; <span class=\"hljs-keyword\">list</span> = <span class=\"hljs-keyword\">new</span> ArrayList&lt;Integer&gt;();\r\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">List</span>&lt;Integer&gt; inOrder(TreeNode root){\r\n    <span class=\"hljs-keyword\">if</span> (root == <span class=\"hljs-keyword\">null</span>) <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">null</span>;\r\n    inOrder(root.left);\r\n    <span class=\"hljs-keyword\">list</span>.add(root.val);\r\n    inOrder(root.right);\r\n\r\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">list</span>;\r\n}\r\n</code></pre>\r\n<ul>\r\n<li><p>递归遍历 记录前驱节点的值 比较是否有序</p>\r\n</li>\r\n<li><p><a href=\"https://leetcode-cn.com/problems/successor-lcci/\">后继者</a></p>\r\n</li>\r\n<li><p>有parent指针的情况下</p>\r\n</li>\r\n</ul>\r\n<pre><code class=\"lang-java\"><span class=\"hljs-keyword\">public</span> K successor(K key) {\r\n    BSTNode&lt;K, V&gt; p = lookupNode(key);\r\n    <span class=\"hljs-keyword\">if</span> (p == <span class=\"hljs-keyword\">null</span>)    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">null</span>;\r\n    <span class=\"hljs-keyword\">if</span> (p.right != <span class=\"hljs-keyword\">null</span>){\r\n        <span class=\"hljs-comment\">//右子树中最小的元素</span>\r\n        <span class=\"hljs-keyword\">return</span> minNode(p.right).key;\r\n    }\r\n    <span class=\"hljs-comment\">//向上找第一个是左孩子的节点的父节点</span>\r\n    <span class=\"hljs-keyword\">while</span> (p != <span class=\"hljs-keyword\">null</span> &amp;&amp; !p.isLeftChild){\r\n        p = p.<span class=\"hljs-keyword\">parent</span>;\r\n    }\r\n    <span class=\"hljs-keyword\">return</span> p == <span class=\"hljs-keyword\">null</span> ? <span class=\"hljs-keyword\">null</span>:p.<span class=\"hljs-keyword\">parent</span>.key;\r\n}\r\n</code></pre>\r\n<ul>\r\n<li>无parent指针的情况下</li>\r\n</ul>\r\n<pre><code class=\"lang-java\"><span class=\"hljs-comment\">//迭代方式找到中序遍历后继节点</span>\r\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> K <span class=\"hljs-title\">inorderSuccessor</span><span class=\"hljs-params\">(BSTNode&lt;K, V&gt; root, BSTNode&lt;K, V&gt; p)</span> </span>{\r\n    BSTNode&lt;K, V&gt; n = root;\r\n    <span class=\"hljs-keyword\">if</span> (n == <span class=\"hljs-keyword\">null</span>)    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">null</span>;\r\n    Stack&lt;BSTNode&lt;K, V&gt;&gt; s = <span class=\"hljs-keyword\">new</span> Stack&lt;&gt;();\r\n    <span class=\"hljs-keyword\">boolean</span> f = <span class=\"hljs-keyword\">false</span>;\r\n    <span class=\"hljs-keyword\">while</span> (n != <span class=\"hljs-keyword\">null</span> || !s.isEmpty()){\r\n        <span class=\"hljs-keyword\">while</span> (n != <span class=\"hljs-keyword\">null</span>){\r\n            s.push(n);\r\n            n = n.left;\r\n        }\r\n        BSTNode&lt;K, V&gt; t = s.pop();\r\n        <span class=\"hljs-keyword\">if</span> (f){\r\n            <span class=\"hljs-keyword\">return</span> t.key;\r\n        }\r\n        <span class=\"hljs-keyword\">if</span> (t.key == p.key){\r\n            f = <span class=\"hljs-keyword\">true</span>;\r\n        }\r\n        <span class=\"hljs-keyword\">if</span> (t != <span class=\"hljs-keyword\">null</span>){\r\n            n = t.right;\r\n        }\r\n    }\r\n\r\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">null</span>;\r\n}\r\n</code></pre>\r\n<ul>\r\n<li>递归方式求解</li>\r\n</ul>\r\n<pre><code class=\"lang-java\"><span class=\"hljs-comment\">//中序遍历递归方式求后继 记录前驱节点的值</span>\r\n<span class=\"hljs-keyword\">int</span> pre = Integer.MIN_VALUE;\r\nK res;\r\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> K <span class=\"hljs-title\">successor3</span>(<span class=\"hljs-params\">BSTNode&lt;K, V&gt; root, BSTNode&lt;K, V&gt; p</span>)</span>{\r\n    succ(root, p.key);\r\n    <span class=\"hljs-keyword\">return</span> res;\r\n}\r\n\r\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">succ</span>(<span class=\"hljs-params\">BSTNode&lt;K, V&gt; root, K key</span>)</span>{\r\n    <span class=\"hljs-keyword\">if</span> (root == <span class=\"hljs-literal\">null</span>)    <span class=\"hljs-keyword\">return</span>;\r\n    succ(root.left, key);\r\n    <span class=\"hljs-keyword\">if</span> (pre == (<span class=\"hljs-keyword\">int</span>)key){\r\n        res = root.key;\r\n        <span class=\"hljs-keyword\">return</span>;\r\n    }\r\n    pre = (<span class=\"hljs-keyword\">int</span>) root.key;\r\n    succ(root.right, key);\r\n}\r\n</code></pre>\r\n<ol>\r\n<li><p><a href=\"https://leetcode-cn.com/problems/first-common-ancestor-lcci/\">首个共同祖先</a></p>\r\n</li>\r\n<li><p>解法1</p>\r\n</li>\r\n</ol>\r\n<pre><code class=\"lang-java\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> TreeNode <span class=\"hljs-title\">lowestCommonAncestor</span><span class=\"hljs-params\">(TreeNode root, TreeNode p, TreeNode q)</span> </span>{\r\n    <span class=\"hljs-keyword\">if</span> (root == <span class=\"hljs-keyword\">null</span> || p == <span class=\"hljs-keyword\">null</span> || q == <span class=\"hljs-keyword\">null</span>){\r\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">null</span>;\r\n    }\r\n    <span class=\"hljs-comment\">//如果root和p或q相同则直接返回</span>\r\n    <span class=\"hljs-keyword\">if</span> (root.val == p.val || root.val == q.val){\r\n        <span class=\"hljs-keyword\">return</span> root;\r\n    }\r\n    <span class=\"hljs-comment\">//判断p和q是否在该节点的左和右</span>\r\n    <span class=\"hljs-keyword\">boolean</span> left = f(root.left, p.val);\r\n    <span class=\"hljs-keyword\">boolean</span> right = f(root.right, q.val);\r\n    <span class=\"hljs-comment\">//如果分别在左右或分别不在左右 则证明p和q分属该节点两侧</span>\r\n    <span class=\"hljs-comment\">//只要分属某个节点两侧则该节点一定为首个共同祖先</span>\r\n    <span class=\"hljs-keyword\">if</span> (left == right){\r\n        <span class=\"hljs-keyword\">return</span> root;\r\n    }\r\n    <span class=\"hljs-comment\">//如果都存在于左侧则递归去左侧找</span>\r\n    <span class=\"hljs-keyword\">if</span> (left){\r\n        <span class=\"hljs-keyword\">return</span> lowestCommonAncestor(root.left, p, q);\r\n    }\r\n    <span class=\"hljs-comment\">//如果都存在于右侧则递归去右侧找</span>\r\n    <span class=\"hljs-keyword\">if</span> (right){\r\n        <span class=\"hljs-keyword\">return</span> lowestCommonAncestor(root.right, p, q);\r\n    }\r\n\r\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">null</span>;\r\n}\r\n\r\n<span class=\"hljs-comment\">//判断n是否在root子树中存在</span>\r\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">boolean</span> <span class=\"hljs-title\">f</span><span class=\"hljs-params\">(TreeNode root, <span class=\"hljs-keyword\">int</span> n)</span></span>{\r\n    <span class=\"hljs-keyword\">if</span> (root == <span class=\"hljs-keyword\">null</span>)    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">false</span>;\r\n    <span class=\"hljs-keyword\">if</span> (root.val == n){\r\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">true</span>;\r\n    }\r\n\r\n    <span class=\"hljs-keyword\">return</span> f(root.left, n) || f(root.right, n);\r\n}\r\n</code></pre>\r\n<ul>\r\n<li>解法2</li>\r\n</ul>\r\n<pre><code class=\"lang-java\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> TreeNode <span class=\"hljs-title\">lowestCommonAncestor</span>(<span class=\"hljs-params\">TreeNode root, TreeNode p, TreeNode q</span>) </span>{\r\n    <span class=\"hljs-keyword\">if</span> (root == <span class=\"hljs-literal\">null</span>)   <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">null</span>;\r\n    <span class=\"hljs-keyword\">if</span> (root.val == p.val || root.val == q.val){\r\n        <span class=\"hljs-keyword\">return</span> root;\r\n    }\r\n    <span class=\"hljs-comment\">//x 为lca || p || q || null 代表找到了lca或者p在这一侧或者q在这一侧或者什么都不是</span>\r\n    TreeNode x = lowestCommonAncestor(root.left, p, q);\r\n    <span class=\"hljs-keyword\">if</span> (x != <span class=\"hljs-literal\">null</span> &amp;&amp; x.val != p.val &amp;&amp; x.val != q.val){\r\n        <span class=\"hljs-keyword\">return</span> x;\r\n    }\r\n    TreeNode y = lowestCommonAncestor(root.right, p, q);\r\n    <span class=\"hljs-keyword\">if</span> (y != <span class=\"hljs-literal\">null</span> &amp;&amp; y.val != p.val &amp;&amp; y.val != q.val){\r\n        <span class=\"hljs-keyword\">return</span> y;\r\n    }\r\n\r\n    <span class=\"hljs-keyword\">if</span> (x != <span class=\"hljs-literal\">null</span> &amp;&amp; y != <span class=\"hljs-literal\">null</span>){\r\n        <span class=\"hljs-keyword\">return</span> root;\r\n    }<span class=\"hljs-function\"><span class=\"hljs-keyword\">else</span> <span class=\"hljs-title\">if</span> (<span class=\"hljs-params\">root.val == p.val || root.val == q.val</span>)</span>{\r\n        <span class=\"hljs-keyword\">return</span> root;\r\n    }<span class=\"hljs-keyword\">else</span>{\r\n        <span class=\"hljs-keyword\">return</span> x != <span class=\"hljs-literal\">null</span> ? x : y;\r\n    }\r\n}\r\n</code></pre>\r\n<ol>\r\n<li><a href=\"https://leetcode-cn.com/problems/check-subtree-lcci/\">检查子树</a></li>\r\n</ol>\r\n<pre><code class=\"lang-java\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">boolean</span> <span class=\"hljs-title\">checkSubTree</span><span class=\"hljs-params\">(TreeNode t1, TreeNode t2)</span> </span>{\r\n    <span class=\"hljs-keyword\">if</span> (t1 == <span class=\"hljs-keyword\">null</span> || t2 == <span class=\"hljs-keyword\">null</span>)    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">false</span>;\r\n    <span class=\"hljs-comment\">//找到t1子树中和t2根节点相同的节点</span>\r\n    TreeNode node = s(t1, t2);\r\n    <span class=\"hljs-comment\">//如果找不到t2一定不是子树</span>\r\n    <span class=\"hljs-keyword\">if</span> (node == <span class=\"hljs-keyword\">null</span>)    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">false</span>;\r\n\r\n    <span class=\"hljs-comment\">//判断两个子树是否完全相同</span>\r\n    <span class=\"hljs-keyword\">if</span> (f(node, t2)){\r\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">true</span>;\r\n    }<span class=\"hljs-keyword\">else</span>{\r\n        <span class=\"hljs-comment\">//如果不相同则递归检查左侧和右侧</span>\r\n        <span class=\"hljs-keyword\">return</span> checkSubTree(t1.left, t2) || checkSubTree(t1.right, t2);\r\n    }\r\n}\r\n<span class=\"hljs-comment\">//判断两个子树是否相同</span>\r\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">boolean</span> <span class=\"hljs-title\">f</span><span class=\"hljs-params\">(TreeNode t1, TreeNode t2)</span></span>{\r\n    <span class=\"hljs-keyword\">if</span> (t1 == <span class=\"hljs-keyword\">null</span> &amp;&amp; t2 == <span class=\"hljs-keyword\">null</span>)    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">true</span>;\r\n    <span class=\"hljs-keyword\">if</span> (t1 == <span class=\"hljs-keyword\">null</span> || t2 == <span class=\"hljs-keyword\">null</span>)    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">false</span>;\r\n\r\n    <span class=\"hljs-keyword\">if</span> (t1.val != t2.val)    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">false</span>;\r\n\r\n    <span class=\"hljs-keyword\">return</span> f(t1.left, t2.left) &amp;&amp; f(t1.right, t2.right);\r\n}\r\n\r\n<span class=\"hljs-comment\">//在t1子树中找到和n相同的节点</span>\r\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> TreeNode <span class=\"hljs-title\">s</span><span class=\"hljs-params\">(TreeNode t1, TreeNode n)</span></span>{\r\n    <span class=\"hljs-keyword\">if</span> (t1 == <span class=\"hljs-keyword\">null</span>)    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">null</span>;\r\n    <span class=\"hljs-keyword\">if</span> (t1.val == n.val){\r\n        <span class=\"hljs-keyword\">return</span> t1;\r\n    }\r\n    TreeNode node = s(t1.left, n);\r\n    <span class=\"hljs-keyword\">if</span> (node != <span class=\"hljs-keyword\">null</span>){\r\n        <span class=\"hljs-keyword\">return</span> node;\r\n    }<span class=\"hljs-keyword\">else</span>{\r\n        <span class=\"hljs-keyword\">return</span> s(t1.right, n);\r\n    }\r\n}\r\n</code></pre>\r\n<ol>\r\n<li><p><a href=\"https://leetcode-cn.com/problems/paths-with-sum-lcci/\">求和路径</a></p>\r\n</li>\r\n<li><p>固定路径为从根节点到叶子节点</p>\r\n</li>\r\n</ol>\r\n<pre><code class=\"lang-java\"><span class=\"hljs-comment\">//结果集</span>\r\n<span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">List</span>&lt;<span class=\"hljs-keyword\">List</span>&lt;Integer&gt;&gt; <span class=\"hljs-keyword\">list</span> = <span class=\"hljs-keyword\">new</span> ArrayList&lt;&gt;();\r\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> void f(<span class=\"hljs-keyword\">List</span>&lt;Integer&gt; cur, TreeNode n, int target){\r\n    <span class=\"hljs-keyword\">if</span> (n == <span class=\"hljs-keyword\">null</span>)    <span class=\"hljs-keyword\">return</span>;\r\n    <span class=\"hljs-comment\">//l中记录从根节点到叶子的路径</span>\r\n    <span class=\"hljs-keyword\">List</span>&lt;Integer&gt; l = <span class=\"hljs-keyword\">new</span> ArrayList&lt;&gt;();\r\n    l.addAll(cur);\r\n    l.add(n.val);\r\n    <span class=\"hljs-comment\">//如果该节点为叶子节点则结算</span>\r\n    <span class=\"hljs-keyword\">if</span> (n.left == <span class=\"hljs-keyword\">null</span> &amp;&amp; n.right == <span class=\"hljs-keyword\">null</span>){\r\n        <span class=\"hljs-comment\">//如果路径和正好相等</span>\r\n        <span class=\"hljs-keyword\">if</span> (target - n.val == <span class=\"hljs-number\">0</span>){\r\n            <span class=\"hljs-comment\">//加入结果集</span>\r\n            <span class=\"hljs-keyword\">list</span>.add(l);\r\n        }\r\n        <span class=\"hljs-keyword\">return</span>;\r\n    }\r\n    f(l, n.left, target - n.val);\r\n    f(l, n.right, target - n.val);\r\n}\r\n</code></pre>\r\n<ul>\r\n<li>路径不一定以根节点或叶子节点结束</li>\r\n</ul>\r\n<pre><code class=\"lang-java\"><span class=\"hljs-comment\">//结果集</span>\r\n<span class=\"hljs-keyword\">static</span> List&lt;List&lt;Integer&gt;&gt; list = <span class=\"hljs-keyword\">new</span> ArrayList&lt;&gt;();\r\n<span class=\"hljs-comment\">//计算路径和个数</span>\r\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">pathSum</span>(<span class=\"hljs-params\">TreeNode root, <span class=\"hljs-keyword\">int</span> sum</span>)</span>{\r\n    help(root, sum);\r\n    <span class=\"hljs-keyword\">return</span> list.size();\r\n}\r\n<span class=\"hljs-comment\">//从任意节点向下到任意节点的路径和</span>\r\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">help</span>(<span class=\"hljs-params\">TreeNode root, <span class=\"hljs-keyword\">int</span> sum</span>) </span>{\r\n    <span class=\"hljs-keyword\">if</span> (root == <span class=\"hljs-literal\">null</span>)    <span class=\"hljs-keyword\">return</span>;\r\n    f2(<span class=\"hljs-keyword\">new</span> ArrayList&lt;&gt;(), root, sum);\r\n    help(root.left, sum);\r\n    help(root.right, sum);\r\n}\r\n\r\n<span class=\"hljs-comment\">//从根节点到任意向下节点的路径和</span>\r\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">f2</span>(<span class=\"hljs-params\">List&lt;Integer&gt; cur, TreeNode n, <span class=\"hljs-keyword\">int</span> target</span>)</span>{\r\n    <span class=\"hljs-keyword\">if</span> (n == <span class=\"hljs-literal\">null</span>)    <span class=\"hljs-keyword\">return</span>;\r\n    <span class=\"hljs-comment\">//l中记录从根节点到叶子的路径</span>\r\n    List&lt;Integer&gt; l = <span class=\"hljs-keyword\">new</span> ArrayList&lt;&gt;();\r\n    l.addAll(cur);\r\n    l.<span class=\"hljs-keyword\">add</span>(n.val);\r\n    <span class=\"hljs-comment\">//如果该节点为叶子节点或路径和正好相等则结算</span>\r\n    <span class=\"hljs-keyword\">if</span> (target - n.val == <span class=\"hljs-number\">0</span>){\r\n        <span class=\"hljs-comment\">//加入结果集</span>\r\n        list.<span class=\"hljs-keyword\">add</span>(l);\r\n    }\r\n    <span class=\"hljs-keyword\">if</span> (n.left == <span class=\"hljs-literal\">null</span> &amp;&amp; n.right == <span class=\"hljs-literal\">null</span>){\r\n        <span class=\"hljs-keyword\">return</span>;\r\n    }\r\n    f2(l, n.left, target - n.val);\r\n    f2(l, n.right, target - n.val);\r\n}\r\n</code></pre>', '### 树的基本概念及实现\r\n\r\n#### 树的实现\r\n\r\n##### 操作定义\r\n\r\n```java\r\n/**\r\n * 树接口\r\n * @author 96047\r\n *\r\n * @param <E>\r\n */\r\npublic interface ITree<E> {\r\n	//节点数\r\n	int size();\r\n	\r\n	//获取根节点\r\n	TreeNode<E> getRoot();\r\n	\r\n	//获取n的父节点\r\n	TreeNode<E> getParent(TreeNode<E> n);\r\n	\r\n	//获取第一个儿子\r\n	TreeNode<E> getFirstChild(TreeNode<E> p);\r\n	\r\n	//获取n的下一个兄弟\r\n	TreeNode<E> getNextSibling(TreeNode<E> n);\r\n	\r\n	//子树高度\r\n	int getHight(TreeNode<E> n);\r\n	\r\n	//插入子节点\r\n	void insertChild(TreeNode<E> n, TreeNode<E> child);\r\n	\r\n	//删除第i个子节点\r\n	void deleteChild(TreeNode<E> n, int i);\r\n	\r\n	//先序遍历\r\n	List<TreeNode<E>> preOrder(TreeNode<E> n);\r\n	\r\n	//后序遍历\r\n	List<TreeNode<E>> postOrder(TreeNode<E> n);\r\n	\r\n	//层序遍历\r\n	List<List<TreeNode<E>>> levelOrder(TreeNode<E> n);\r\n	\r\n	List<List<TreeNode<E>>> levelOrder();\r\n}\r\n```\r\n\r\n##### 节点定义\r\n\r\n```java\r\npublic class TreeNode<E> {\r\n	public E data;\r\n	public TreeNode<E> parent;\r\n	public List<TreeNode<E>> children;\r\n	\r\n	public TreeNode(E data, TreeNode<E> parent){\r\n		this.data = data;\r\n		this.parent = parent;\r\n	}\r\n	\r\n	public TreeNode(E data){\r\n		this.data = data;\r\n	}\r\n	\r\n	@Override\r\n	public String toString() {\r\n		return \"data = \" + data;\r\n	}\r\n}\r\n```\r\n\r\n##### 实现\r\n\r\n```java\r\npublic class MyTree<E> implements ITree<E> {\r\n	private TreeNode<E> root;\r\n	private int size;\r\n	\r\n	public MyTree(TreeNode<E> root){\r\n		this.root = root;\r\n		size++;\r\n	}\r\n\r\n	@Override\r\n	public int size() {\r\n		return size;\r\n	}\r\n\r\n	@Override\r\n	public TreeNode<E> getRoot() {\r\n		return root;\r\n	}\r\n\r\n	@Override\r\n	public TreeNode<E> getParent(TreeNode<E> n) {\r\n		if (n == null){\r\n			return null;\r\n		}else{\r\n			return n.parent;\r\n		}\r\n	}\r\n\r\n	@Override\r\n	public TreeNode<E> getFirstChild(TreeNode<E> p) {\r\n		if (p == null || p.children == null){\r\n			return null;\r\n		}else{\r\n			return p.children.get(0);\r\n		}\r\n	}\r\n\r\n	@Override\r\n	public TreeNode<E> getNextSibling(TreeNode<E> n) {\r\n		if (n == null || n.parent == null){\r\n			return null;\r\n		}else{\r\n			int index = n.parent.children.indexOf(n);\r\n			TreeNode<E> t = n.parent.children.get(index + 1);\r\n			return t;\r\n		}\r\n	}\r\n\r\n	@Override\r\n	public int getHight(TreeNode<E> n) {\r\n		if (n.children == null){\r\n			return 0;\r\n		}\r\n		int h = 0;\r\n		for (TreeNode<E> t : n.children){\r\n			h = Math.max(h, getHight(t));\r\n		}\r\n		\r\n		return h + 1;\r\n	}\r\n\r\n	@Override\r\n	public void insertChild(TreeNode<E> n, TreeNode<E> child) {\r\n		if (n.children == null){\r\n			n.children = new ArrayList<TreeNode<E>>();\r\n		}\r\n		n.children.add(child);\r\n		child.parent = n;\r\n		size++;\r\n	}\r\n\r\n	@Override\r\n	public void deleteChild(TreeNode<E> n, int i) {\r\n		n.children.remove(i);\r\n		size--;\r\n	}\r\n\r\n	@Override\r\n	public List<TreeNode<E>> preOrder(TreeNode<E> n) {\r\n		if (n.children == null){\r\n			List<TreeNode<E>> list = new ArrayList<TreeNode<E>>();\r\n			list.add(n);\r\n			\r\n			return list;\r\n		}\r\n		List<TreeNode<E>> list = new ArrayList<TreeNode<E>>();\r\n		//遍历根\r\n		list.add(n);\r\n		//得到子层遍历结果\r\n		List<TreeNode<E>> listC = null;\r\n		for (TreeNode<E> t : n.children){\r\n			listC = preOrder(t);\r\n			list.addAll(listC);\r\n		}\r\n		\r\n		return list;\r\n	}\r\n\r\n	@Override\r\n	public List<TreeNode<E>> postOrder(TreeNode<E> n) {\r\n		if (n.children == null){\r\n			List<TreeNode<E>> list = new ArrayList<TreeNode<E>>();\r\n			list.add(n);\r\n			return list;\r\n		}\r\n		//得到子层遍历结果\r\n		List<TreeNode<E>> list = new ArrayList<TreeNode<E>>();\r\n		for (TreeNode<E> t : n.children){\r\n			list.addAll(postOrder(t));\r\n		}\r\n		//加入根\r\n		list.add(n);\r\n		\r\n		return list;\r\n	}\r\n\r\n	@Override\r\n	public List<List<TreeNode<E>>> levelOrder(TreeNode<E> n) {\r\n		List<List<TreeNode<E>>> res = new ArrayList<List<TreeNode<E>>>();\r\n		List<TreeNode<E>> list = new ArrayList<TreeNode<E>>();\r\n		//初始化队列\r\n		Queue<TreeNode<E>> queue = new LinkedList<TreeNode<E>>();\r\n		queue.add(n);\r\n		//双指针记录层级关系\r\n		TreeNode<E> p = n;	//游标指针\r\n		TreeNode<E> last = n;	//该层最后一个元素\r\n		\r\n		while (!queue.isEmpty()){\r\n			//弹出一个\r\n			TreeNode<E> t = queue.poll();\r\n			list.add(t);\r\n			\r\n			//加入n个\r\n			if (t.children != null){\r\n				for (TreeNode<E> tn : t.children){\r\n					queue.add(tn);\r\n					p = tn;	//游标指针指向新加入队列的最后一个元素\r\n				}\r\n			}\r\n			//如果弹出的元素是该层最后一个元素\r\n			if (t == last){\r\n				last = p;	//last指向下一层最后一个元素\r\n				res.add(list);	//该层遍历结果加入总结果集\r\n				list = new ArrayList<TreeNode<E>>();	//初始化新一层结果集\r\n			}\r\n		}\r\n		\r\n		return res;\r\n	}\r\n\r\n	@Override\r\n	public List<List<TreeNode<E>>> levelOrder() {\r\n		return levelOrder(root);\r\n	}\r\n\r\n}\r\n```\r\n\r\n##### 测试\r\n\r\n```java\r\npublic class TestTree {\r\n\r\n	public static void main(String[] args) {\r\n		TreeNode<Integer> root = new TreeNode<Integer>(0);\r\n		MyTree<Integer> tree = new MyTree<>(root);\r\n		\r\n		TreeNode<Integer> node1 = new TreeNode<Integer>(1);\r\n		tree.insertChild(root, node1);\r\n		TreeNode<Integer> node2 = new TreeNode<Integer>(2);\r\n		tree.insertChild(root, node2);\r\n		TreeNode<Integer> node3 = new TreeNode<Integer>(3);\r\n		tree.insertChild(root, node3);\r\n		\r\n		TreeNode<Integer> node11 = new TreeNode<Integer>(11);\r\n		tree.insertChild(node1, node11);\r\n		TreeNode<Integer> node12 = new TreeNode<Integer>(12);\r\n		tree.insertChild(node1, node12);\r\n		TreeNode<Integer> node13 = new TreeNode<Integer>(13);\r\n		tree.insertChild(node1, node13);\r\n		\r\n		TreeNode<Integer> node111 = new TreeNode<Integer>(111);\r\n		tree.insertChild(node11, node111);\r\n		TreeNode<Integer> node1111 = new TreeNode<Integer>(1111);\r\n		tree.insertChild(node111, node1111);\r\n		TreeNode<Integer> node11111 = new TreeNode<Integer>(11111);\r\n		tree.insertChild(node1111, node11111);\r\n		\r\n		List<TreeNode<Integer>> list = tree.preOrder(root);\r\n		System.out.println(list);\r\n		\r\n		list = tree.postOrder(root);\r\n		System.out.println(list);\r\n		\r\n		System.out.println(tree.size());\r\n		System.out.println(tree.getHight(root));\r\n		System.out.println(tree.getFirstChild(node111));\r\n		System.out.println(tree.getNextSibling(node12));\r\n		System.out.println(tree.getParent(node111));\r\n		tree.deleteChild(node1, 2);\r\n		System.out.println(tree.preOrder(root));\r\n		System.out.println(tree.size());\r\n		\r\n		for (List<TreeNode<Integer>> l : tree.levelOrder()){\r\n			System.out.println(l);\r\n		}\r\n	}\r\n}\r\n```\r\n\r\n### 二叉树的基本概念及实现\r\n\r\n#### 二叉树的性值\r\n\r\n1. 在非空二叉树中，第i层的结点总数不超过 , i>=1；\r\n2. 深度为h的二叉树最多有 个结点(h>=1)，最少有h个结点；\r\n3. 对于任意一棵二叉树，如果其叶结点数为N0，而度数为2的结点总数为N2，则N0=N2+1；\r\n4. 具有n个结点的完全二叉树的深度为 （注：[ ]表示向下取整）\r\n5. 有N个结点的完全二叉树各结点如果用顺序方式存储，则结点之间有如下关系：\r\n若I为结点编号则 如果I>1，则其父结点的编号为I/2；\r\n如果2*I<=N，则其左孩子（即左子树的根结点）的编号为2*I；若2*I>N，则无左孩子；\r\n如果2*I+1<=N，则其右孩子的结点编号为2*I+1；若2*I+1>N，则无右孩子。\r\n\r\n### 二叉查找树\r\n\r\n#### 操作定义\r\n\r\n```java\r\npublic interface IBinarySearchTree<K, V> {\r\n	//插入一个节点\r\n	BSTNode<K, V> insert(K key, V value);\r\n	\r\n	//中序遍历\r\n	void inOrder(Consumer<K> con);\r\n	\r\n	//查找value\r\n	V lookUpValue(K key);\r\n	\r\n	//获取最大关键字\r\n	K max();\r\n	\r\n	//获取最小关键字\r\n	K min();\r\n	\r\n	//删除节点\r\n	void remove(K key);\r\n	\r\n	//第一个比k大的节点\r\n	K successor(K key);\r\n	\r\n	//前一个比K小的节点\r\n	K predecessor(K key);\r\n	\r\n	//二叉树是否平衡\r\n	boolean isBalance();\r\n	\r\n	//节点数\r\n	int getSize();\r\n	\r\n	//高度\r\n	int getHeight();\r\n	\r\n	//层序遍历\r\n	List<List<BSTNode<K, V>>> levelOrder();\r\n}\r\n```\r\n\r\n#### 节点定义\r\n\r\n```java\r\npublic class BSTNode<K, V> {\r\n	public K key;\r\n	public V vlaue;\r\n	public BSTNode<K, V> left;\r\n	public BSTNode<K, V> right;\r\n	public BSTNode<K, V> parent;\r\n	public boolean isLeftChild;\r\n	public int height;\r\n	public int num;\r\n	public boolean isRed = true;\r\n	\r\n	public BSTNode(K key, V vlaue, BSTNode<K, V> left, BSTNode<K, V> right, BSTNode<K, V> parent) {\r\n		super();\r\n		this.key = key;\r\n		this.vlaue = vlaue;\r\n		this.left = left;\r\n		this.right = right;\r\n		this.parent = parent;\r\n	}\r\n	public BSTNode(K key, V vlaue) {\r\n		super();\r\n		this.key = key;\r\n		this.vlaue = vlaue;\r\n	}\r\n	@Override\r\n	public String toString() {\r\n		StringBuilder res = new StringBuilder();\r\n		if (isRed){\r\n			res.append(\"[\" + key + \"]\");\r\n		}else{\r\n			res.append(\"(\" + key + \")\");\r\n		}\r\n		if (parent != null){\r\n			res.append(\"<--\" + parent.key);\r\n		}\r\n		return res.toString();\r\n	}\r\n}\r\n```\r\n\r\n#### 实现\r\n\r\n```java\r\npublic class BinarySearchTree<K, V> implements IBinarySearchTree<K, V> {\r\n	protected BSTNode<K, V> root;\r\n	protected int size;\r\n	protected Comparator<K> comparator;\r\n\r\n	public BinarySearchTree(BSTNode<K, V> root) {\r\n		super();\r\n		this.root = root;\r\n	}\r\n\r\n	@Override\r\n	public BSTNode<K, V> insert(K key, V value) {\r\n		if (!(key instanceof Comparable)) {\r\n			throw new ClassCastException();\r\n		}\r\n		BSTNode<K, V> p = null;\r\n		BSTNode<K, V> cur = root;\r\n		// 找到应该插入的位置的父节点\r\n		while (cur != null) {\r\n			p = cur;\r\n			if (compare(cur.key, key) < 0) {\r\n				cur = cur.right;\r\n			} else if (compare(cur.key, key) > 0) {\r\n				cur = cur.left;\r\n			} else {\r\n				cur.vlaue = value;\r\n				return cur;\r\n			}\r\n		}\r\n		cur = new BSTNode<K, V>(key, value);\r\n		// 如果树为空\r\n		if (p == null) {\r\n			root = cur;\r\n		} else if (compare(p.key, key) > 0) {\r\n			p.left = cur;\r\n			cur.isLeftChild = true;\r\n		} else {\r\n			p.right = cur;\r\n			cur.isLeftChild = false;\r\n		}\r\n		cur.parent = p;\r\n		size++;\r\n		updateHight(cur);\r\n		return cur;\r\n	}\r\n\r\n	protected void updateHight(BSTNode<K, V> cur) {\r\n		if (cur.parent == null) {\r\n			return;\r\n		}\r\n		BSTNode<K, V> p = cur.parent;\r\n		if (cur.height == p.height) {\r\n			p.height++;\r\n			updateHight(p);\r\n		}\r\n	}\r\n\r\n	@Override\r\n	public void inOrder(Consumer<K> con) {\r\n		if (root != null) {\r\n			inOrder(root, con);\r\n		}\r\n	}\r\n\r\n	protected void inOrder(BSTNode<K, V> cur, Consumer<K> con) {\r\n		if (cur == null)\r\n			return;\r\n		inOrder(cur.left, con);\r\n		con.accept(cur.key);\r\n		inOrder(cur.right, con);\r\n	}\r\n\r\n	@Override\r\n	public V lookUpValue(K key) {\r\n		return lookupNode(key).vlaue;\r\n	}\r\n\r\n	protected BSTNode<K, V> lookupNode(K key) {\r\n		BSTNode<K, V> cur = root;\r\n		while (cur != null) {\r\n			if (compare(cur.key, key) == 0) {\r\n				return cur;\r\n			} else if (compare(cur.key, key) > 0) {\r\n				cur = cur.left;\r\n			} else {\r\n				cur = cur.right;\r\n			}\r\n		}\r\n		return null;\r\n	}\r\n\r\n	@Override\r\n	public K max() {\r\n		return maxNode(root).key;\r\n	}\r\n\r\n	protected BSTNode<K, V> maxNode(BSTNode<K, V> p) {\r\n		while (p.right != null)\r\n			p = p.right;\r\n		return p;\r\n	}\r\n\r\n	@Override\r\n	public K min() {\r\n		return minNode(root).key;\r\n	}\r\n\r\n	protected BSTNode<K, V> minNode(BSTNode<K, V> p) {\r\n		while (p.left != null)\r\n			p = p.left;\r\n		return p;\r\n	}\r\n\r\n	@Override\r\n	public void remove(K key) {\r\n		BSTNode<K, V> p = lookupNode(key);\r\n		// 没找到\r\n		if (p == null) {\r\n			return;\r\n		}\r\n		// 只有一个根节点\r\n		if (p.parent == null) {\r\n			root = null;\r\n			size--;\r\n			return;\r\n		}\r\n		// 叶子节点\r\n		if (p.left == null && p.right == null) {\r\n			if (p.isLeftChild) {\r\n				p.parent.left = null;\r\n			} else {\r\n				p.parent.right = null;\r\n			}\r\n			p.parent = null;\r\n			p = null;\r\n			size--;\r\n			return;\r\n		}\r\n		// 有一个孩子\r\n		if (p.left == null) {\r\n			if (p.isLeftChild) {\r\n				p.parent.left = p.right;\r\n				p.isLeftChild = true;\r\n				p.right.parent = p.parent;\r\n			} else {\r\n				p.parent.right = p.right;\r\n				p.right.parent = p.parent;\r\n			}\r\n			p.parent = null;\r\n			p = null;\r\n			size--;\r\n			return;\r\n		}\r\n		if (p.right == null) {\r\n			if (p.isLeftChild) {\r\n				p.parent.left = p.left;\r\n				p.isLeftChild = true;\r\n			} else {\r\n				p.parent.right = p.left;\r\n				p.isLeftChild = false;\r\n			}\r\n			p.left.parent = p.parent;\r\n			p.parent = null;\r\n			p = null;\r\n			size--;\r\n			return;\r\n		}\r\n		// 有两个孩子\r\n		BSTNode<K, V> minOfRight = minNode(p.right);\r\n		p.key = minOfRight.key;\r\n		p.vlaue = minOfRight.vlaue;\r\n		remove(minOfRight.key);\r\n	}\r\n\r\n	@Override\r\n	public K successor(K key) {\r\n		BSTNode<K, V> p = lookupNode(key);\r\n		if (p == null)	return null;\r\n		if (p.right != null){\r\n			//右子树中最小的元素\r\n			return minNode(p.right).key;\r\n		}\r\n		//向上找第一个是左孩子的节点的父节点\r\n		while (p != null && !p.isLeftChild){\r\n			p = p.parent;\r\n		}\r\n		return p == null ? null:p.parent.key;\r\n	}\r\n\r\n	@Override\r\n	public K predecessor(K key) {\r\n		BSTNode<K, V> p = lookupNode(key);\r\n		if (p == null)	return null;\r\n		if (p.left != null){\r\n			//左子树中最大的元素\r\n			return maxNode(p.left).key;\r\n		}\r\n		//向上找第一个是右孩子的节点的父节点\r\n		while (p != null && p.isLeftChild){\r\n			p = p.parent;\r\n		}\r\n		return p == null ? null:p.parent.key;\r\n	}\r\n\r\n	@Override\r\n	public boolean isBalance() {\r\n		return !unBalance(root);\r\n	}\r\n	\r\n	protected boolean unBalance(BSTNode<K, V> n){\r\n		if (n == null) return false;\r\n		int x = Math.abs(getHight(n.left) - getHight(n.right));\r\n		return x > 1 || unBalance(n.left) || unBalance(n.right);\r\n	}\r\n\r\n	@Override\r\n	public int getSize() {\r\n		return size;\r\n	}\r\n\r\n	@Override\r\n	public int getHeight(){\r\n		return getHight(root);\r\n	}\r\n	protected int getHight(BSTNode<K, V> p) {\r\n		if (p == null){\r\n			return 0;\r\n		}\r\n		int max = Math.max(getHight(p.left), getHight(p.right));\r\n		return max + 1;\r\n	}\r\n	\r\n	protected void rightRotate(BSTNode<K, V> g, BSTNode<K, V> p) {\r\n		BSTNode<K, V> gp = g.parent;\r\n		boolean gb = g.isLeftChild;\r\n		\r\n		g.parent = p;\r\n		g.isLeftChild = false;\r\n		\r\n		\r\n		//处理B\r\n		if (p.right != null){\r\n			g.left = p.right;\r\n			g.left.isLeftChild = true;\r\n			g.left.parent = g;\r\n		}else{\r\n			g.left = null;\r\n		}\r\n		p.right = g;\r\n		\r\n		//处理p\r\n		if (gp != null){\r\n			p.parent = gp;\r\n			p.isLeftChild = gb;\r\n			//处理上一级\r\n			if (gb){\r\n				p.parent.left = p;\r\n			}else{\r\n				p.parent.right = p;\r\n			}\r\n		}else{\r\n			root = p;\r\n			p.parent = null;\r\n		}\r\n	}\r\n	\r\n	protected void leftRotate(BSTNode<K, V> g, BSTNode<K, V> p) {\r\n		BSTNode<K, V> gp = g.parent;\r\n		boolean gb = g.isLeftChild;\r\n		\r\n		g.parent = p;\r\n		g.isLeftChild = true;\r\n		\r\n		\r\n		//处理B\r\n		if (p.left != null){\r\n			g.right = p.left;\r\n			g.right.isLeftChild = false;\r\n			g.right.parent = g;\r\n		}else{\r\n			g.right = null;\r\n		}\r\n		p.left = g;\r\n		\r\n		//处理p\r\n		if (gp != null){\r\n			p.parent = gp;\r\n			p.isLeftChild = gb;\r\n			//处理上一级\r\n			if (gb){\r\n				p.parent.left = p;\r\n			}else{\r\n				p.parent.right = p;\r\n			}\r\n		}else{\r\n			root = p;\r\n			p.parent = null;\r\n		}\r\n	}\r\n	\r\n	@Override\r\n	public List<List<BSTNode<K, V>>> levelOrder() {\r\n		BSTNode<K, V> p = root;\r\n		List<List<BSTNode<K, V>>> res = new ArrayList<>();\r\n		List<BSTNode<K, V>> list = new ArrayList<BSTNode<K,V>>();\r\n		Queue<BSTNode<K, V>> queue = new LinkedList<BSTNode<K,V>>();\r\n		queue.add(p);\r\n		BSTNode<K, V> last = p;\r\n		BSTNode<K, V> n = p;\r\n		\r\n		while (!queue.isEmpty()){\r\n			//弹出一个\r\n			p = queue.poll();\r\n			list.add(p);\r\n			//进入n个\r\n			if (p.left != null){\r\n				p.left.num = p.num * 2;\r\n				queue.add(p.left);\r\n				n = p.left;\r\n			}\r\n			if (p.right != null){\r\n				p.right.num = p.num * 2 + 1;\r\n				queue.add(p.right);\r\n				n = p.right;\r\n			}\r\n			if (p == last){\r\n				res.add(list);\r\n				list = new ArrayList<>();\r\n				last = n;\r\n			}\r\n		}\r\n		\r\n		return res;\r\n	}\r\n\r\n	protected int compare(K key1, K key2) {\r\n		// 判断是否有自定义比较器\r\n		if (comparator == null) {\r\n			return ((Comparable) key1).compareTo((Comparable) key2);\r\n		} else {\r\n			return comparator.compare(key1, key2);\r\n		}\r\n	}\r\n}\r\n```\r\n\r\n* 当二叉查找树成为斜树时，它的查找效率会从O(logn)退化到O(N),因此需要尽量保持二叉查找树的平衡。\r\n\r\n#### 二叉平衡树\r\n\r\n* AVL是最先发明的自平衡二叉查找树\r\n* AVL树所有节点的平衡因子(高度最大差)的绝对值不大于1，需要在BST的基础上在插入和删除时维护平衡即可。\r\n* AVL is a BST.\r\n\r\n##### 新增操作\r\n\r\n![](/images/lanqiao/avl.png)\r\n![](/images/lanqiao/avl2.png)\r\n\r\n##### 删除操作\r\n\r\n![](/images/lanqiao/avl3.png)\r\n\r\n##### 实现\r\n\r\n```java\r\npublic class AVLTree<K, V> extends BinarySearchTree<K, V> implements IBinarySearchTree<K, V> {\r\n	public AVLTree(BSTNode<K, V> root) {\r\n		super(root);\r\n	}\r\n	\r\n	@Override\r\n	public BSTNode<K, V> insert(K key, V value) {\r\n		//插入节点\r\n		BSTNode<K, V> node = super.insert(key, value);\r\n		//找到不平衡的节点坐标\r\n		BSTNode<K, V>[] gps = findUnBalance(node);\r\n		if (gps != null){\r\n			//重新调整平衡\r\n			reBalance(gps);\r\n		}\r\n		return node;\r\n	}\r\n	//根据gps将二叉树调整平衡\r\n	private void reBalance(BSTNode<K, V>[] gps) {\r\n		if (gps == null) return;\r\n		BSTNode<K, V> g = gps[0];\r\n		BSTNode<K, V> p = gps[1];\r\n		BSTNode<K, V> s = gps[2];\r\n		\r\n		//判型\r\n		if (p.isLeftChild && s.isLeftChild){	//左左型\r\n			rightRotate(g, p);\r\n		}else if (!p.isLeftChild && !s.isLeftChild){ //右右型\r\n			leftRotate(g, p);\r\n		}else if (p.isLeftChild && !s.isLeftChild){	//左右型\r\n			leftRotate(p, s);\r\n			rightRotate(g, s);\r\n		}else{	//右左型\r\n			rightRotate(p, s);\r\n			leftRotate(g, s);\r\n		}\r\n	}\r\n\r\n	//向上寻找到第一个不平衡的祖先\r\n	private BSTNode<K, V>[] findUnBalance(BSTNode<K, V> node) {\r\n		if (node == null) return null;\r\n		BSTNode<K, V> s = node;\r\n		if (node.parent == null) return null;\r\n		BSTNode<K, V> p = node.parent;\r\n		if (p.parent == null) return null;\r\n		BSTNode<K, V> g = p.parent;\r\n		if (unBalance(g)){\r\n			return new BSTNode[]{g, p, s};\r\n		}else{\r\n			return findUnBalance(p);\r\n		}\r\n	}\r\n\r\n	@Override\r\n	public void remove(K key) {\r\n		BSTNode<K, V> node = lookupNode(key);\r\n		if (node == null) 	return;\r\n		\r\n		if (node.left == null && node.right == null){\r\n			//如果是叶子节点直接删除后重新调整平衡\r\n			super.remove(key);\r\n			reBalance(node.parent);\r\n		}else if (node.left == null){\r\n			//如果只有右孩子,在右侧找最小值替换当前节点，然后删除右侧最小值节点\r\n			BSTNode<K, V> su = minNode(node.right);\r\n			super.remove(su.key);\r\n			node.key = su.key;\r\n			node.vlaue = su.vlaue;\r\n			reBalance(su.parent);\r\n		}else{\r\n			//如果只有左孩子或有左右孩子，在左侧找最大值替换当前节点，然后删除左侧最大值节点\r\n			BSTNode<K, V> pr = maxNode(node.left);\r\n			super.remove(pr.key);\r\n			node.key = pr.key;\r\n			node.vlaue = pr.vlaue;\r\n			reBalance(pr.parent);\r\n		}\r\n	}\r\n\r\n	private void reBalance(BSTNode<K, V> p) {\r\n		if (p == null)	return;\r\n		\r\n		int leftHeight = getHight(p.left);\r\n		int rightHeight = getHight(p.right);\r\n		\r\n		if (leftHeight - rightHeight > 1){\r\n			//左侧高\r\n			rightRotate(p, p.left);\r\n			reBalance(p.left);\r\n		}else if (rightHeight - leftHeight > 1){\r\n			//右侧高\r\n			leftRotate(p, p.right);\r\n			reBalance(p.right);\r\n		}else{\r\n			reBalance(p.parent);\r\n		}\r\n	}\r\n}\r\n```\r\n\r\n#### 红黑树\r\n\r\n* 要求不那么严格的平衡树一红黑树\r\n* (1).节点都有颜色标记,且只能是红色或黑色。\r\n* (2).根是黑色。\r\n* (3).所有叶子都是黑色(叶子是NIL/nill_节点,不保存实际的数据)。\r\n* (4).每个红色节点必须有两个黑色的子节点,也可以表述为从每个叶子到根的所有路径上不能有两个连续的红色节点。\r\n* (5).从任一节点到其每个叶子的所有简单路径都包含相同数目的黑色节点。\r\n* 根黑，红黑,叶黑,红不连,同黑\r\n\r\n##### 新增节点\r\n\r\n![](/images/lanqiao/rbt.png)\r\n![](/images/lanqiao/rbt2.png)\r\n\r\n##### 删除节点\r\n\r\n![](/images/lanqiao/rbt3.png)\r\n\r\n* 红黑树删除及修复\r\n   1、双支转单支\r\n   2、删除D，并顶替N\r\n   3、D为黑，需修复\r\n   4、N为红，很简单（N变黑即可）\r\n   N为黑，系列复杂的修复\r\n\r\n##### 实现\r\n\r\n```java\r\npublic class RedBlackTree<K, V> extends BinarySearchTree<K, V> implements IBinarySearchTree<K, V> {\r\n	private static final boolean RED = true;\r\n	private static final boolean BLACK = false;\r\n	\r\n	public RedBlackTree(BSTNode<K, V> root) {\r\n		super(root);\r\n		colorBlack(root);\r\n	}\r\n	\r\n	@Override\r\n	public BSTNode<K, V> insert(K key, V value) {\r\n		//插入节点\r\n		BSTNode<K, V> node = super.insert(key, value);\r\n		//调整插入节点后的红黑树\r\n		adjust(node);\r\n		//根节点染黑\r\n		colorBlack(root);\r\n		size++;\r\n		return node;\r\n	}\r\n	\r\n	//插入新节点后重新调整红黑树\r\n	private void adjust(BSTNode<K, V> node){\r\n		if (node == null) 	return;\r\n		BSTNode<K, V> parent = node.parent;\r\n		if (parent == null)	return;\r\n		//如果父节点为红色破坏了红不连的规则\r\n		if (parent.isRed == RED){\r\n			BSTNode<K, V> grand = parent.parent;\r\n			BSTNode<K, V> uncle = parent.isLeftChild ? parent.parent.right : parent.parent.left;\r\n			\r\n			if (uncle != null && uncle.isRed == RED){\r\n				//如果uncle为红，gpu反色\r\n				colorRed(grand);\r\n				colorBlack(parent);\r\n				colorBlack(uncle);\r\n				adjust(grand);\r\n			}else{\r\n				//uncle为黑的情况\r\n				if (node.isLeftChild && parent.isLeftChild){\r\n					//左左型 pg反色 向右旋转\r\n					colorBlack(parent);\r\n					colorRed(grand);\r\n					rightRotate(grand, parent);\r\n				}else if (parent.isLeftChild && !node.isLeftChild){\r\n					//左右型 沿着p旋转 变成左左型\r\n					leftRotate(parent, node);\r\n					adjust(parent);\r\n				}else if (!parent.isLeftChild && node.isLeftChild){\r\n					//右左型 沿着p旋转 变成右右型\r\n					rightRotate(parent, node);\r\n					adjust(parent);\r\n				}else{\r\n					//右右型 pg反色 向左旋转\r\n					colorBlack(parent);\r\n					colorRed(grand);\r\n					leftRotate(grand, parent);\r\n				}\r\n			}\r\n		}\r\n	}\r\n	\r\n	private void colorRed(BSTNode<K, V> node){\r\n		if (node != null)	node.isRed = RED;\r\n	}\r\n	\r\n	private void colorBlack(BSTNode<K, V> node){\r\n		if (node != null)	node.isRed = BLACK;\r\n	}\r\n	\r\n	@Override\r\n	public void remove(K key) {\r\n		BSTNode<K, V> del = lookupNode(key);\r\n		if (del == null)	return;\r\n		\r\n		//如果有左右孩子 转移为单支或叶子节点\r\n		if (del.left != null && del.right != null){\r\n			//从右子树中找到最小值\r\n			BSTNode<K, V> n = lookupNode(successor(key));\r\n			del.key = n.key;\r\n			del.vlaue = n.vlaue;\r\n			//del指向最小值节点 为待删除节点\r\n			del = n;\r\n		}\r\n		\r\n		//此时待删除节点一定为单支或者叶子节点\r\n		//找到顶替节点\r\n		BSTNode<K, V> n = null;\r\n		if (del.left != null){\r\n			n = del.left;\r\n		}else{\r\n			n = del.right;\r\n		}\r\n		\r\n		if (n == null){	//待删除节点为叶子\r\n			if (del.parent == null){\r\n				//待删除节点为根节点\r\n				root = null;\r\n				return;\r\n			}\r\n			//如果删除的叶子节点为黑色需要先修复\r\n			if (del.isRed == BLACK){\r\n				repair(del);\r\n			}\r\n			//删除叶子\r\n			if (del.parent.isLeftChild){\r\n				del.parent.left = null;\r\n			}else{\r\n				del.parent.right = null;\r\n			}\r\n			del.parent = null;\r\n			del = null;\r\n		}else{\r\n			//单支 使用孩子节点顶替待删除节点\r\n			n.parent = del.parent;\r\n			if (n.parent == null){\r\n				root = n;\r\n				colorBlack(root);\r\n			}\r\n			n.isLeftChild = del.isLeftChild;\r\n			if (n.isLeftChild){\r\n				n.parent.left = n;\r\n			}else{\r\n				n.parent.right = n;\r\n			}\r\n			del.left = del.right = del.parent = null;\r\n			\r\n			if (del.isRed == BLACK){\r\n				repair(n);\r\n			}\r\n		}\r\n		size--;\r\n	}\r\n	\r\n	//删除后修复红黑树\r\n	private void repair(BSTNode<K, V> n) {\r\n		if (n.isRed == RED){\r\n			//顶替节点为红色直接染黑\r\n			colorBlack(n);\r\n		}else if (n.parent != null){\r\n			//n为黑 double black 有若干种情况\r\n			case2(n);\r\n		}\r\n	}\r\n	\r\n	//sib is red 父兄反色 	旋转\r\n	private void case2(BSTNode<K, V> n) {\r\n		BSTNode<K, V> sib = getSib(n);\r\n		if (sib.isRed){\r\n			colorBlack(sib);\r\n			colorRed(n.parent);\r\n			if (n == n.parent.left){\r\n				leftRotate(n.parent, sib);\r\n			}else{\r\n				rightRotate(n.parent, sib);\r\n			}\r\n		}\r\n		case3(n);\r\n	}\r\n	\r\n	//parent is black 且sib双子为黑  sib->red 递归p->case1\r\n	private void case3(BSTNode<K, V> n) {\r\n		BSTNode<K, V> sib = getSib(n);\r\n		boolean sibL = sib.left == null ? BLACK : sib.left.isRed;\r\n		boolean sibR = sib.right == null ? BLACK : sib.right.isRed;\r\n		if (n.parent.isRed == BLACK && sibL == BLACK && sibR == BLACK){\r\n			colorRed(sib);\r\n			repair(n.parent);\r\n		}else{\r\n			case4(n);\r\n		}\r\n	}\r\n	\r\n	//双子为黑 父亲为红 父兄反色\r\n	private void case4(BSTNode<K, V> n) {\r\n		BSTNode<K, V> sib = getSib(n);\r\n		boolean sibL = sib.left == null ? true : sib.left.isRed;\r\n		boolean sibR = sib.right == null ? true : sib.right.isRed;\r\n		if (n.parent.isRed == RED && sibL == BLACK && sibR == BLACK){\r\n			colorRed(sib);\r\n			colorBlack(n.parent);\r\n		}else{\r\n			case5(n);\r\n		}\r\n	}\r\n\r\n	//兄弟向内的孩子为红，通过旋转转移为case6：向外的孩子为红\r\n	private void case5(BSTNode<K, V> n) {\r\n		BSTNode<K, V> sib = getSib(n);\r\n		boolean sibL = sib.left == null ? true : sib.left.isRed;\r\n		boolean sibR = sib.right == null ? true : sib.right.isRed;\r\n		if (n.isLeftChild && sibR == BLACK){\r\n			colorBlack(sib.left);\r\n			colorRed(sib);\r\n			rightRotate(sib, sib.left);\r\n		}else if (!n.isLeftChild && sibL == BLACK){\r\n			colorBlack(sib.right);\r\n			colorRed(sib);\r\n			rightRotate(sib, sib.right);\r\n		}\r\n		case6(n);\r\n	}\r\n\r\n	//兄弟向外的孩子为红 兄弟染为父节点的颜色 父节点染黑 父节点旋转\r\n	private void case6(BSTNode<K, V> n) {\r\n		BSTNode<K, V> sib = getSib(n);\r\n		sib.isRed = n.parent.isRed;\r\n		colorBlack(n.parent);\r\n		if (n.isLeftChild){\r\n			colorBlack(sib.right);\r\n			leftRotate(n.parent, sib);\r\n		}else{\r\n			colorBlack(sib.left);\r\n			rightRotate(n.parent, sib);\r\n		}\r\n	}\r\n\r\n	private BSTNode<K, V> getSib(BSTNode<K, V> n){\r\n		if (n.isLeftChild){\r\n			return n.parent.right;\r\n		}else{\r\n			return n.parent.left;\r\n		}\r\n	}\r\n\r\n	@Override\r\n	public String toString() {\r\n		StringBuilder sb = new StringBuilder();\r\n		List<List<BSTNode<K, V>>> res = levelOrder();\r\n		for (List<BSTNode<K, V>> list : res) {\r\n			for (BSTNode<K, V> bstNode : list) {\r\n				sb.append(bstNode + \"\\t\");\r\n			}\r\n			sb.append(\"\\n\");\r\n		}\r\n		return sb.toString();\r\n	}\r\n}\r\n```\r\n\r\n### 二叉树补充\r\n\r\n1. 叶子节点的个数\r\n	```java\r\n	//求二叉树叶子节点的个数\r\n	public int leafNumber(BSTNode<K, V> node){\r\n		if (node == null)	return 0;\r\n		if (node.left == null && node.right == null)	return 1;\r\n		\r\n		return leafNumber(node.left) + leafNumber(node.right);\r\n	}\r\n	```\r\n2. 第k层的节点数\r\n	* 层序遍历，给每层相应编号，第k层编号范围：[2(k-1)~2(k)-1]\r\n	```java\r\n	//二叉树第k层节点数目\r\n	public int levelKNum(BSTNode<K, V> root, int k){\r\n		//得到层序遍历下第k层的编号范围\r\n		int min = (int) Math.pow(2, k - 1);\r\n		int max = (int) Math.pow(2, k) - 1;\r\n		\r\n		//初始化队列辅助宽搜\r\n		Queue<BSTNode<K, V>> qu = new LinkedList<>();\r\n		root.num = 1;\r\n		qu.add(root);\r\n		int count = 0;\r\n		while (!qu.isEmpty()){\r\n			BSTNode<K, V> t = qu.poll();\r\n			if (t.left != null){\r\n				t.left.num = t.num * 2;\r\n				qu.add(t.left);\r\n			}\r\n			if (t.right != null){\r\n				t.right.num = t.num * 2 + 1;\r\n				qu.add(t.right);\r\n			}\r\n			//判断节点编号是否在k层编号范围内\r\n			if (t.num >= min && t.num <= max){\r\n				count++;\r\n			}\r\n			if (t.num > max){\r\n				break;\r\n			}\r\n		}\r\n		\r\n		return count;\r\n	}\r\n	```\r\n3. 是否完全二叉树\r\n	```java\r\n	//判断是否为完全二叉树\r\n	public boolean isCBT(){\r\n		for (int i = 1; i <= getHeight(); i++){\r\n			//完全二叉树每层节点数目\r\n			int num = (int) Math.pow(2, i - 1);\r\n			//和实际节点数目比较\r\n			if (num != levelKNum(root, i)){\r\n				return false;\r\n			}\r\n		}\r\n		\r\n		return true;\r\n	}\r\n	```\r\n4. 两棵二叉树是否相同，是否互为镜像\r\n	```java\r\n	//两棵二叉树是否完全相同\r\n	public boolean equal(BSTNode<K, V> me, BSTNode<K, V> other){\r\n		if (me == null && other == null)	return true;\r\n		if (me == null || other == null)	return false;\r\n		\r\n		return me.key == other.key && equal(me.left, other.left) && equal(me.right, other.right);\r\n	}\r\n	```\r\n	```java\r\n	//两棵二叉树是否互为镜像\r\n	public boolean image(BSTNode<K, V> me, BSTNode<K, V> other){\r\n		if (me == null && other == null)	return true;\r\n		if (me == null || other == null)	return false;\r\n		\r\n		return me.key == other.key && equal(me.left, other.right) && equal(me.right, other.left);\r\n	}\r\n	```\r\n5. 翻转二叉树\r\n	```java\r\n	//翻转二叉树\r\n	public void turn(BSTNode<K, V> node){\r\n		if (node == null)	return;\r\n		\r\n		turn(node.left);\r\n		turn(node.right);\r\n		BSTNode<K, V> t = node.left;\r\n		node.left = node.right;\r\n		node.right = t;\r\n	}\r\n	```\r\n6. 前序遍历\r\n7. 后序遍历\r\n8. BST区间搜索\r\n	```java\r\n	//bst区间搜索\r\n	List<BSTNode<K, V>> list = new ArrayList<>();\r\n	public List<BSTNode<K, V>> search(BSTNode<K, V> node, int min, int max){\r\n		if (node == null){\r\n			return null;\r\n		}\r\n		\r\n		if (((Comparable)node.key).compareTo(min) >= 0 && ((Comparable)node.key).compareTo(max) <= 0){\r\n			list.add(node);\r\n		}\r\n		//如果查找值还在范围内 就继续向下查找\r\n		if (((Comparable)node.key).compareTo(min) > 0){\r\n			search(node.left, min, max);\r\n		}\r\n		if (((Comparable)node.key).compareTo(max) < 0){\r\n			search(node.right, min, max);\r\n		}\r\n		return list;\r\n	}\r\n	```\r\n\r\n### 前缀树\r\n\r\n* Trie;又称单词查找树;是一-种树形结构;用于保存大量的字符串。它的优点是:利用字符串的公共前缀来节约存储空间\r\n* Trie 树主要是利用词的公共前缀缩小查词范围、通过状态间的映射关系避免了字符的遍历,从而达到高效检索的目的。\r\n\r\n#### 节点定义\r\n\r\n```java\r\npublic class TrieNode {\r\n	//节点次序\r\n	public int level;\r\n	public TrieNode[] children = new TrieNode[26];\r\n	public TrieNode parent;\r\n	//是否为单词末尾\r\n	public boolean isLast;\r\n	//出现频率\r\n	public int fre = 1;\r\n}\r\n```\r\n\r\n#### 实现\r\n\r\n```java\r\npublic class Trie {\r\n	TrieNode root;\r\n	\r\n	public Trie(){\r\n		root = new TrieNode();\r\n	}\r\n	//插入单词\r\n	public void insert(String str){\r\n		char[] chars = str.toCharArray();\r\n		TrieNode p = root;\r\n		for (int i = 0; i < chars.length; i++) {\r\n			TrieNode t = p.children[chars[i] - \'a\'];\r\n			if (t == null){\r\n				t = new TrieNode();\r\n				t.level = chars[i] - \'a\';\r\n				t.parent = p;\r\n				p.children[chars[i] - \'a\'] = t;\r\n			}else{\r\n				t.fre++;\r\n			}\r\n				p = t;\r\n		}\r\n		\r\n		p.isLast = true;\r\n	}\r\n	//查找前缀为prefix的单词\r\n	public void search(String prefix){\r\n		char[] chars = prefix.toCharArray();\r\n		TrieNode p = root;\r\n		for (int i = 0; i < chars.length; i++) {\r\n			TrieNode t = p.children[chars[i] - \'a\'];\r\n			if (t == null){\r\n				return;\r\n			}else{\r\n				p = t;\r\n			}\r\n		}\r\n		\r\n		print(\"\", p);\r\n	}\r\n	//打印以p为起点的所有单词\r\n	private void print(String prefix, TrieNode p) {\r\n		if (p.isLast && prefix.length() > 0){\r\n			System.out.println(prefix + \" \" + p.fre);\r\n		}\r\n		for (int i = 0; i < 26; i++) {\r\n			if (p.children[i] != null){\r\n				print(prefix + (char)(\'a\' + p.children[i].level), p.children[i]);\r\n			}\r\n		}\r\n	}\r\n	//打印整个前缀树中所有单词\r\n	public void printAll(){\r\n		print(\"\", root);\r\n	}\r\n}\r\n```\r\n\r\n### 题解\r\n\r\n1. 给定一棵二叉树，求其最小深度。最小深度是节点数沿最短路径从根节点到最近的叶节点。[LeetCode](https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/)\r\n\r\n```java\r\npublic int minDepth(TreeNode root) {\r\n	if (root == null)   return 0;\r\n	int left = minDepth(root.left);\r\n	int right = minDepth(root.right);\r\n	if (root.left == null || root.right == null){\r\n		return (int)Math.max(left, right) + 1;\r\n	}\r\n	return (int)Math.min(left, right) + 1;\r\n}\r\n```\r\n\r\n2. [求根到叶子节点数字之和](https://leetcode-cn.com/problems/sum-root-to-leaf-numbers/)\r\n\r\n```java\r\npublic int sumNumbers(TreeNode root) {\r\n	if (root == null){\r\n		return 0;\r\n	}\r\n	f(root, \"\");\r\n	int sum = 0;\r\n	for (int i = 0; i < list.size(); i++){\r\n		int t = Integer.parseInt(list.get(i));\r\n		sum += t;\r\n	}\r\n	\r\n	return sum;\r\n}\r\nList<String> list = new ArrayList<>();\r\npublic void f(TreeNode root, String pre){\r\n	pre = pre + root.val;\r\n	if (root.left == null && root.right == null){\r\n		list.add(pre);\r\n	}\r\n	if (root.left != null){\r\n		f(root.left, pre);\r\n	}\r\n	if (root.right != null){\r\n		f(root.right, pre);\r\n	}\r\n}\r\n```\r\n\r\n3. [平衡二叉树](https://leetcode-cn.com/problems/balanced-binary-tree/)\r\n\r\n```java\r\npublic boolean isBalanced(TreeNode root) {\r\n	if (root == null) return true;\r\n	int x = Math.abs(getHight(root.left) - getHight(root.right));\r\n	return x <= 1 && isBalanced(root.left) && isBalanced(root.right);\r\n}\r\npublic int getHight(TreeNode p) {\r\n	if (p == null){\r\n		return 0;\r\n	}\r\n	int max = Math.max(getHight(p.left), getHight(p.right));\r\n	return max + 1;\r\n}\r\n```\r\n\r\n4. [最小高度树](https://leetcode-cn.com/problems/minimum-height-tree-lcci/)\r\n\r\n```java\r\npublic TreeNode sortedArrayToBST(int[] nums) {\r\n	return f(nums, 0, nums.length - 1);\r\n}\r\npublic TreeNode f(int[] nums, int i, int j){\r\n	if (i > j){\r\n		return null;\r\n	}\r\n	int mid = (i + j) / 2;\r\n	TreeNode left = f(nums, i, mid - 1);\r\n	TreeNode right = f(nums, mid + 1, j);\r\n	TreeNode node = new TreeNode(nums[mid]);\r\n	node.left = left;\r\n	node.right = right;\r\n	return node;\r\n}\r\n```\r\n\r\n5. [特定深度节点链表](https://leetcode-cn.com/problems/list-of-depth-lcci/)\r\n\r\n```java\r\npublic ListNode[] listOfDepth(TreeNode tree) {\r\n	List res = new ArrayList();\r\n	ListNode node = new ListNode(-1);\r\n	Queue<TreeNode> qu = new LinkedList<TreeNode>();\r\n	qu.add(tree);\r\n	TreeNode p = tree;\r\n	TreeNode last = tree;\r\n	boolean f = true;\r\n	while (!qu.isEmpty()){\r\n		TreeNode t = qu.poll();\r\n		node.next = new ListNode(t.val);\r\n		if (f){\r\n			res.add(node);\r\n			f = !f;\r\n		}\r\n		node = node.next;\r\n		\r\n		if (t.left != null){\r\n			qu.add(t.left);\r\n			p = t.left;\r\n		}\r\n		if (t.right != null){\r\n			qu.add(t.right);\r\n			p = t.right;\r\n		}\r\n		if (t == last){\r\n			f = true;\r\n			last = p;\r\n			node = new ListNode(-1);\r\n		}\r\n	}\r\n	\r\n	ListNode[] ln = new ListNode[res.size()];\r\n	for (int i = 0; i < ln.length; i++) {\r\n		ln[i] = ((ListNode) res.get(i)).next;\r\n	}\r\n	\r\n	return ln;\r\n}\r\n```\r\n\r\n6. [合法二叉搜索树](https://leetcode-cn.com/problems/legal-binary-search-tree-lcci/)\r\n\r\n* 中序遍历bst 判断遍历结果是否有序\r\n\r\n```java\r\npublic boolean isValidBST(TreeNode root) {\r\n	if (root == null )  return true;\r\n	inOrder(root);\r\n	for (int i = 0; i < list.size() - 1; i++) {\r\n		if (list.get(i) > list.get(i + 1)){\r\n			return false;\r\n		}\r\n	}\r\n	return true;\r\n}\r\nList<Integer> list = new ArrayList<Integer>();\r\npublic List<Integer> inOrder(TreeNode root){\r\n	if (root == null) return null;\r\n	inOrder(root.left);\r\n	list.add(root.val);\r\n	inOrder(root.right);\r\n	\r\n	return list;\r\n}\r\n```\r\n\r\n* 递归遍历 记录前驱节点的值 比较是否有序\r\n\r\n7. [后继者](https://leetcode-cn.com/problems/successor-lcci/)\r\n\r\n* 有parent指针的情况下\r\n\r\n```java\r\npublic K successor(K key) {\r\n	BSTNode<K, V> p = lookupNode(key);\r\n	if (p == null)	return null;\r\n	if (p.right != null){\r\n		//右子树中最小的元素\r\n		return minNode(p.right).key;\r\n	}\r\n	//向上找第一个是左孩子的节点的父节点\r\n	while (p != null && !p.isLeftChild){\r\n		p = p.parent;\r\n	}\r\n	return p == null ? null:p.parent.key;\r\n}\r\n```\r\n\r\n* 无parent指针的情况下\r\n\r\n```java\r\n//迭代方式找到中序遍历后继节点\r\npublic K inorderSuccessor(BSTNode<K, V> root, BSTNode<K, V> p) {\r\n	BSTNode<K, V> n = root;\r\n	if (n == null)	return null;\r\n	Stack<BSTNode<K, V>> s = new Stack<>();\r\n	boolean f = false;\r\n	while (n != null || !s.isEmpty()){\r\n		while (n != null){\r\n			s.push(n);\r\n			n = n.left;\r\n		}\r\n		BSTNode<K, V> t = s.pop();\r\n		if (f){\r\n			return t.key;\r\n		}\r\n		if (t.key == p.key){\r\n			f = true;\r\n		}\r\n		if (t != null){\r\n			n = t.right;\r\n		}\r\n	}\r\n	\r\n	return null;\r\n}\r\n```\r\n\r\n* 递归方式求解\r\n\r\n```java\r\n//中序遍历递归方式求后继 记录前驱节点的值\r\nint pre = Integer.MIN_VALUE;\r\nK res;\r\npublic K successor3(BSTNode<K, V> root, BSTNode<K, V> p){\r\n	succ(root, p.key);\r\n	return res;\r\n}\r\n\r\npublic void succ(BSTNode<K, V> root, K key){\r\n	if (root == null)	return;\r\n	succ(root.left, key);\r\n	if (pre == (int)key){\r\n		res = root.key;\r\n		return;\r\n	}\r\n	pre = (int) root.key;\r\n	succ(root.right, key);\r\n}\r\n```\r\n\r\n8. [首个共同祖先](https://leetcode-cn.com/problems/first-common-ancestor-lcci/)\r\n\r\n* 解法1\r\n\r\n```java\r\npublic static TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\r\n	if (root == null || p == null || q == null){\r\n		return null;\r\n	}\r\n	//如果root和p或q相同则直接返回\r\n	if (root.val == p.val || root.val == q.val){\r\n		return root;\r\n	}\r\n	//判断p和q是否在该节点的左和右\r\n	boolean left = f(root.left, p.val);\r\n	boolean right = f(root.right, q.val);\r\n	//如果分别在左右或分别不在左右 则证明p和q分属该节点两侧\r\n	//只要分属某个节点两侧则该节点一定为首个共同祖先\r\n	if (left == right){\r\n		return root;\r\n	}\r\n	//如果都存在于左侧则递归去左侧找\r\n	if (left){\r\n		return lowestCommonAncestor(root.left, p, q);\r\n	}\r\n	//如果都存在于右侧则递归去右侧找\r\n	if (right){\r\n		return lowestCommonAncestor(root.right, p, q);\r\n	}\r\n	\r\n	return null;\r\n}\r\n\r\n//判断n是否在root子树中存在\r\npublic static boolean f(TreeNode root, int n){\r\n	if (root == null)	return false;\r\n	if (root.val == n){\r\n		return true;\r\n	}\r\n	\r\n	return f(root.left, n) || f(root.right, n);\r\n}\r\n```\r\n\r\n* 解法2\r\n\r\n```java\r\npublic TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\r\n	if (root == null)   return null;\r\n	if (root.val == p.val || root.val == q.val){\r\n		return root;\r\n	}\r\n	//x 为lca || p || q || null 代表找到了lca或者p在这一侧或者q在这一侧或者什么都不是\r\n	TreeNode x = lowestCommonAncestor(root.left, p, q);\r\n	if (x != null && x.val != p.val && x.val != q.val){\r\n		return x;\r\n	}\r\n	TreeNode y = lowestCommonAncestor(root.right, p, q);\r\n	if (y != null && y.val != p.val && y.val != q.val){\r\n		return y;\r\n	}\r\n\r\n	if (x != null && y != null){\r\n		return root;\r\n	}else if (root.val == p.val || root.val == q.val){\r\n		return root;\r\n	}else{\r\n		return x != null ? x : y;\r\n	}\r\n}\r\n```\r\n\r\n9. [检查子树](https://leetcode-cn.com/problems/check-subtree-lcci/)\r\n\r\n```java\r\npublic static boolean checkSubTree(TreeNode t1, TreeNode t2) {\r\n	if (t1 == null || t2 == null)	return false;\r\n	//找到t1子树中和t2根节点相同的节点\r\n	TreeNode node = s(t1, t2);\r\n	//如果找不到t2一定不是子树\r\n	if (node == null)	return false;\r\n	\r\n	//判断两个子树是否完全相同\r\n	if (f(node, t2)){\r\n		return true;\r\n	}else{\r\n		//如果不相同则递归检查左侧和右侧\r\n		return checkSubTree(t1.left, t2) || checkSubTree(t1.right, t2);\r\n	}\r\n}\r\n//判断两个子树是否相同\r\npublic static boolean f(TreeNode t1, TreeNode t2){\r\n	if (t1 == null && t2 == null)	return true;\r\n	if (t1 == null || t2 == null)	return false;\r\n	\r\n	if (t1.val != t2.val)	return false;\r\n	\r\n	return f(t1.left, t2.left) && f(t1.right, t2.right);\r\n}\r\n\r\n//在t1子树中找到和n相同的节点\r\npublic static TreeNode s(TreeNode t1, TreeNode n){\r\n	if (t1 == null)	return null;\r\n	if (t1.val == n.val){\r\n		return t1;\r\n	}\r\n	TreeNode node = s(t1.left, n);\r\n	if (node != null){\r\n		return node;\r\n	}else{\r\n		return s(t1.right, n);\r\n	}\r\n}\r\n```\r\n\r\n10. [求和路径](https://leetcode-cn.com/problems/paths-with-sum-lcci/)\r\n\r\n* 固定路径为从根节点到叶子节点\r\n\r\n```java\r\n//结果集\r\nstatic List<List<Integer>> list = new ArrayList<>();\r\npublic static void f(List<Integer> cur, TreeNode n, int target){\r\n	if (n == null)	return;\r\n	//l中记录从根节点到叶子的路径\r\n	List<Integer> l = new ArrayList<>();\r\n	l.addAll(cur);\r\n	l.add(n.val);\r\n	//如果该节点为叶子节点则结算\r\n	if (n.left == null && n.right == null){\r\n		//如果路径和正好相等\r\n		if (target - n.val == 0){\r\n			//加入结果集\r\n			list.add(l);\r\n		}\r\n		return;\r\n	}\r\n	f(l, n.left, target - n.val);\r\n	f(l, n.right, target - n.val);\r\n}\r\n```\r\n\r\n* 路径不一定以根节点或叶子节点结束\r\n\r\n```java\r\n//结果集\r\nstatic List<List<Integer>> list = new ArrayList<>();\r\n//计算路径和个数\r\npublic static int pathSum(TreeNode root, int sum){\r\n	help(root, sum);\r\n	return list.size();\r\n}\r\n//从任意节点向下到任意节点的路径和\r\nprivate static void help(TreeNode root, int sum) {\r\n	if (root == null)	return;\r\n	f2(new ArrayList<>(), root, sum);\r\n	help(root.left, sum);\r\n	help(root.right, sum);\r\n}\r\n\r\n//从根节点到任意向下节点的路径和\r\npublic static void f2(List<Integer> cur, TreeNode n, int target){\r\n	if (n == null)	return;\r\n	//l中记录从根节点到叶子的路径\r\n	List<Integer> l = new ArrayList<>();\r\n	l.addAll(cur);\r\n	l.add(n.val);\r\n	//如果该节点为叶子节点或路径和正好相等则结算\r\n	if (target - n.val == 0){\r\n		//加入结果集\r\n		list.add(l);\r\n	}\r\n	if (n.left == null && n.right == null){\r\n		return;\r\n	}\r\n	f2(l, n.left, target - n.val);\r\n	f2(l, n.right, target - n.val);\r\n}\r\n```', '2020-06-24 11:20:40', '0', '树的基本概念及实现树的实现操作定义/***树接口*@author96047**@param&lt;E', '/static/img/rand/4.jpg', '树结构', '0', 'post', '0', '2020-06-24 11:20:40', '1592968839', null);
INSERT INTO `plog_article` VALUES ('158', '14', '<h3 id=\"-\">图基础</h3>\r\n<h4 id=\"-\">树与图</h4>\r\n<ul>\r\n<li>没有圈的连通图,就是树</li>\r\n<li>没有圈的非连通图,就是森林</li>\r\n<li>一棵树的边数等于顶点数-1</li>\r\n<li>边数等于顶点数-1的连通图,就是树</li>\r\n</ul>\r\n<h4 id=\"-\">有向图</h4>\r\n<ul>\r\n<li>没有圈的有向图,叫做DAG ( Directed Acyclic Graph ,有向无环图)</li>\r\n<li>拓扑排序定义:将DAG中的顶点以线性方式进行排序。即对于任何自顶点u到顶点v的有向边u-&gt;v ,在最后的排序结果中,顶点u总是在顶点v的前面。这样的排序结果,称为拓扑序。</li>\r\n</ul>\r\n<h3 id=\"-\">图的表示</h3>\r\n<ul>\r\n<li>邻接矩阵</li>\r\n<li>邻接表</li>\r\n<li>边集数组-Edge List</li>\r\n</ul>\r\n<h3 id=\"dfs-\">dfs及相关问题</h3>\r\n<h4 id=\"dfs-\">dfs典型应用</h4>\r\n<ol>\r\n<li><p>连通检测</p>\r\n<ul>\r\n<li><p>给定一个方阵，定义连通：上下左右相邻，并且值相同。<br>可以想象成一张地图，不同的区域被涂以不同颜色。<br>输入：<br>整数N, (N&lt;50)表示矩阵的行列数<br>接下来N行，每行N个字符，代表方阵中的元素<br>接下来一个整数M，(M&lt;1000)表示询问数<br>接下来M行，每行代表一个询问，<br>格式为4个整数，y1,x1,y2,x2，<br>表示询问(第y1行,第x1列) 与 (第y2行,第x2列) 是否连通。<br>连通输出true，否则false</p>\r\n<p>例如：<br>10<br>0010000000<br>0011100000<br>0000111110<br>0001100010<br>1111010010<br>0000010010<br>0000010011<br>0111111000<br>0000010000<br>0000000000<br>3<br>0 0 9 9<br>0 2 6 8<br>4 4 4 6</p>\r\n<p>程序应该输出：<br>false<br>true<br>true</p>\r\n</li>\r\n<li><p>解：</p>\r\n<pre><code class=\"lang-java\">public static void main(String[] args) {\r\n  Scanner input = new Scanner(System.in);\r\n  //得到N\r\n  int N = input.nextInt();\r\n  //得到图\r\n  char[<span class=\"hljs-string\"></span>][<span class=\"hljs-symbol\"></span>] graph = new char[<span class=\"hljs-string\">N</span>][<span class=\"hljs-symbol\">N</span>];\r\n  int[<span class=\"hljs-string\"></span>][<span class=\"hljs-symbol\"></span>] help = new int[<span class=\"hljs-string\">N</span>][<span class=\"hljs-symbol\">N</span>];\r\n  for (int i = 0; i <span class=\"xml\"><span class=\"hljs-tag\">&lt; <span class=\"hljs-attr\">graph.length</span>; <span class=\"hljs-attr\">i</span>++) {\r\n      <span class=\"hljs-attr\">String</span> <span class=\"hljs-attr\">str</span> = <span class=\"hljs-string\">input.next();</span>\r\n      <span class=\"hljs-attr\">for</span> (<span class=\"hljs-attr\">int</span> <span class=\"hljs-attr\">j</span> = <span class=\"hljs-string\">0;</span> <span class=\"hljs-attr\">j</span> &lt; <span class=\"hljs-attr\">graph</span>[<span class=\"hljs-attr\">i</span>]<span class=\"hljs-attr\">.length</span>; <span class=\"hljs-attr\">j</span>++) {\r\n          <span class=\"hljs-attr\">graph</span>[<span class=\"hljs-attr\">i</span>][<span class=\"hljs-attr\">j</span>] = <span class=\"hljs-string\">str.charAt(j);</span>\r\n      }\r\n  }\r\n  //得到<span class=\"hljs-attr\">M</span>\r\n  <span class=\"hljs-attr\">int</span> <span class=\"hljs-attr\">M</span> = <span class=\"hljs-string\">input.nextInt();</span>\r\n  <span class=\"hljs-attr\">boolean</span>[] <span class=\"hljs-attr\">res</span> = <span class=\"hljs-string\">new</span> <span class=\"hljs-attr\">boolean</span>[<span class=\"hljs-attr\">M</span>];\r\n  <span class=\"hljs-attr\">for</span> (<span class=\"hljs-attr\">int</span> <span class=\"hljs-attr\">i</span> = <span class=\"hljs-string\">0;</span> <span class=\"hljs-attr\">i</span> &lt; <span class=\"hljs-attr\">M</span>; <span class=\"hljs-attr\">i</span>++) {\r\n      //得到坐标\r\n      <span class=\"hljs-attr\">int</span>[] <span class=\"hljs-attr\">points</span> = <span class=\"hljs-string\">new</span> <span class=\"hljs-attr\">int</span>[<span class=\"hljs-attr\">4</span>];\r\n      <span class=\"hljs-attr\">for</span> (<span class=\"hljs-attr\">int</span> <span class=\"hljs-attr\">j</span> = <span class=\"hljs-string\">0;</span> <span class=\"hljs-attr\">j</span> &lt; <span class=\"hljs-attr\">points.length</span>; <span class=\"hljs-attr\">j</span>++) {\r\n          <span class=\"hljs-attr\">points</span>[<span class=\"hljs-attr\">j</span>] = <span class=\"hljs-string\">input.nextInt();</span>\r\n      }\r\n      //得到结果\r\n      <span class=\"hljs-attr\">res</span>[<span class=\"hljs-attr\">i</span>] = <span class=\"hljs-string\">check(graph,</span> <span class=\"hljs-attr\">help</span>, <span class=\"hljs-attr\">points</span>);\r\n  }\r\n  //打印\r\n  <span class=\"hljs-attr\">for</span> (<span class=\"hljs-attr\">int</span> <span class=\"hljs-attr\">i</span> = <span class=\"hljs-string\">0;</span> <span class=\"hljs-attr\">i</span> &lt; <span class=\"hljs-attr\">res.length</span>; <span class=\"hljs-attr\">i</span>++) {\r\n      <span class=\"hljs-attr\">System.out.println</span>(<span class=\"hljs-attr\">res</span>[<span class=\"hljs-attr\">i</span>]);\r\n  }\r\n}\r\n/**\r\n* 两点是否连同\r\n* @<span class=\"hljs-attr\">param</span> <span class=\"hljs-attr\">graph</span> 图\r\n* @<span class=\"hljs-attr\">param</span> <span class=\"hljs-attr\">help</span> 标识节点是否访问\r\n* @<span class=\"hljs-attr\">param</span> <span class=\"hljs-attr\">points</span> 当前坐标和目标坐标\r\n* @<span class=\"hljs-attr\">return</span> \r\n*/\r\n<span class=\"hljs-attr\">public</span> <span class=\"hljs-attr\">static</span> <span class=\"hljs-attr\">boolean</span> <span class=\"hljs-attr\">check</span>(<span class=\"hljs-attr\">char</span>[][] <span class=\"hljs-attr\">graph</span>, <span class=\"hljs-attr\">int</span>[][] <span class=\"hljs-attr\">help</span>, <span class=\"hljs-attr\">int</span>[] <span class=\"hljs-attr\">points</span>){\r\n  //<span class=\"hljs-attr\">x1</span> <span class=\"hljs-attr\">y1</span> 为当前坐标\r\n  <span class=\"hljs-attr\">int</span> <span class=\"hljs-attr\">x1</span> = <span class=\"hljs-string\">points[0];</span>\r\n  <span class=\"hljs-attr\">int</span> <span class=\"hljs-attr\">y1</span> = <span class=\"hljs-string\">points[1];</span>\r\n  //<span class=\"hljs-attr\">x2</span> <span class=\"hljs-attr\">y2</span> 为目标坐标\r\n  <span class=\"hljs-attr\">int</span> <span class=\"hljs-attr\">x2</span> = <span class=\"hljs-string\">points[2];</span>\r\n  <span class=\"hljs-attr\">int</span> <span class=\"hljs-attr\">y2</span> = <span class=\"hljs-string\">points[3];</span>\r\n  //如果当前已经到达目标则返回\r\n  <span class=\"hljs-attr\">if</span> (<span class=\"hljs-attr\">x1</span> == <span class=\"hljs-string\">x2</span> &amp;&amp; <span class=\"hljs-attr\">y1</span> == <span class=\"hljs-string\">y2){</span>\r\n      <span class=\"hljs-attr\">return</span> <span class=\"hljs-attr\">true</span>;\r\n  }\r\n  <span class=\"hljs-attr\">boolean</span> <span class=\"hljs-attr\">f1</span> = <span class=\"hljs-string\">false;</span>\r\n  <span class=\"hljs-attr\">boolean</span> <span class=\"hljs-attr\">f2</span> = <span class=\"hljs-string\">false;</span>\r\n  <span class=\"hljs-attr\">boolean</span> <span class=\"hljs-attr\">f3</span> = <span class=\"hljs-string\">false;</span>\r\n  <span class=\"hljs-attr\">boolean</span> <span class=\"hljs-attr\">f4</span> = <span class=\"hljs-string\">false;</span>\r\n  //向左 不能越界 是否连同 是否走过 \r\n  <span class=\"hljs-attr\">if</span> (<span class=\"hljs-attr\">x1</span> <span class=\"hljs-attr\">-</span> <span class=\"hljs-attr\">1</span> &gt;</span></span>= 0 &amp;&amp; graph[<span class=\"hljs-string\">x1 - 1</span>][<span class=\"hljs-symbol\">y1</span>] == graph[<span class=\"hljs-string\">x1</span>][<span class=\"hljs-symbol\">y1</span>] &amp;&amp; help[<span class=\"hljs-string\">x1 - 1</span>][<span class=\"hljs-symbol\">y1</span>] == 0){\r\n<span class=\"hljs-code\">      //向左走</span>\r\n<span class=\"hljs-code\">      help[x1 - 1][y1] = 1;</span>\r\n<span class=\"hljs-code\">      points[0] -=1;</span>\r\n<span class=\"hljs-code\">      f1 = check(graph, help, points);</span>\r\n<span class=\"hljs-code\">      //回溯</span>\r\n<span class=\"hljs-code\">      help[x1 - 1][y1] = 0;</span>\r\n<span class=\"hljs-code\">      points[0] +=1;</span>\r\n  }\r\n  //向右\r\n  if (x1 + 1 <span class=\"xml\"><span class=\"hljs-tag\">&lt; <span class=\"hljs-attr\">graph.length</span> &amp;&amp; <span class=\"hljs-attr\">graph</span>[<span class=\"hljs-attr\">x1</span> + <span class=\"hljs-attr\">1</span>][<span class=\"hljs-attr\">y1</span>] == <span class=\"hljs-string\">graph[x1][y1]</span> &amp;&amp; <span class=\"hljs-attr\">help</span>[<span class=\"hljs-attr\">x1</span> + <span class=\"hljs-attr\">1</span>][<span class=\"hljs-attr\">y1</span>] == <span class=\"hljs-string\">0){</span>\r\n      //向右走\r\n      <span class=\"hljs-attr\">help</span>[<span class=\"hljs-attr\">x1</span> + <span class=\"hljs-attr\">1</span>][<span class=\"hljs-attr\">y1</span>] = <span class=\"hljs-string\">1;</span>\r\n      <span class=\"hljs-attr\">points</span>[<span class=\"hljs-attr\">0</span>] +=<span class=\"hljs-string\">1;</span>\r\n      <span class=\"hljs-attr\">f2</span> = <span class=\"hljs-string\">check(graph,</span> <span class=\"hljs-attr\">help</span>, <span class=\"hljs-attr\">points</span>);\r\n      //回溯\r\n      <span class=\"hljs-attr\">help</span>[<span class=\"hljs-attr\">x1</span> + <span class=\"hljs-attr\">1</span>][<span class=\"hljs-attr\">y1</span>] = <span class=\"hljs-string\">0;</span>\r\n      <span class=\"hljs-attr\">points</span>[<span class=\"hljs-attr\">0</span>] <span class=\"hljs-attr\">-</span>=<span class=\"hljs-string\">1;</span>\r\n  }\r\n  //向上\r\n  <span class=\"hljs-attr\">if</span> (<span class=\"hljs-attr\">y1</span> <span class=\"hljs-attr\">-</span> <span class=\"hljs-attr\">1</span> &gt;</span></span>= 0 &amp;&amp; graph[<span class=\"hljs-string\">x1</span>][<span class=\"hljs-symbol\">y1 - 1</span>] == graph[<span class=\"hljs-string\">x1</span>][<span class=\"hljs-symbol\">y1</span>] &amp;&amp; help[<span class=\"hljs-string\">x1</span>][<span class=\"hljs-symbol\">y1 - 1</span>] == 0){\r\n<span class=\"hljs-code\">      //向上走</span>\r\n<span class=\"hljs-code\">      help[x1][y1 - 1] = 1;</span>\r\n<span class=\"hljs-code\">      points[1] -=1;</span>\r\n<span class=\"hljs-code\">      f3 = check(graph, help, points);</span>\r\n<span class=\"hljs-code\">      //回溯</span>\r\n<span class=\"hljs-code\">      help[x1][y1 - 1] = 0;</span>\r\n<span class=\"hljs-code\">      points[1] +=1;</span>\r\n  }\r\n  //向下\r\n  if (y1 + 1 <span class=\"xml\"><span class=\"hljs-tag\">&lt; <span class=\"hljs-attr\">graph.length</span> &amp;&amp; <span class=\"hljs-attr\">graph</span>[<span class=\"hljs-attr\">x1</span>][<span class=\"hljs-attr\">y1</span> + <span class=\"hljs-attr\">1</span>] == <span class=\"hljs-string\">graph[x1][y1]</span> &amp;&amp; <span class=\"hljs-attr\">help</span>[<span class=\"hljs-attr\">x1</span>][<span class=\"hljs-attr\">y1</span> + <span class=\"hljs-attr\">1</span>] == <span class=\"hljs-string\">0){</span>\r\n      //向上走\r\n      <span class=\"hljs-attr\">help</span>[<span class=\"hljs-attr\">x1</span>][<span class=\"hljs-attr\">y1</span> + <span class=\"hljs-attr\">1</span>] = <span class=\"hljs-string\">1;</span>\r\n      <span class=\"hljs-attr\">points</span>[<span class=\"hljs-attr\">1</span>] +=<span class=\"hljs-string\">1;</span>\r\n      <span class=\"hljs-attr\">f4</span> = <span class=\"hljs-string\">check(graph,</span> <span class=\"hljs-attr\">help</span>, <span class=\"hljs-attr\">points</span>);\r\n      //回溯\r\n      <span class=\"hljs-attr\">help</span>[<span class=\"hljs-attr\">x1</span>][<span class=\"hljs-attr\">y1</span> + <span class=\"hljs-attr\">1</span>] = <span class=\"hljs-string\">0;</span>\r\n      <span class=\"hljs-attr\">points</span>[<span class=\"hljs-attr\">1</span>] <span class=\"hljs-attr\">-</span>=<span class=\"hljs-string\">1;</span>\r\n  }\r\n\r\n  <span class=\"hljs-attr\">return</span> <span class=\"hljs-attr\">f1</span> || <span class=\"hljs-attr\">f2</span> || <span class=\"hljs-attr\">f3</span> || <span class=\"hljs-attr\">f4</span>;\r\n}</span></span>\r\n</code></pre>\r\n</li>\r\n</ul>\r\n</li>\r\n<li><p>用DFS求连通块--种子填充(Flood Fill)</p>\r\n<ul>\r\n<li>输入一个m行n列的字符矩阵，统计字符“@”组成多少个八连块。</li>\r\n<li>如果两个字符“@”所在的格子相邻（横、竖或者对角线方向），就说它们属于同一个八连块。</li>\r\n<li><p>解：</p>\r\n<pre><code class=\"lang-java\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">main</span>(<span class=\"hljs-params\">String[] args</span>) </span>{\r\n  <span class=\"hljs-keyword\">char</span>[][] data = {\r\n            <span class=\"hljs-string\">\"*@@*@\"</span>.toCharArray(),\r\n            <span class=\"hljs-string\">\"**@*@\"</span>.toCharArray(),\r\n            <span class=\"hljs-string\">\"****@\"</span>.toCharArray(),\r\n            <span class=\"hljs-string\">\"@@@*@\"</span>.toCharArray(),\r\n            <span class=\"hljs-string\">\"@@@@@\"</span>.toCharArray(),\r\n        };\r\n  <span class=\"hljs-keyword\">int</span> count = <span class=\"hljs-number\">0</span>;\r\n  <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; data.length; i++) {\r\n      <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> j = <span class=\"hljs-number\">0</span>; j &lt; data.length; j++) {\r\n          <span class=\"hljs-keyword\">if</span> (data[i][j] != <span class=\"hljs-string\">\'*\'</span>){\r\n              dfs(data, i, j);\r\n              count++;\r\n          }\r\n      }\r\n  }\r\n\r\n  System.<span class=\"hljs-keyword\">out</span>.println(count);\r\n}\r\n\r\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">dfs</span>(<span class=\"hljs-params\"><span class=\"hljs-keyword\">char</span>[][] graph, <span class=\"hljs-keyword\">int</span> x, <span class=\"hljs-keyword\">int</span> y</span>)</span>{\r\n  <span class=\"hljs-comment\">//如果下标越界直接退出</span>\r\n  <span class=\"hljs-keyword\">if</span> (x &lt; <span class=\"hljs-number\">0</span> || x &gt;= graph.length || y &lt; <span class=\"hljs-number\">0</span> || y &gt;= graph[<span class=\"hljs-number\">0</span>].length){\r\n      <span class=\"hljs-keyword\">return</span>;\r\n  }\r\n  <span class=\"hljs-comment\">//如果已经访问过则退出</span>\r\n  <span class=\"hljs-keyword\">if</span> (graph[x][y] == <span class=\"hljs-string\">\'*\'</span>){\r\n      <span class=\"hljs-keyword\">return</span>;\r\n  }\r\n  <span class=\"hljs-comment\">//标记访问</span>\r\n  graph[x][y] = <span class=\"hljs-string\">\'*\'</span>;\r\n  <span class=\"hljs-comment\">//深搜</span>\r\n  dfs(graph, x - <span class=\"hljs-number\">1</span>, y);\r\n  dfs(graph, x + <span class=\"hljs-number\">1</span>, y);\r\n  dfs(graph, x, y - <span class=\"hljs-number\">1</span>);\r\n  dfs(graph, x, y + <span class=\"hljs-number\">1</span>);\r\n  dfs(graph, x - <span class=\"hljs-number\">1</span>, y - <span class=\"hljs-number\">1</span>);\r\n  dfs(graph, x - <span class=\"hljs-number\">1</span>, y + <span class=\"hljs-number\">1</span>);\r\n  dfs(graph, x + <span class=\"hljs-number\">1</span>, y - <span class=\"hljs-number\">1</span>);\r\n  dfs(graph, x + <span class=\"hljs-number\">1</span>, y + <span class=\"hljs-number\">1</span>);\r\n}\r\n</code></pre>\r\n</li>\r\n</ul>\r\n</li>\r\n<li><p>拓扑排序</p>\r\n</li>\r\n<li><p>拓扑排序:将DAG中的顶点以线性方式进行排序。即对于任何自顶点u到顶点v的有向边u-&gt;v ,在最后的排序结果中,顶点u总是<br>在顶点v的前面。这样的排序结果,称为拓扑序。有环图,不存在拓扑排序。</p>\r\n<pre><code class=\"lang-java\">  <span class=\"hljs-comment\">//顶点</span>\r\n  <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">char</span>[] v = {<span class=\"hljs-string\">\'a\'</span>, <span class=\"hljs-string\">\'b\'</span>, <span class=\"hljs-string\">\'c\'</span>, <span class=\"hljs-string\">\'d\'</span>, <span class=\"hljs-string\">\'e\'</span>};\r\n  <span class=\"hljs-comment\">//图</span>\r\n  <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">int</span>[][] graph = {\r\n          {<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">0</span>},\r\n          {<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>},\r\n          {<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">0</span>},\r\n          {<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">1</span>},\r\n          {<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>},\r\n  };\r\n  <span class=\"hljs-comment\">//记录顶点是否已访问</span>\r\n  <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">int</span>[] visited = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-keyword\">int</span>[v.length];\r\n  <span class=\"hljs-comment\">//拓扑排序结果</span>\r\n  <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">int</span>[] res = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-keyword\">int</span>[v.length];\r\n  <span class=\"hljs-comment\">//结果集下标</span>\r\n  <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">int</span> n = res.length - <span class=\"hljs-number\">1</span>;\r\n  <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">(String[] args)</span> </span>{\r\n      <span class=\"hljs-comment\">//对每个顶点进行dfs</span>\r\n      <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; v.length; i++) {\r\n          <span class=\"hljs-comment\">//如果顶点访问过则跳过</span>\r\n          <span class=\"hljs-keyword\">if</span> (visited[i] == <span class=\"hljs-number\">1</span>){\r\n              <span class=\"hljs-keyword\">continue</span>;\r\n          }\r\n          <span class=\"hljs-comment\">//判断有向图是否有环</span>\r\n          <span class=\"hljs-keyword\">boolean</span> f = dfs(i);\r\n          <span class=\"hljs-comment\">//有环则直接退出</span>\r\n          <span class=\"hljs-keyword\">if</span> (!f)    <span class=\"hljs-keyword\">return</span>;\r\n      }\r\n      <span class=\"hljs-comment\">//打印排序结果</span>\r\n      <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; visited.length; i++) {\r\n          System.out.println(v[res[i]]);\r\n      }\r\n  }\r\n\r\n  <span class=\"hljs-function\"><span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">boolean</span> <span class=\"hljs-title\">dfs</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> i)</span> </span>{\r\n      <span class=\"hljs-comment\">//标记节点正在访问</span>\r\n      visited[i] = -<span class=\"hljs-number\">1</span>;\r\n\r\n      <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> j = <span class=\"hljs-number\">0</span>; j &lt; graph.length; j++) {\r\n          <span class=\"hljs-comment\">//找到顶点i的出度顶点</span>\r\n          <span class=\"hljs-keyword\">if</span> (graph[i][j] == <span class=\"hljs-number\">1</span>){\r\n              <span class=\"hljs-comment\">//如果正在访问则证明有环 返回有环</span>\r\n              <span class=\"hljs-keyword\">if</span> (visited[j] == -<span class=\"hljs-number\">1</span>){\r\n                  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">false</span>;\r\n              }\r\n              <span class=\"hljs-comment\">//如果顶点未被访问</span>\r\n              <span class=\"hljs-keyword\">if</span> (visited[j] == <span class=\"hljs-number\">0</span>){\r\n                  <span class=\"hljs-comment\">//递归进行dfs</span>\r\n                  <span class=\"hljs-keyword\">boolean</span> t = dfs(j);\r\n                  <span class=\"hljs-keyword\">if</span> (!t){\r\n                      <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">false</span>;\r\n                  }\r\n              }\r\n          }\r\n      }\r\n      <span class=\"hljs-comment\">//标记顶点已访问</span>\r\n      visited[i] = <span class=\"hljs-number\">1</span>;\r\n      <span class=\"hljs-comment\">//加入排序结果集</span>\r\n      res[n--] = i;\r\n      <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">true</span>;\r\n  }\r\n</code></pre>\r\n</li>\r\n<li><p>欧拉道路与七桥问题</p>\r\n</li>\r\n<li><p>柯尼斯堡七桥问题( Seven Bridges of Konigsberg )是图论中的著名问题。这个问题是基于一个现实生活中的事例:当时东普鲁士<br>柯尼斯堡(今日俄罗斯加里宁格勒)市区跨普列戈利亚河两岸,河中心有两个小岛。小岛与河的两岸有七条桥连接。在所有桥都只能<br>走一遍的前提下,如何才能把这个地方所有的桥都走遍? </p>\r\n</li>\r\n<li><p>能否从无向图中的一个结点出发走出一条道路,每条边恰好经过一次，这样的路线称为欧拉道路(一笔画)。</p>\r\n</li>\r\n<li><p>如果一个无向图是连通的,且最多只有两个奇点(度数为奇数) ,则一定存在欧拉道路</p>\r\n</li>\r\n<li>如果有两个奇点,它们必须是起点和终点</li>\r\n<li>如果奇点不存在,可以从任意点出发,最终一-定会回到该点 ,称为欧拉回路</li>\r\n<li><p>对于有向图,欧拉道路存在的充要条件是:最多只能有两个点的入度不等于出度，而且必须是其中一个点的出度恰好比入度大1 (起<br>点) ,另一个的入度比出度大1 (终点)</p>\r\n<pre><code class=\"lang-java\">  <span class=\"hljs-comment\">//顶点</span>\r\n  <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">char</span>[] v = {<span class=\"hljs-string\">\'a\'</span>, <span class=\"hljs-string\">\'b\'</span>, <span class=\"hljs-string\">\'c\'</span>, <span class=\"hljs-string\">\'d\'</span>};\r\n  <span class=\"hljs-comment\">//图</span>\r\n  <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">int</span>[][] graph = {\r\n          {<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">1</span>},\r\n          {<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>},\r\n          {<span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">1</span>},\r\n          {<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">0</span>},\r\n  };\r\n  <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">int</span>[][] visited = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-keyword\">int</span>[<span class=\"hljs-number\">4</span>][<span class=\"hljs-number\">4</span>];\r\n  <span class=\"hljs-comment\">//记录路径</span>\r\n  <span class=\"hljs-keyword\">static</span> Stack&lt;String&gt; path = <span class=\"hljs-keyword\">new</span> Stack&lt;&gt;();\r\n  <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">main</span>(<span class=\"hljs-params\">String[] args</span>) </span>{\r\n      <span class=\"hljs-comment\">//从奇数点开始</span>\r\n      dfs(<span class=\"hljs-number\">2</span>);\r\n      <span class=\"hljs-comment\">//打印路径</span>\r\n      <span class=\"hljs-keyword\">while</span> (!path.isEmpty()){\r\n          System.<span class=\"hljs-keyword\">out</span>.println(path.pop());\r\n      }\r\n  }\r\n  <span class=\"hljs-function\"><span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">dfs</span>(<span class=\"hljs-params\"><span class=\"hljs-keyword\">int</span> i</span>) </span>{\r\n      <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> j = <span class=\"hljs-number\">0</span>; j &lt; graph.length; j++) {\r\n          <span class=\"hljs-comment\">//如果i-j之间有道路 且走过的次数小于道路树</span>\r\n          <span class=\"hljs-keyword\">if</span> (graph[i][j] &gt; <span class=\"hljs-number\">0</span> &amp;&amp; visited[i][j] &lt; graph[i][j]){\r\n              <span class=\"hljs-comment\">//记录访问过的道路</span>\r\n              visited[i][j]++;\r\n              visited[j][i]++;\r\n              <span class=\"hljs-comment\">//从j点开始</span>\r\n              dfs(j);\r\n              <span class=\"hljs-comment\">//这里添加路径放在递归之后是因为</span>\r\n              <span class=\"hljs-comment\">//只有走到底才能知道这条路径可不可行</span>\r\n              <span class=\"hljs-comment\">//所以在调用栈弹出之前添加路径</span>\r\n              path.push(v[i] + <span class=\"hljs-string\">\"--&gt;\"</span> + v[j]);\r\n          }\r\n      }\r\n  }\r\n</code></pre>\r\n</li>\r\n<li><p>二分图-&gt;图的着色问题</p>\r\n</li>\r\n<li><p>给定一一个具有n个顶点的图,要给图上每个顶点染色,并且要使相邻的顶点的颜色不同、问是否最多用2种颜色进行染色?没有重边<br>和自环。</p>\r\n</li>\r\n<li>把相邻顶点染成不同颜色的问题叫做图的着色问题。</li>\r\n<li><p>对图进行染色所需的最小颜色数,称为最小着色数。最小着色数为2的图称为二分图。</p>\r\n<pre><code class=\"lang-java\">  <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">main</span>(<span class=\"hljs-params\">String[] args</span>) </span>{\r\n      GraphNode n1 = <span class=\"hljs-keyword\">new</span> GraphNode(<span class=\"hljs-number\">1</span>);\r\n      GraphNode n2 = <span class=\"hljs-keyword\">new</span> GraphNode(<span class=\"hljs-number\">2</span>);\r\n      GraphNode n3 = <span class=\"hljs-keyword\">new</span> GraphNode(<span class=\"hljs-number\">3</span>);\r\n      GraphNode n4 = <span class=\"hljs-keyword\">new</span> GraphNode(<span class=\"hljs-number\">4</span>);\r\n\r\n      n1.neighbor.<span class=\"hljs-keyword\">add</span>(n2);\r\n      n1.neighbor.<span class=\"hljs-keyword\">add</span>(n4);\r\n\r\n      n2.neighbor.<span class=\"hljs-keyword\">add</span>(n3);\r\n      n2.neighbor.<span class=\"hljs-keyword\">add</span>(n1);\r\n\r\n      n3.neighbor.<span class=\"hljs-keyword\">add</span>(n2);\r\n      n3.neighbor.<span class=\"hljs-keyword\">add</span>(n4);\r\n\r\n      n4.neighbor.<span class=\"hljs-keyword\">add</span>(n1);\r\n      n4.neighbor.<span class=\"hljs-keyword\">add</span>(n3);\r\n\r\n      System.<span class=\"hljs-keyword\">out</span>.println(dfs(n1, <span class=\"hljs-number\">1</span>));\r\n  }\r\n  <span class=\"hljs-comment\">//判断是否为二分图</span>\r\n  <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> boolean <span class=\"hljs-title\">dfs</span>(<span class=\"hljs-params\">GraphNode node, <span class=\"hljs-keyword\">int</span> color</span>)</span>{\r\n      <span class=\"hljs-comment\">//顶点染色</span>\r\n      node.color = color;\r\n      <span class=\"hljs-comment\">//遍历邻居</span>\r\n      <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; node.neighbor.size(); i++) {\r\n          GraphNode neighbor = node.neighbor.<span class=\"hljs-keyword\">get</span>(i);\r\n          <span class=\"hljs-comment\">//如果和邻居颜色冲突则直接返回</span>\r\n          <span class=\"hljs-keyword\">if</span> (neighbor.color == color){\r\n              <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span>;\r\n          }\r\n          <span class=\"hljs-comment\">//如果邻居没有染色</span>\r\n          <span class=\"hljs-keyword\">if</span> (neighbor.color == <span class=\"hljs-number\">0</span>){\r\n              <span class=\"hljs-comment\">//给邻居染色</span>\r\n              boolean f = dfs(neighbor, -color);\r\n              <span class=\"hljs-keyword\">if</span> (!f){\r\n                  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span>;\r\n              }\r\n          }\r\n      }\r\n\r\n      <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span>;\r\n  }\r\n</code></pre>\r\n</li>\r\n<li><p>最小生成树</p>\r\n</li>\r\n<li><p>连通图去一条边就是树</p>\r\n</li>\r\n<li>所有生成树中边的权重和最小的，称之为最小生成树( Minimal Spanning Tree )</li>\r\n<li><p>常用于网络构建等建设性问题的优化</p>\r\n</li>\r\n<li><p>并查集(Union Find)<br>并查集，在一些有N个元素的集合应用问题中，我们通常是在开始时让每个元素构成一个单元素的集合，然后按一定顺序将属于同一组的元素所在的集合合并，其间要反复查找一个元素在哪个集合中。<br>并查集是一种树型的数据结构，用于处理一些不相交集合（Disjoint Sets）的合并及查询问题。常常在使用中以森林来表示。</p>\r\n</li>\r\n<li><p>Edge List</p>\r\n</li>\r\n</ol>\r\n<pre><code class=\"lang-java\"><span class=\"hljs-comment\">/**\r\n * 边集数组 edge list\r\n * <span class=\"hljs-doctag\">@author</span> 96047\r\n *\r\n */</span>\r\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Edge</span>&lt;<span class=\"hljs-title\">T</span>&gt; <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title\">Comparable</span>&lt;<span class=\"hljs-title\">Edge</span>&lt;<span class=\"hljs-title\">T</span>&gt;&gt; </span>{\r\n    <span class=\"hljs-comment\">//起始顶点</span>\r\n    <span class=\"hljs-keyword\">private</span> T start;\r\n    <span class=\"hljs-comment\">//结束顶点</span>\r\n    <span class=\"hljs-keyword\">private</span> T end;\r\n    <span class=\"hljs-comment\">//距离</span>\r\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">int</span> distance;\r\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-title\">Edge</span><span class=\"hljs-params\">(T start, T end, <span class=\"hljs-keyword\">int</span> distance)</span> </span>{\r\n        <span class=\"hljs-keyword\">super</span>();\r\n        <span class=\"hljs-keyword\">this</span>.start = start;\r\n        <span class=\"hljs-keyword\">this</span>.end = end;\r\n        <span class=\"hljs-keyword\">this</span>.distance = distance;\r\n    }\r\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-title\">Edge</span><span class=\"hljs-params\">()</span> </span>{\r\n    }\r\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> T <span class=\"hljs-title\">getStart</span><span class=\"hljs-params\">()</span> </span>{\r\n        <span class=\"hljs-keyword\">return</span> start;\r\n    }\r\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">setStart</span><span class=\"hljs-params\">(T start)</span> </span>{\r\n        <span class=\"hljs-keyword\">this</span>.start = start;\r\n    }\r\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> T <span class=\"hljs-title\">getEnd</span><span class=\"hljs-params\">()</span> </span>{\r\n        <span class=\"hljs-keyword\">return</span> end;\r\n    }\r\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">setEnd</span><span class=\"hljs-params\">(T end)</span> </span>{\r\n        <span class=\"hljs-keyword\">this</span>.end = end;\r\n    }\r\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">getDistance</span><span class=\"hljs-params\">()</span> </span>{\r\n        <span class=\"hljs-keyword\">return</span> distance;\r\n    }\r\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">setDistance</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> distance)</span> </span>{\r\n        <span class=\"hljs-keyword\">this</span>.distance = distance;\r\n    }\r\n    <span class=\"hljs-meta\">@Override</span>\r\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> String <span class=\"hljs-title\">toString</span><span class=\"hljs-params\">()</span> </span>{\r\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">\"Edge [start=\"</span> + start + <span class=\"hljs-string\">\", end=\"</span> + end + <span class=\"hljs-string\">\", distance=\"</span> + distance + <span class=\"hljs-string\">\"]\"</span>;\r\n    }\r\n    <span class=\"hljs-meta\">@Override</span>\r\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">compareTo</span><span class=\"hljs-params\">(Edge&lt;T&gt; o)</span> </span>{\r\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">this</span>.distance - o.distance;\r\n    }\r\n}\r\n</code></pre>\r\n<ul>\r\n<li>并查集</li>\r\n</ul>\r\n<pre><code class=\"lang-java\"><span class=\"hljs-comment\">/**\r\n * 并查集\r\n * @author 96047\r\n *\r\n */</span>\r\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">UnionFind</span> {\r\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">union</span>(<span class=\"hljs-params\">UFNode x, UFNode y</span>)</span>{\r\n        find(y).parent = find(x);\r\n    }\r\n\r\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> UFNode <span class=\"hljs-title\">find</span>(<span class=\"hljs-params\">UFNode x</span>)</span>{\r\n        UFNode p = x;\r\n        Set&lt;UFNode&gt; <span class=\"hljs-keyword\">set</span> = <span class=\"hljs-keyword\">new</span> HashSet&lt;&gt;();\r\n        <span class=\"hljs-comment\">//向上找到根节点</span>\r\n        <span class=\"hljs-keyword\">while</span> (p.parent != <span class=\"hljs-literal\">null</span>){\r\n            <span class=\"hljs-keyword\">set</span>.<span class=\"hljs-keyword\">add</span>(p);\r\n            p = p.parent;\r\n        }\r\n        <span class=\"hljs-comment\">//所有节点并入到根节点</span>\r\n        <span class=\"hljs-keyword\">for</span> (UFNode uf: <span class=\"hljs-keyword\">set</span>){\r\n            uf.parent = p;\r\n        }\r\n\r\n        <span class=\"hljs-keyword\">return</span> p;\r\n    }\r\n}\r\n\r\n<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">UFNode</span>{\r\n    UFNode parent;\r\n}\r\n</code></pre>\r\n<ul>\r\n<li>kurskal</li>\r\n</ul>\r\n<pre><code class=\"lang-java\"><span class=\"hljs-comment\">/**\r\n * 最小生成树-克鲁兹卡尔\r\n * @author 96047\r\n *\r\n */</span>\r\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Kurskal</span> {\r\n    <span class=\"hljs-comment\">//边集</span>\r\n    <span class=\"hljs-keyword\">private</span> List&lt;Edge&lt;String&gt;&gt; lists;\r\n    <span class=\"hljs-comment\">//顶点总数</span>\r\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">int</span> n;\r\n    <span class=\"hljs-comment\">//边和并查集的映射</span>\r\n    Map&lt;String, UFNode&gt; edgeAndUF = <span class=\"hljs-keyword\">new</span> HashMap&lt;&gt;();\r\n    <span class=\"hljs-comment\">//最小生成树集合</span>\r\n    Set&lt;Edge&lt;String&gt;&gt; T = <span class=\"hljs-keyword\">new</span> HashSet&lt;&gt;();\r\n\r\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-title\">Kurskal</span>(<span class=\"hljs-params\">List&lt;Edge&lt;String&gt;&gt; lists, <span class=\"hljs-keyword\">int</span> n</span>) </span>{\r\n        super();\r\n        <span class=\"hljs-keyword\">this</span>.lists = lists;\r\n        <span class=\"hljs-keyword\">this</span>.n = n;\r\n        <span class=\"hljs-comment\">//按照顶点初始化并查集</span>\r\n        <span class=\"hljs-keyword\">for</span> (Edge&lt;String&gt; edge : lists) {\r\n            String start = edge.getStart();\r\n            String end = edge.getEnd();\r\n            edgeAndUF.put(start, <span class=\"hljs-keyword\">new</span> UFNode());\r\n            edgeAndUF.put(end, <span class=\"hljs-keyword\">new</span> UFNode());\r\n        }\r\n    }\r\n\r\n    <span class=\"hljs-keyword\">public</span> Set&lt;Edge&lt;String&gt;&gt; getT(){\r\n        <span class=\"hljs-comment\">//对边集排序</span>\r\n        Collections.sort(lists);\r\n        <span class=\"hljs-keyword\">for</span> (Edge&lt;String&gt; edge : lists) {\r\n            String start = edge.getStart();\r\n            String end = edge.getEnd();\r\n            <span class=\"hljs-comment\">//如果两个点在同一个集合</span>\r\n            <span class=\"hljs-keyword\">if</span> (UnionFind.find(edgeAndUF.<span class=\"hljs-keyword\">get</span>(start)).<span class=\"hljs-keyword\">equals</span>(UnionFind.find(edgeAndUF.<span class=\"hljs-keyword\">get</span>(end)))){\r\n                <span class=\"hljs-comment\">//跳过这条边</span>\r\n                <span class=\"hljs-keyword\">continue</span>;\r\n            }<span class=\"hljs-keyword\">else</span>{\r\n                <span class=\"hljs-comment\">//选中这条边</span>\r\n                T.<span class=\"hljs-keyword\">add</span>(edge);\r\n                <span class=\"hljs-comment\">//将边中顶点并入集合</span>\r\n                UnionFind.union(edgeAndUF.<span class=\"hljs-keyword\">get</span>(start), edgeAndUF.<span class=\"hljs-keyword\">get</span>(end));\r\n            }\r\n            <span class=\"hljs-comment\">//判断mst是否已经生成</span>\r\n            <span class=\"hljs-keyword\">if</span> (T.size() == n - <span class=\"hljs-number\">1</span>){\r\n                <span class=\"hljs-keyword\">break</span>;\r\n            }\r\n        }\r\n\r\n        <span class=\"hljs-keyword\">return</span> T;\r\n    }\r\n\r\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">main</span>(<span class=\"hljs-params\">String[] args</span>) </span>{\r\n        List&lt;Edge&lt;String&gt;&gt; l = <span class=\"hljs-keyword\">new</span> ArrayList&lt;&gt;();\r\n        l.<span class=\"hljs-keyword\">add</span>(<span class=\"hljs-keyword\">new</span> Edge&lt;String&gt;(<span class=\"hljs-string\">\"C\"</span>, <span class=\"hljs-string\">\"D\"</span>, <span class=\"hljs-number\">1</span>));\r\n        l.<span class=\"hljs-keyword\">add</span>(<span class=\"hljs-keyword\">new</span> Edge&lt;String&gt;(<span class=\"hljs-string\">\"C\"</span>, <span class=\"hljs-string\">\"A\"</span>, <span class=\"hljs-number\">1</span>));\r\n        l.<span class=\"hljs-keyword\">add</span>(<span class=\"hljs-keyword\">new</span> Edge&lt;String&gt;(<span class=\"hljs-string\">\"C\"</span>, <span class=\"hljs-string\">\"E\"</span>, <span class=\"hljs-number\">8</span>));\r\n        l.<span class=\"hljs-keyword\">add</span>(<span class=\"hljs-keyword\">new</span> Edge&lt;String&gt;(<span class=\"hljs-string\">\"A\"</span>, <span class=\"hljs-string\">\"B\"</span>, <span class=\"hljs-number\">3</span>));\r\n        l.<span class=\"hljs-keyword\">add</span>(<span class=\"hljs-keyword\">new</span> Edge&lt;String&gt;(<span class=\"hljs-string\">\"D\"</span>, <span class=\"hljs-string\">\"E\"</span>, <span class=\"hljs-number\">3</span>));\r\n        l.<span class=\"hljs-keyword\">add</span>(<span class=\"hljs-keyword\">new</span> Edge&lt;String&gt;(<span class=\"hljs-string\">\"B\"</span>, <span class=\"hljs-string\">\"C\"</span>, <span class=\"hljs-number\">5</span>));\r\n        l.<span class=\"hljs-keyword\">add</span>(<span class=\"hljs-keyword\">new</span> Edge&lt;String&gt;(<span class=\"hljs-string\">\"B\"</span>, <span class=\"hljs-string\">\"E\"</span>, <span class=\"hljs-number\">6</span>));\r\n        l.<span class=\"hljs-keyword\">add</span>(<span class=\"hljs-keyword\">new</span> Edge&lt;String&gt;(<span class=\"hljs-string\">\"B\"</span>, <span class=\"hljs-string\">\"D\"</span>, <span class=\"hljs-number\">7</span>));\r\n        l.<span class=\"hljs-keyword\">add</span>(<span class=\"hljs-keyword\">new</span> Edge&lt;String&gt;(<span class=\"hljs-string\">\"A\"</span>, <span class=\"hljs-string\">\"D\"</span>, <span class=\"hljs-number\">2</span>));\r\n        l.<span class=\"hljs-keyword\">add</span>(<span class=\"hljs-keyword\">new</span> Edge&lt;String&gt;(<span class=\"hljs-string\">\"A\"</span>, <span class=\"hljs-string\">\"E\"</span>, <span class=\"hljs-number\">9</span>));\r\n\r\n        Kurskal kurskal = <span class=\"hljs-keyword\">new</span> Kurskal(l, <span class=\"hljs-number\">5</span>);\r\n        System.<span class=\"hljs-keyword\">out</span>.println(kurskal.getT());\r\n    }\r\n}\r\n</code></pre>\r\n<h3 id=\"bfs-\">bfs及相关问题</h3>\r\n<h4 id=\"-\">最短路径问题</h4>\r\n<ul>\r\n<li>最短路径：给定两个顶点,在以这两个点为起点和终点的路径中,边的权值和最小的路径。考虑权值为点之间的距离。单源最短路问题</li>\r\n</ul>\r\n<h5 id=\"bellman-ford-\">Bellman-Ford算法</h5>\r\n<p><code>记从起点s出发到顶点的最短距离为d[i]。则下述等式成立。\r\nd[i]=min {d[j]+(从j到i的边的权值)e=(j,i)∈E}\r\n如果给定的图是一个DAG， 就可以按拓扑序给顶点编号，并利用用这条递推关系式计算出d。但\r\n是，如果图中有圈，就无法依赖这样的顺序进行计算。在这种情况下，记当前到顶点的最短路\r\n长度为d[i]，并设初值a[s]=0, d[i]=INF ( 足够大的常数)，再不断使用这条递推关系式更新d的值，\r\n就可以算出新的d。只要图中不存在负圈，这样的更新操作就是有限的。结束之后的d就是所求的\r\n最短距离了。</code></p>\r\n<ul>\r\n<li>总结：有e(i, j)边 如果d[i]可达 有d[j] = min(d[j], d[j] + |e(i, j)|)</li>\r\n</ul>\r\n<pre><code class=\"lang-java\"><span class=\"hljs-comment\">/**\r\n* 源点s到各顶点的最短路径\r\n* @param s 起点\r\n* @return\r\n*/</span>\r\n<span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">int</span>[][] graph = {\r\n            {<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">5</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>},\r\n            {<span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">6</span>, <span class=\"hljs-number\">10</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>},\r\n            {<span class=\"hljs-number\">5</span>, <span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>},\r\n            {<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">6</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">0</span>},\r\n            {<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">10</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">5</span>},\r\n            {<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">9</span>},\r\n            {<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">5</span>, <span class=\"hljs-number\">9</span>, <span class=\"hljs-number\">0</span>}\r\n        };\r\n\r\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">int</span>[] <span class=\"hljs-title\">shortestPath</span>(<span class=\"hljs-params\"><span class=\"hljs-keyword\">int</span> s</span>)</span>{\r\n    <span class=\"hljs-comment\">//s到各顶点距离</span>\r\n    <span class=\"hljs-keyword\">int</span>[] d = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-keyword\">int</span>[graph.length];\r\n    <span class=\"hljs-comment\">//到自己距离为0</span>\r\n    d[s] = <span class=\"hljs-number\">0</span>;\r\n    <span class=\"hljs-comment\">//到其他顶点距离初始化为无穷大</span>\r\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">1</span>; i &lt; d.length; i++) {\r\n        d[i] = Integer.MAX_VALUE;\r\n    }\r\n\r\n    <span class=\"hljs-keyword\">while</span> (<span class=\"hljs-literal\">true</span>){\r\n        boolean update = <span class=\"hljs-literal\">false</span>;\r\n        <span class=\"hljs-comment\">//到i点的距离</span>\r\n        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; graph.length; i++) {\r\n            <span class=\"hljs-comment\">//如果s-i距离未算出 则直接跳过</span>\r\n            <span class=\"hljs-keyword\">if</span> (d[i] == Integer.MAX_VALUE){\r\n                <span class=\"hljs-keyword\">continue</span>;\r\n            }\r\n            <span class=\"hljs-comment\">//i--j</span>\r\n            <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> j = <span class=\"hljs-number\">0</span>; j &lt; graph.length; j++) {\r\n                <span class=\"hljs-comment\">//如果i--j点有边</span>\r\n                <span class=\"hljs-keyword\">if</span> (graph[i][j] &gt; <span class=\"hljs-number\">0</span>){\r\n                    <span class=\"hljs-keyword\">int</span> cost = graph[i][j];\r\n                    <span class=\"hljs-comment\">//判断从s-i-j的距离是否小于s-j的距离</span>\r\n                    <span class=\"hljs-keyword\">if</span> (d[i] + cost &lt; d[j]){\r\n                        <span class=\"hljs-comment\">//如果小于则更新距离</span>\r\n                        d[j] = d[i] + cost;\r\n                        <span class=\"hljs-comment\">//设置更新状态</span>\r\n                        update = <span class=\"hljs-literal\">true</span>;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        <span class=\"hljs-comment\">//如果</span>\r\n        <span class=\"hljs-keyword\">if</span> (!update)    <span class=\"hljs-keyword\">break</span>;\r\n    }\r\n\r\n    <span class=\"hljs-keyword\">return</span> d;\r\n}\r\n\r\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">main</span>(<span class=\"hljs-params\">String[] args</span>) </span>{\r\n    System.<span class=\"hljs-keyword\">out</span>.println(Arrays.toString(shortestPath(<span class=\"hljs-number\">0</span>)));\r\n}\r\n</code></pre>\r\n<ul>\r\n<li>优化：使用edge list结构减少循环次数，复杂度为O(|V|*|E|)</li>\r\n</ul>\r\n<pre><code class=\"lang-java\"><span class=\"hljs-comment\">/**\r\n* 源点s到各顶点的最短路径\r\n* @param s 起点\r\n* @return\r\n*/</span>\r\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">int</span>[] shortestPath(<span class=\"hljs-keyword\">int</span> s){\r\n    <span class=\"hljs-comment\">//s到各顶点距离</span>\r\n    <span class=\"hljs-keyword\">int</span>[] d = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-keyword\">int</span>[graph.length];\r\n    <span class=\"hljs-comment\">//到自己距离为0</span>\r\n    d[s] = <span class=\"hljs-number\">0</span>;\r\n    <span class=\"hljs-comment\">//到其他顶点距离初始化为无穷大</span>\r\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">1</span>; i &lt; d.length; i++) {\r\n        d[i] = Integer.MAX_VALUE;\r\n    }\r\n    List&lt;Edge&lt;Integer&gt;&gt; <span class=\"hljs-built_in\">list</span> = getEdges(graph);\r\n    <span class=\"hljs-comment\">//更新距离</span>\r\n    <span class=\"hljs-keyword\">while</span> (<span class=\"hljs-literal\">true</span>){\r\n        boolean update = <span class=\"hljs-literal\">false</span>;\r\n        <span class=\"hljs-comment\">//遍历边集</span>\r\n        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; <span class=\"hljs-built_in\">list</span>.size(); i++) {\r\n            Edge&lt;Integer&gt; edge = <span class=\"hljs-built_in\">list</span>.get(i);\r\n            <span class=\"hljs-keyword\">int</span> j = edge.getStart();\r\n            <span class=\"hljs-keyword\">int</span> k = edge.getEnd();\r\n            <span class=\"hljs-keyword\">int</span> cost = edge.getDistance();\r\n            <span class=\"hljs-comment\">//如果到j的距离未更新则直接跳过</span>\r\n            <span class=\"hljs-keyword\">if</span> (d[j] == Integer.MAX_VALUE){\r\n                <span class=\"hljs-keyword\">continue</span>;\r\n            }\r\n            <span class=\"hljs-comment\">//如果s-j-k&lt;s-k</span>\r\n            <span class=\"hljs-keyword\">if</span> (d[j] + cost &lt; d[k]){\r\n                <span class=\"hljs-comment\">//更新到k的距离</span>\r\n                d[k] = d[j] + cost;\r\n                update = <span class=\"hljs-literal\">true</span>;\r\n            }\r\n        }\r\n        <span class=\"hljs-comment\">//如果遍历边集后未更新距离则退出</span>\r\n        <span class=\"hljs-keyword\">if</span> (!update)    <span class=\"hljs-keyword\">break</span>;\r\n    }\r\n\r\n    <span class=\"hljs-keyword\">return</span> d;\r\n}\r\n\r\n<span class=\"hljs-comment\">/**\r\n    * 将邻接矩阵转换为edge list\r\n    * @param graph\r\n    * @return\r\n    */</span>\r\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> List&lt;Edge&lt;Integer&gt;&gt; getEdges(<span class=\"hljs-keyword\">int</span>[][] graph){\r\n    List&lt;Edge&lt;Integer&gt;&gt; <span class=\"hljs-built_in\">list</span> = <span class=\"hljs-keyword\">new</span> ArrayList&lt;Edge&lt;Integer&gt;&gt;();\r\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; graph.length; i++) {\r\n        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> j = <span class=\"hljs-number\">0</span>; j &lt; graph.length; j++) {\r\n            <span class=\"hljs-keyword\">if</span> (graph[i][j] &gt; <span class=\"hljs-number\">0</span>){\r\n                <span class=\"hljs-built_in\">list</span>.add(<span class=\"hljs-keyword\">new</span> Edge&lt;&gt;(i, j, graph[i][j]));\r\n            }\r\n        }\r\n    }\r\n\r\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">list</span>;\r\n}\r\n\r\n<span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">int</span>[][] graph = {\r\n            {<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">5</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>},\r\n            {<span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">6</span>, <span class=\"hljs-number\">10</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>},\r\n            {<span class=\"hljs-number\">5</span>, <span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>},\r\n            {<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">6</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">0</span>},\r\n            {<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">10</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">5</span>},\r\n            {<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">9</span>},\r\n            {<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">5</span>, <span class=\"hljs-number\">9</span>, <span class=\"hljs-number\">0</span>}\r\n        };\r\n\r\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">(String[] args)</span> </span>{\r\n    System.out.println(Arrays.toString(shortestPath(<span class=\"hljs-number\">0</span>)));\r\n}\r\n</code></pre>\r\n<ul>\r\n<li>如果在图中不存在从s可达的的负圈,那么最短路不会经过同一个顶点两次(也就是说，最多通过IV-1条边), while(true)的循环最多执行|V|-1次， 因此，复杂度是O(|V|x|E|)。反之，如果存在从s可达的负圈，那么在第|V|次循环中也会更新d的值，因此也可以用这个性质来检查负圈。如果一开始对所有的顶点i,都把的d[j]初始化为0，那么可以检查出所有的负圈。</li>\r\n</ul>\r\n<pre><code class=\"lang-java\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">static</span> boolean <span class=\"hljs-title\">findNagativeLoop</span>(<span class=\"hljs-params\">List&lt;Edge&gt; edges</span>)</span>{\r\n    <span class=\"hljs-keyword\">int</span>[] d = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-keyword\">int</span>[graph.length];\r\n\r\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; graph.length; i++) {\r\n        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> j = <span class=\"hljs-number\">0</span>; j &lt; edges.size(); j++) {\r\n            Edge e = edges.<span class=\"hljs-keyword\">get</span>(j);\r\n            <span class=\"hljs-keyword\">if</span> (d[e.end] &gt; d[e.start] + e.cost){\r\n                d[e.end] = d[e.start] + e.cost;\r\n\r\n                <span class=\"hljs-keyword\">if</span> (i == graph.length - <span class=\"hljs-number\">1</span>)    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span>;\r\n            }\r\n        }\r\n    }\r\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span>;\r\n}\r\n</code></pre>\r\n<h5 id=\"dijkstra-\">Dijkstra算法</h5>\r\n<p><code>让我们考虑一- 下没有负边的情况。在Bellman-Ford算法中，如果d[i]还不是最短距离的话,那么即\r\n使进行dj]=d[j]+(从i到j的边的权值)的更新，d[j]也不会 变成最短距离。而且，即使d[i]没有变化，\r\n每一次循环也要检查- -遍 从出发的所有边。这显然是很浪费时间的。因此可以对算法做如下修改。\r\n(1)找到最短距离已经确定的顶点，从它出发更新相邻顶点的最短距离。\r\n(2)此后不需要再关心1中的“最短距离已经确定的顶点”。\r\n在(1)和(2)中提到的“最短距离已经确定的顶点”要怎么得到是问题的关键。在最开始时，只有\r\n起点的最短距离是确定的。而在尚未使用过的顶点中，距离a[i]最小的顶点就是最短距离已经确\r\n定的顶点。这是因为由于不存在负边，所以d[i]不会在之后的更新中变小。这个算法叫做Djkstra\r\n算法。</code></p>\r\n<pre><code class=\"lang-java\"><span class=\"hljs-comment\">//这里特指从A到其他点的最短路径</span>\r\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">main</span>(<span class=\"hljs-params\">String[] args</span>) </span>{\r\n    <span class=\"hljs-keyword\">char</span>[] v = {<span class=\"hljs-string\">\'A\'</span>, <span class=\"hljs-string\">\'B\'</span>, <span class=\"hljs-string\">\'C\'</span>, <span class=\"hljs-string\">\'D\'</span>, <span class=\"hljs-string\">\'E\'</span>, <span class=\"hljs-string\">\'F\'</span>, <span class=\"hljs-string\">\'G\'</span>};\r\n    <span class=\"hljs-keyword\">int</span>[][] graph = {\r\n                {<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">5</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>},\r\n                {<span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">6</span>, <span class=\"hljs-number\">10</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>},\r\n                {<span class=\"hljs-number\">5</span>, <span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>},\r\n                {<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">6</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">0</span>},\r\n                {<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">10</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">5</span>},\r\n                {<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">9</span>},\r\n                {<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">5</span>, <span class=\"hljs-number\">9</span>, <span class=\"hljs-number\">0</span>}\r\n    };\r\n\r\n    <span class=\"hljs-comment\">//清除所有点的标记</span>\r\n    <span class=\"hljs-keyword\">int</span>[] f = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-keyword\">int</span>[v.length];\r\n    <span class=\"hljs-comment\">//\"父亲指针\"</span>\r\n    <span class=\"hljs-keyword\">int</span>[] fa = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-keyword\">int</span>[v.length];\r\n    <span class=\"hljs-comment\">//设d[0]=0,其他未inf</span>\r\n    <span class=\"hljs-keyword\">int</span>[] d = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-keyword\">int</span>[v.length];\r\n    d[<span class=\"hljs-number\">0</span>] = <span class=\"hljs-number\">0</span>;\r\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">1</span>; i &lt; d.length; i++) {\r\n        d[i] = Integer.MAX_VALUE;\r\n    }\r\n    <span class=\"hljs-comment\">//记录已经找到最短路径的点</span>\r\n    Set&lt;Integer&gt; <span class=\"hljs-keyword\">set</span> = <span class=\"hljs-keyword\">new</span> HashSet&lt;&gt;();\r\n    <span class=\"hljs-keyword\">int</span> count = <span class=\"hljs-number\">0</span>;\r\n    <span class=\"hljs-comment\">//循环n次</span>\r\n    <span class=\"hljs-keyword\">while</span> (<span class=\"hljs-keyword\">set</span>.size() &lt; v.length){\r\n        <span class=\"hljs-comment\">//在所有未标号节点中，选出d值最小的节点x</span>\r\n        <span class=\"hljs-keyword\">int</span> x = <span class=\"hljs-number\">0</span>;\r\n        <span class=\"hljs-keyword\">int</span> min = Integer.MAX_VALUE;\r\n        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> j = <span class=\"hljs-number\">0</span>; j &lt; d.length; j++) {\r\n            <span class=\"hljs-keyword\">if</span> (f[j] == <span class=\"hljs-number\">0</span> &amp;&amp; d[j] &lt;= min){\r\n                x = j;\r\n                min = d[j];\r\n            }\r\n        }\r\n        <span class=\"hljs-comment\">//给节点x标记</span>\r\n        count++;\r\n        f[x] = <span class=\"hljs-number\">1</span>;\r\n        <span class=\"hljs-keyword\">set</span>.<span class=\"hljs-keyword\">add</span>(x);\r\n        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> j = <span class=\"hljs-number\">0</span>; j &lt; graph.length; j++) {\r\n            <span class=\"hljs-keyword\">if</span> (graph[x][j] &gt; <span class=\"hljs-number\">0</span> &amp;&amp; d[j] &gt; d[x] + graph[x][j]){\r\n                d[j] = d[x] + graph[x][j];\r\n                fa[j] = x;\r\n            }\r\n        }\r\n    }\r\n\r\n    <span class=\"hljs-comment\">//打印各个最短路径</span>\r\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; d.length; i++) {\r\n        System.<span class=\"hljs-keyword\">out</span>.print(v[i] + <span class=\"hljs-string\">\"&lt;---\"</span>);\r\n        <span class=\"hljs-keyword\">int</span> j = fa[i];\r\n        <span class=\"hljs-keyword\">while</span> (j != <span class=\"hljs-number\">0</span>){\r\n            System.<span class=\"hljs-keyword\">out</span>.print(v[j] + <span class=\"hljs-string\">\"&lt;---\"</span>);\r\n            j = fa[j];\r\n        }\r\n        System.<span class=\"hljs-keyword\">out</span>.println(v[<span class=\"hljs-number\">0</span>] + <span class=\"hljs-string\">\":\"</span> + d[i]);\r\n    }\r\n}\r\n</code></pre>\r\n<h5 id=\"floyd-\">Floyd算法</h5>\r\n<p><code>求解所有两点间的最短路的问题叫做任意两点间的最短路问题。让我们试着用DP来求解任意两\r\n点间的最短路问题。只使用顶点0 k和i, j的情况下，记到j的最短路长度为d[k+1][i][]。k=-1时，\r\n认为只使用i和j，所以d[0][i[i]=cost[][i]。 接下来让我们把只使用顶点0~k的问题归约到只使用\r\n0~k-1的问题上。\r\n只使用0~ k时，我们分i到j的最短路正好经过顶点k- -次和完全不经过顶点k两种情况来讨论。不经\r\n过顶点k的情况下，d[k][][i]=d[k-1][i][i]。 通过顶点k的情况下，d[k][][i]=d[k-1 ][i][k]+a[k-1][k][]。\r\n合起来，就得到了&quot;d[k][][i]=min(d[k-1][][i], d[k-1][][k]+d[k-1][k][i])。这个DP也可以使用同-个\r\n数组，不断进行d[i][i]=min(d[i][], d[i][k]+d[k][i])的更新来实现。</code></p>\r\n<pre><code class=\"lang-java\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">main</span>(<span class=\"hljs-params\">String[] args</span>) </span>{\r\n    <span class=\"hljs-keyword\">char</span>[] v = {<span class=\"hljs-string\">\'A\'</span>, <span class=\"hljs-string\">\'B\'</span>, <span class=\"hljs-string\">\'C\'</span>, <span class=\"hljs-string\">\'D\'</span>, <span class=\"hljs-string\">\'E\'</span>, <span class=\"hljs-string\">\'F\'</span>, <span class=\"hljs-string\">\'G\'</span>};\r\n    <span class=\"hljs-keyword\">int</span>[][] graph = {\r\n                {<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">5</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>},\r\n                {<span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">6</span>, <span class=\"hljs-number\">10</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>},\r\n                {<span class=\"hljs-number\">5</span>, <span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>},\r\n                {<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">6</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">0</span>},\r\n                {<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">10</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">5</span>},\r\n                {<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">9</span>},\r\n                {<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">5</span>, <span class=\"hljs-number\">9</span>, <span class=\"hljs-number\">0</span>}\r\n    };\r\n\r\n    <span class=\"hljs-keyword\">int</span>[][] d = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-keyword\">int</span>[v.length][v.length];\r\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; d.length; i++) {\r\n        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> j = <span class=\"hljs-number\">0</span>; j &lt; d.length; j++) {\r\n            d[i][j] = graph[i][j];\r\n        }\r\n    }\r\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; d.length; i++) {\r\n        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> j = <span class=\"hljs-number\">0</span>; j &lt; d.length; j++) {\r\n            <span class=\"hljs-keyword\">if</span> (i ==  j){\r\n                d[i][j] = <span class=\"hljs-number\">0</span>;\r\n                <span class=\"hljs-keyword\">continue</span>;\r\n            }\r\n            <span class=\"hljs-keyword\">if</span> (d[i][j] == <span class=\"hljs-number\">0</span>){\r\n                d[i][j] = <span class=\"hljs-number\">1000</span>;\r\n            }\r\n        }\r\n    }\r\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> k = <span class=\"hljs-number\">0</span>; k &lt; d.length; k++) {\r\n        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; d.length; i++) {\r\n            <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> j = <span class=\"hljs-number\">0</span>; j &lt; d.length; j++) {\r\n                d[i][j] = Math.min(d[i][j], d[i][k] + d[k][j]);\r\n            }\r\n        }\r\n    }\r\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; v.length; i++) {\r\n        System.<span class=\"hljs-keyword\">out</span>.println(Arrays.toString(d[i]));\r\n    }\r\n}\r\n</code></pre>\r\n<h3 id=\"-\">题解</h3>\r\n<h4 id=\"kurskal\">Kurskal</h4>\r\n<ol>\r\n<li><a href=\"http://poj.org/problem?id=1287\">POJ1287</a></li>\r\n</ol>\r\n<pre><code class=\"lang-java\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">main</span>(<span class=\"hljs-params\">String[] args</span>) </span>{\r\n    List&lt;Integer&gt; res = <span class=\"hljs-keyword\">new</span> ArrayList&lt;Integer&gt;();\r\n    Scanner input = <span class=\"hljs-keyword\">new</span> Scanner(System.<span class=\"hljs-keyword\">in</span>);\r\n    <span class=\"hljs-keyword\">while</span> (<span class=\"hljs-literal\">true</span>){\r\n        List&lt;Edge&lt;Integer&gt;&gt; list = <span class=\"hljs-keyword\">new</span> ArrayList&lt;Edge&lt;Integer&gt;&gt;();\r\n        <span class=\"hljs-keyword\">int</span> p = input.nextInt();\r\n        <span class=\"hljs-keyword\">if</span> (p == <span class=\"hljs-number\">0</span>){\r\n            <span class=\"hljs-keyword\">break</span>;\r\n        }\r\n        <span class=\"hljs-keyword\">int</span> r = input.nextInt();\r\n        <span class=\"hljs-comment\">//电缆</span>\r\n        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; r; i++) {\r\n            <span class=\"hljs-keyword\">int</span> start = input.nextInt();\r\n            <span class=\"hljs-keyword\">int</span> end = input.nextInt();\r\n            <span class=\"hljs-keyword\">int</span> dis = input.nextInt();\r\n            list.<span class=\"hljs-keyword\">add</span>(<span class=\"hljs-keyword\">new</span> Edge&lt;Integer&gt;(start, end, dis));\r\n        }\r\n        <span class=\"hljs-comment\">//得到最小电缆长度方案</span>\r\n        Kurskal&lt;Integer&gt; kurskal = <span class=\"hljs-keyword\">new</span> Kurskal&lt;Integer&gt;(list, <span class=\"hljs-number\">6</span>);\r\n        Set&lt;Edge&lt;Integer&gt;&gt; t = kurskal.getT();\r\n        <span class=\"hljs-comment\">//统计最小长度</span>\r\n        <span class=\"hljs-keyword\">int</span> count = <span class=\"hljs-number\">0</span>;\r\n        <span class=\"hljs-keyword\">for</span> (Edge&lt;Integer&gt; edge : t) {\r\n            count += edge.getDistance();\r\n        }\r\n        res.<span class=\"hljs-keyword\">add</span>(count);\r\n    }\r\n\r\n    <span class=\"hljs-keyword\">for</span> (Integer i : res) {\r\n        System.<span class=\"hljs-keyword\">out</span>.println(i);\r\n    }\r\n}\r\n</code></pre>\r\n<ol>\r\n<li><p>城市建设</p>\r\n<p> 问题描述<br> 　　栋栋居住在一个繁华的C市中，然而，这个城市的道路大都年久失修。市长准备重新修一些路以方便市民，于是找到了栋栋，希望栋栋能帮助他。</p>\r\n<p> 　　C市中有n个比较重要的地点，市长希望这些地点重点被考虑。现在可以修一些道路来连接其中的一些地点，每条道路可以连接其中的两个地点。</p>\r\n<p> 另外由于C市有一条河从中穿过，也可以在其中的一些地点建设码头，所有建了码头的地点可以通过河道连接。</p>\r\n<p> 　　栋栋拿到了允许建设的道路的信息，包括每条可以建设的道路的花费，以及哪些地点可以建设码头和建设码头的花费。</p>\r\n<p> 　　市长希望栋栋给出一个方案，使得任意两个地点能只通过新修的路或者河道互达，同时花费尽量小。<br> 输入格式<br> 　　输入的第一行包含两个整数n, m，分别表示C市中重要地点的个数和可以建设的道路条数。所有地点从1到n依次编号。<br> 　　接下来m行，每行三个整数a, b, c，表示可以建设一条从地点a到地点b的道路，花费为c。<br> 若c为正，表示建设是花钱的，如果c为负，则表示建设了道路后还可以赚钱（比如建设收费道路）。<br> 　　接下来一行，包含n个整数w_1, w_2, …, w_n。如果w_i为正数，则表示在地点i建设码头的花费，如果w_i为-1，则表示地点i无法建设码头。<br> 　　输入保证至少存在一个方法使得任意两个地点能只通过新修的路或者河道互达。<br> 输出格式<br> 　　输出一行，包含一个整数，表示使得所有地点通过新修道路或者码头连接的最小花费。如果满足条件的情况下还能赚钱，那么你应该输出一个负数。<br> 样例输入<br> 5 5<br> 1 2 4<br> 1 3 -1<br> 2 3 3<br> 2 4 5<br> 4 5 10<br> -1 10 10 1 1<br> 样例输出<br> 9<br> 样例说明<br> 　　建设第2、3、4条道路，在地点4、5建设码头，总的花费为9。<br> 数据规模和约定<br> 　　对于20%的数据，1&lt;=n&lt;=10，1&lt;=m&lt;=20，0&lt;=c&lt;=20，w_i&lt;=20；<br> 　　对于50%的数据，1&lt;=n&lt;=100，1&lt;=m&lt;=1000，-50&lt;=c&lt;=50，w_i&lt;=50；<br> 　　对于70%的数据，1&lt;=n&lt;=1000；<br> 　　对于100%的数据，1 &lt;= n &lt;= 10000，1 &lt;= m &lt;= 100000，-1000&lt;=c&lt;=1000，-1&lt;=w_i&lt;=1000，w_i≠0。</p>\r\n<ul>\r\n<li>解：<pre><code class=\"lang-java\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">(String[] args)</span> </span>{\r\n  List&lt;Edge&lt;Integer&gt;&gt; <span class=\"hljs-built_in\">list</span> = <span class=\"hljs-keyword\">new</span> ArrayList&lt;Edge&lt;Integer&gt;&gt;();\r\n  <span class=\"hljs-comment\">//道路</span>\r\n  <span class=\"hljs-built_in\">list</span>.add(<span class=\"hljs-keyword\">new</span> Edge&lt;Integer&gt;(<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">4</span>));\r\n  <span class=\"hljs-built_in\">list</span>.add(<span class=\"hljs-keyword\">new</span> Edge&lt;Integer&gt;(<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">-1</span>));\r\n  <span class=\"hljs-built_in\">list</span>.add(<span class=\"hljs-keyword\">new</span> Edge&lt;Integer&gt;(<span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">3</span>));\r\n  <span class=\"hljs-built_in\">list</span>.add(<span class=\"hljs-keyword\">new</span> Edge&lt;Integer&gt;(<span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">5</span>));\r\n  <span class=\"hljs-built_in\">list</span>.add(<span class=\"hljs-keyword\">new</span> Edge&lt;Integer&gt;(<span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">5</span>, <span class=\"hljs-number\">10</span>));\r\n  <span class=\"hljs-comment\">//每个地点建设码头的开销</span>\r\n  <span class=\"hljs-built_in\">list</span>.add(<span class=\"hljs-keyword\">new</span> Edge&lt;Integer&gt;(<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">10</span>));\r\n  <span class=\"hljs-built_in\">list</span>.add(<span class=\"hljs-keyword\">new</span> Edge&lt;Integer&gt;(<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">10</span>));\r\n  <span class=\"hljs-built_in\">list</span>.add(<span class=\"hljs-keyword\">new</span> Edge&lt;Integer&gt;(<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">1</span>));\r\n  <span class=\"hljs-built_in\">list</span>.add(<span class=\"hljs-keyword\">new</span> Edge&lt;Integer&gt;(<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">5</span>, <span class=\"hljs-number\">1</span>));\r\n  <span class=\"hljs-comment\">//得到最小花费的建设方案</span>\r\n  Kurskal&lt;Integer&gt; kurskal = <span class=\"hljs-keyword\">new</span> Kurskal&lt;&gt;(<span class=\"hljs-built_in\">list</span>, <span class=\"hljs-number\">6</span>);\r\n  Set&lt;Edge&lt;Integer&gt;&gt; t = kurskal.getT();\r\n  <span class=\"hljs-comment\">//统计最小开销</span>\r\n  <span class=\"hljs-keyword\">int</span> count = <span class=\"hljs-number\">0</span>;\r\n  <span class=\"hljs-keyword\">for</span> (Edge&lt;Integer&gt; edge : t) {\r\n      count += edge.getDistance();\r\n  }\r\n  System.out.println(count);\r\n  System.out.println(t);\r\n}\r\n</code></pre>\r\n</li>\r\n</ul>\r\n</li>\r\n</ol>\r\n<h4 id=\"-\">没有明显节点的图</h4>\r\n<ol>\r\n<li><p>分酒<br>有4个红酒瓶子，它们的容量分别是：9升, 7升, 4升, 2升<br>开始的状态是 [9,0,0,0]，也就是说：第一个瓶子满着，其它的都空着。</p>\r\n<p>允许把酒从一个瓶子倒入另一个瓶子，但只能把一个瓶子倒满或把一个瓶子倒空，不能有中间状态。<br>这样的一次倒酒动作称为1次操作。</p>\r\n<p>假设瓶子的容量和初始状态不变，对于给定的目标状态，至少需要多少次操作才能实现？<br>本题就是要求你编程实现最小操作次数的计算。</p>\r\n<p>输入：最终状态（空格分隔）<br>输出：最小操作次数（如无法实现，则输出-1）</p>\r\n<p>例如：<br>输入：<br>9 0 0 0<br>应该输出：<br>0</p>\r\n<p>输入：<br>6 0 0 3<br>应该输出：<br>-1</p>\r\n<p>输入：<br>7 2 0 0<br>应该输出：<br>2</p>\r\n</li>\r\n</ol>\r\n<pre><code class=\"lang-java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> 分酒 </span>{\r\n    <span class=\"hljs-comment\">//容量</span>\r\n    <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">int</span>[] v = {<span class=\"hljs-number\">9</span>, <span class=\"hljs-number\">7</span>, <span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">2</span>};\r\n\r\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">(String[] args)</span> </span>{\r\n        <span class=\"hljs-comment\">//定义开始状态</span>\r\n        Integer[] s = {<span class=\"hljs-number\">9</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>};\r\n        State start = <span class=\"hljs-keyword\">new</span> State(s, <span class=\"hljs-number\">0</span>);\r\n        <span class=\"hljs-comment\">//得到输入的最终状态</span>\r\n        Scanner input = <span class=\"hljs-keyword\">new</span> Scanner(System.in);\r\n        Integer[] e = <span class=\"hljs-keyword\">new</span> Integer[v.length];\r\n        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; v.length; i++) {\r\n            e[i] = input.nextInt();\r\n        }\r\n        State end = <span class=\"hljs-keyword\">new</span> State(e, <span class=\"hljs-number\">0</span>);\r\n        <span class=\"hljs-comment\">//队列记录状态转移中间过程 bfs</span>\r\n        Queue&lt;State&gt; q = <span class=\"hljs-keyword\">new</span> LinkedList&lt;State&gt;();\r\n        <span class=\"hljs-comment\">//set判断状态是否重叠  避免重复添加状态</span>\r\n        Set&lt;State&gt; set = <span class=\"hljs-keyword\">new</span> HashSet&lt;&gt;();\r\n        <span class=\"hljs-comment\">//状态初始化</span>\r\n        set.add(start);\r\n        q.add(start);\r\n        <span class=\"hljs-comment\">//遍历状态</span>\r\n        <span class=\"hljs-keyword\">while</span> (!q.isEmpty()){\r\n            <span class=\"hljs-comment\">//得到一个状态</span>\r\n            State t = q.poll();\r\n            <span class=\"hljs-comment\">//判断是否到达最终状态</span>\r\n            <span class=\"hljs-keyword\">if</span> (t.equals(end)){\r\n                <span class=\"hljs-comment\">//打印状态转移的次数</span>\r\n                System.out.println(t.depth);\r\n                <span class=\"hljs-keyword\">return</span>;\r\n            }\r\n            <span class=\"hljs-comment\">//备份t状态</span>\r\n            Integer[] temp = t.t.clone();\r\n            <span class=\"hljs-comment\">//加入t转移状态后的n个状态</span>\r\n            <span class=\"hljs-comment\">//从i杯倒入j杯</span>\r\n            <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; temp.length; i++) {\r\n                <span class=\"hljs-comment\">//如果i杯没有酒直接跳过</span>\r\n                <span class=\"hljs-keyword\">if</span> (temp[i] == <span class=\"hljs-number\">0</span>)    <span class=\"hljs-keyword\">continue</span>;\r\n                <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> j = <span class=\"hljs-number\">0</span>; j &lt; temp.length; j++) {\r\n                    <span class=\"hljs-comment\">//每次都是从t状态之间转移 所以需要还原t状态</span>\r\n                    temp = t.t.clone();\r\n                    <span class=\"hljs-comment\">//如果i杯导入i杯则跳过</span>\r\n                    <span class=\"hljs-keyword\">if</span> (i == j)    <span class=\"hljs-keyword\">continue</span>;\r\n                    <span class=\"hljs-comment\">//j杯剩余容量</span>\r\n                    <span class=\"hljs-keyword\">int</span> surplus = v[j] - temp[j];\r\n                    <span class=\"hljs-comment\">//i杯能倒完</span>\r\n                    <span class=\"hljs-keyword\">if</span> (surplus &gt;= temp[i]){\r\n                        temp[j] += temp[i];\r\n                        temp[i] = <span class=\"hljs-number\">0</span>;\r\n                    }\r\n                    <span class=\"hljs-comment\">//j杯能倒满</span>\r\n                    <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (temp[i] &gt; surplus){\r\n                        temp[j] += surplus;\r\n                        temp[i] -= surplus;\r\n                    }\r\n                    <span class=\"hljs-comment\">//得到转移后的状态</span>\r\n                    State next = <span class=\"hljs-keyword\">new</span> State(temp, t.depth + <span class=\"hljs-number\">1</span>);\r\n                    <span class=\"hljs-comment\">//判断此状态之前是否已经加入</span>\r\n                    <span class=\"hljs-keyword\">if</span> (!set.contains(next)){\r\n                        <span class=\"hljs-comment\">//加入状态</span>\r\n                        set.add(next);\r\n                        q.add(next);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        System.out.println(-<span class=\"hljs-number\">1</span>);\r\n    }\r\n}\r\n<span class=\"hljs-comment\">//定义状态</span>\r\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">State</span></span>{\r\n    <span class=\"hljs-comment\">//酒杯状态</span>\r\n    Integer[] t;\r\n    <span class=\"hljs-comment\">//转移次数</span>\r\n    <span class=\"hljs-keyword\">int</span> depth;\r\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-title\">State</span><span class=\"hljs-params\">(Integer[] t, <span class=\"hljs-keyword\">int</span> count)</span> </span>{\r\n        <span class=\"hljs-keyword\">super</span>();\r\n        <span class=\"hljs-keyword\">this</span>.t = t;\r\n        <span class=\"hljs-keyword\">this</span>.depth = count;\r\n    }\r\n    <span class=\"hljs-meta\">@Override</span>\r\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> String <span class=\"hljs-title\">toString</span><span class=\"hljs-params\">()</span> </span>{\r\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">\"State [t=\"</span> + Arrays.toString(t) + <span class=\"hljs-string\">\", count=\"</span> + depth + <span class=\"hljs-string\">\"]\"</span>;\r\n    }\r\n    <span class=\"hljs-meta\">@Override</span>\r\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">hashCode</span><span class=\"hljs-params\">()</span> </span>{\r\n        <span class=\"hljs-keyword\">final</span> <span class=\"hljs-keyword\">int</span> prime = <span class=\"hljs-number\">31</span>;\r\n        <span class=\"hljs-keyword\">int</span> result = <span class=\"hljs-number\">1</span>;\r\n        result = prime * result + Arrays.hashCode(t);\r\n        <span class=\"hljs-keyword\">return</span> result;\r\n    }\r\n    <span class=\"hljs-comment\">//判断状态是否相同根据酒杯状态是否相同</span>\r\n    <span class=\"hljs-meta\">@Override</span>\r\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">boolean</span> <span class=\"hljs-title\">equals</span><span class=\"hljs-params\">(Object obj)</span> </span>{\r\n        <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">this</span> == obj)\r\n            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">true</span>;\r\n        <span class=\"hljs-keyword\">if</span> (obj == <span class=\"hljs-keyword\">null</span>)\r\n            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">false</span>;\r\n        <span class=\"hljs-keyword\">if</span> (getClass() != obj.getClass())\r\n            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">false</span>;\r\n        State other = (State) obj;\r\n        <span class=\"hljs-keyword\">if</span> (!Arrays.equals(t, other.t))\r\n            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">false</span>;\r\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">true</span>;\r\n    }\r\n}\r\n</code></pre>\r\n<ol>\r\n<li>迷宫</li>\r\n</ol>\r\n<p>...11111111111111111111111111111<br>11.111111........1111111111.1111<br>11.111111..111.11111111.....1111<br>11.11111111111.1111111111.111111<br>11.111111.................111111<br>11.111111.11111111111.11111.1111<br>11.111111.11111111111.11111..111<br>11..........111111111.11111.1111<br>11111.111111111111111.11....1111<br>11111.111111111111111.11.11.1111<br>11111.111111111111111.11.11.1111<br>111...111111111111111.11.11.1111<br>111.11111111111111111....11.1111<br>111.11111111111111111111111.1111<br>111.1111.111111111111111......11<br>111.1111.......111111111.1111.11<br>111.1111.11111.111111111.1111.11<br>111......11111.111111111.1111111<br>11111111111111.111111111.111...1<br>11111111111111...............1.1<br>111111111111111111111111111111..</p>\r\n<p>如上图的迷宫，入口，出口分别：左上角，右下角<br>&quot;1&quot;是墙壁，&quot;.&quot;是通路<br>求最短需要走多少步？</p>\r\n<pre><code class=\"lang-java\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">main</span>(<span class=\"hljs-params\">String[] args</span>) </span>{\r\n    <span class=\"hljs-keyword\">char</span>[][] graph = { \r\n            <span class=\"hljs-string\">\"...111\"</span>.toCharArray(), \r\n            <span class=\"hljs-string\">\".1.111\"</span>.toCharArray(), \r\n            <span class=\"hljs-string\">\".....1\"</span>.toCharArray(),\r\n            <span class=\"hljs-string\">\"...1..\"</span>.toCharArray(), };\r\n    <span class=\"hljs-comment\">//标识</span>\r\n    <span class=\"hljs-keyword\">int</span>[][] visited = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-keyword\">int</span>[graph.length][graph[<span class=\"hljs-number\">0</span>].length];\r\n\r\n    Queue&lt;Node1&gt; q = <span class=\"hljs-keyword\">new</span> LinkedList&lt;Node1&gt;();\r\n    <span class=\"hljs-comment\">//初始化起点</span>\r\n    q.<span class=\"hljs-keyword\">add</span>(<span class=\"hljs-keyword\">new</span> Node1(<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>));\r\n\r\n    <span class=\"hljs-keyword\">while</span> (!q.isEmpty()) {\r\n        Node1 Node1 = q.poll();\r\n        <span class=\"hljs-keyword\">int</span> x = Node1.x;\r\n        <span class=\"hljs-keyword\">int</span> y = Node1.y;\r\n        <span class=\"hljs-comment\">//终点为右下角</span>\r\n        <span class=\"hljs-keyword\">if</span> (x == graph.length - <span class=\"hljs-number\">1</span> &amp;&amp; y == graph[<span class=\"hljs-number\">0</span>].length - <span class=\"hljs-number\">1</span>) {\r\n            System.<span class=\"hljs-keyword\">out</span>.println(Node1.depth);\r\n            <span class=\"hljs-keyword\">break</span>;\r\n        }\r\n        <span class=\"hljs-comment\">//加入四周的点</span>\r\n        <span class=\"hljs-keyword\">if</span> (x - <span class=\"hljs-number\">1</span> &gt;= <span class=\"hljs-number\">0</span> &amp;&amp; graph[x - <span class=\"hljs-number\">1</span>][y] != <span class=\"hljs-string\">\'1\'</span> &amp;&amp; visited[x - <span class=\"hljs-number\">1</span>][y] == <span class=\"hljs-number\">0</span>) {\r\n            visited[x - <span class=\"hljs-number\">1</span>][y] = <span class=\"hljs-number\">1</span>;\r\n            q.<span class=\"hljs-keyword\">add</span>(<span class=\"hljs-keyword\">new</span> Node1(x - <span class=\"hljs-number\">1</span>, y, Node1.depth + <span class=\"hljs-number\">1</span>));\r\n        }\r\n        <span class=\"hljs-keyword\">if</span> (x + <span class=\"hljs-number\">1</span> &lt; graph.length &amp;&amp; graph[x + <span class=\"hljs-number\">1</span>][y] != <span class=\"hljs-string\">\'1\'</span> &amp;&amp; visited[x + <span class=\"hljs-number\">1</span>][y] == <span class=\"hljs-number\">0</span>) {\r\n            visited[x + <span class=\"hljs-number\">1</span>][y] = <span class=\"hljs-number\">1</span>;\r\n            q.<span class=\"hljs-keyword\">add</span>(<span class=\"hljs-keyword\">new</span> Node1(x + <span class=\"hljs-number\">1</span>, y, Node1.depth + <span class=\"hljs-number\">1</span>));\r\n        }\r\n        <span class=\"hljs-keyword\">if</span> (y - <span class=\"hljs-number\">1</span> &gt;= <span class=\"hljs-number\">0</span> &amp;&amp; graph[x][y - <span class=\"hljs-number\">1</span>] != <span class=\"hljs-string\">\'1\'</span> &amp;&amp; visited[x][y - <span class=\"hljs-number\">1</span>] == <span class=\"hljs-number\">0</span>) {\r\n            visited[x][y - <span class=\"hljs-number\">1</span>] = <span class=\"hljs-number\">1</span>;\r\n            q.<span class=\"hljs-keyword\">add</span>(<span class=\"hljs-keyword\">new</span> Node1(x, y - <span class=\"hljs-number\">1</span>, Node1.depth + <span class=\"hljs-number\">1</span>));\r\n        }\r\n        <span class=\"hljs-keyword\">if</span> (y + <span class=\"hljs-number\">1</span> &lt; graph[<span class=\"hljs-number\">0</span>].length &amp;&amp; graph[x][y + <span class=\"hljs-number\">1</span>] != <span class=\"hljs-string\">\'1\'</span> &amp;&amp; visited[x][y + <span class=\"hljs-number\">1</span>] == <span class=\"hljs-number\">0</span>) {\r\n            visited[x][y + <span class=\"hljs-number\">1</span>] = <span class=\"hljs-number\">1</span>;\r\n            q.<span class=\"hljs-keyword\">add</span>(<span class=\"hljs-keyword\">new</span> Node1(x, y + <span class=\"hljs-number\">1</span>, Node1.depth + <span class=\"hljs-number\">1</span>));\r\n        }\r\n    }\r\n}\r\n<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Node1</span> {\r\n    <span class=\"hljs-keyword\">int</span> x;\r\n    <span class=\"hljs-keyword\">int</span> y;\r\n    <span class=\"hljs-keyword\">int</span> depth;\r\n\r\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-title\">Node1</span>(<span class=\"hljs-params\"><span class=\"hljs-keyword\">int</span> x, <span class=\"hljs-keyword\">int</span> y, <span class=\"hljs-keyword\">int</span> depth</span>) </span>{\r\n        <span class=\"hljs-keyword\">this</span>.x = x;\r\n        <span class=\"hljs-keyword\">this</span>.y = y;\r\n        <span class=\"hljs-keyword\">this</span>.depth = depth;\r\n    }\r\n}\r\n</code></pre>\r\n<h4 id=\"-\">最短路径</h4>\r\n<ul>\r\n<li><a href=\"http://poj.org/problem?id=1502\">POJ-1502</a></li>\r\n</ul>\r\n<pre><code class=\"lang-java\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">main</span>(<span class=\"hljs-params\">String[] args</span>) </span>{\r\n    Scanner input = <span class=\"hljs-keyword\">new</span> Scanner(System.<span class=\"hljs-keyword\">in</span>);\r\n    <span class=\"hljs-keyword\">int</span> n = input.nextInt();\r\n    <span class=\"hljs-keyword\">int</span>[][] graph = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-keyword\">int</span>[n][n];\r\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">1</span>; i &lt; graph.length; i++) {\r\n        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> j = <span class=\"hljs-number\">0</span>; j &lt; i; j++) {\r\n            <span class=\"hljs-keyword\">try</span>{\r\n            <span class=\"hljs-keyword\">int</span> x = Integer.parseInt(input.next());\r\n            graph[i][j] = x;\r\n            graph[j][i] = x;\r\n            }<span class=\"hljs-keyword\">catch</span> (Exception e){\r\n                graph[i][j] =<span class=\"hljs-number\">0</span>;\r\n                graph[j][i] =<span class=\"hljs-number\">0</span>;\r\n            }\r\n        }\r\n    }\r\n\r\n    <span class=\"hljs-keyword\">int</span>[] d = 单源最短路径_Bellman_ford优化.shortestPath(graph, <span class=\"hljs-number\">0</span>);\r\n\r\n    <span class=\"hljs-comment\">//所需的最短通信时间为最大值</span>\r\n    <span class=\"hljs-keyword\">int</span> max = d[<span class=\"hljs-number\">1</span>];\r\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">2</span>; i &lt; d.length; i++) {\r\n        <span class=\"hljs-keyword\">if</span> (d[i] &gt; max){\r\n            max = d[i];\r\n        }\r\n    }\r\n    System.<span class=\"hljs-keyword\">out</span>.println(max);\r\n}\r\n</code></pre>', '### 图基础\r\n\r\n#### 树与图\r\n\r\n* 没有圈的连通图,就是树\r\n* 没有圈的非连通图,就是森林\r\n* 一棵树的边数等于顶点数-1\r\n* 边数等于顶点数-1的连通图,就是树\r\n\r\n#### 有向图\r\n\r\n* 没有圈的有向图,叫做DAG ( Directed Acyclic Graph ,有向无环图)\r\n* 拓扑排序定义:将DAG中的顶点以线性方式进行排序。即对于任何自顶点u到顶点v的有向边u->v ,在最后的排序结果中,顶点u总是在顶点v的前面。这样的排序结果,称为拓扑序。\r\n\r\n### 图的表示\r\n\r\n* 邻接矩阵\r\n* 邻接表\r\n* 边集数组-Edge List\r\n\r\n### dfs及相关问题\r\n\r\n#### dfs典型应用\r\n\r\n1. 连通检测\r\n\r\n    * 给定一个方阵，定义连通：上下左右相邻，并且值相同。\r\n    可以想象成一张地图，不同的区域被涂以不同颜色。\r\n    输入：\r\n    整数N, (N<50)表示矩阵的行列数\r\n    接下来N行，每行N个字符，代表方阵中的元素\r\n    接下来一个整数M，(M<1000)表示询问数\r\n    接下来M行，每行代表一个询问，\r\n    格式为4个整数，y1,x1,y2,x2，\r\n    表示询问(第y1行,第x1列) 与 (第y2行,第x2列) 是否连通。\r\n    连通输出true，否则false\r\n\r\n    例如：\r\n    10\r\n    0010000000\r\n    0011100000\r\n    0000111110\r\n    0001100010\r\n    1111010010\r\n    0000010010\r\n    0000010011\r\n    0111111000\r\n    0000010000\r\n    0000000000\r\n    3\r\n    0 0 9 9\r\n    0 2 6 8\r\n    4 4 4 6\r\n\r\n    程序应该输出：\r\n    false\r\n    true\r\n    true\r\n\r\n    * 解：\r\n    ```java\r\n    public static void main(String[] args) {\r\n		Scanner input = new Scanner(System.in);\r\n		//得到N\r\n		int N = input.nextInt();\r\n		//得到图\r\n		char[][] graph = new char[N][N];\r\n		int[][] help = new int[N][N];\r\n		for (int i = 0; i < graph.length; i++) {\r\n			String str = input.next();\r\n			for (int j = 0; j < graph[i].length; j++) {\r\n				graph[i][j] = str.charAt(j);\r\n			}\r\n		}\r\n		//得到M\r\n		int M = input.nextInt();\r\n		boolean[] res = new boolean[M];\r\n		for (int i = 0; i < M; i++) {\r\n			//得到坐标\r\n			int[] points = new int[4];\r\n			for (int j = 0; j < points.length; j++) {\r\n				points[j] = input.nextInt();\r\n			}\r\n			//得到结果\r\n			res[i] = check(graph, help, points);\r\n		}\r\n		//打印\r\n		for (int i = 0; i < res.length; i++) {\r\n			System.out.println(res[i]);\r\n		}\r\n	}\r\n	/**\r\n	 * 两点是否连同\r\n	 * @param graph 图\r\n	 * @param help 标识节点是否访问\r\n	 * @param points 当前坐标和目标坐标\r\n	 * @return \r\n	 */\r\n	public static boolean check(char[][] graph, int[][] help, int[] points){\r\n		//x1 y1 为当前坐标\r\n		int x1 = points[0];\r\n		int y1 = points[1];\r\n		//x2 y2 为目标坐标\r\n		int x2 = points[2];\r\n		int y2 = points[3];\r\n		//如果当前已经到达目标则返回\r\n		if (x1 == x2 && y1 == y2){\r\n			return true;\r\n		}\r\n		boolean f1 = false;\r\n		boolean f2 = false;\r\n		boolean f3 = false;\r\n		boolean f4 = false;\r\n		//向左 不能越界 是否连同 是否走过 \r\n		if (x1 - 1 >= 0 && graph[x1 - 1][y1] == graph[x1][y1] && help[x1 - 1][y1] == 0){\r\n			//向左走\r\n			help[x1 - 1][y1] = 1;\r\n			points[0] -=1;\r\n			f1 = check(graph, help, points);\r\n			//回溯\r\n			help[x1 - 1][y1] = 0;\r\n			points[0] +=1;\r\n		}\r\n		//向右\r\n		if (x1 + 1 < graph.length && graph[x1 + 1][y1] == graph[x1][y1] && help[x1 + 1][y1] == 0){\r\n			//向右走\r\n			help[x1 + 1][y1] = 1;\r\n			points[0] +=1;\r\n			f2 = check(graph, help, points);\r\n			//回溯\r\n			help[x1 + 1][y1] = 0;\r\n			points[0] -=1;\r\n		}\r\n		//向上\r\n		if (y1 - 1 >= 0 && graph[x1][y1 - 1] == graph[x1][y1] && help[x1][y1 - 1] == 0){\r\n			//向上走\r\n			help[x1][y1 - 1] = 1;\r\n			points[1] -=1;\r\n			f3 = check(graph, help, points);\r\n			//回溯\r\n			help[x1][y1 - 1] = 0;\r\n			points[1] +=1;\r\n		}\r\n		//向下\r\n		if (y1 + 1 < graph.length && graph[x1][y1 + 1] == graph[x1][y1] && help[x1][y1 + 1] == 0){\r\n			//向上走\r\n			help[x1][y1 + 1] = 1;\r\n			points[1] +=1;\r\n			f4 = check(graph, help, points);\r\n			//回溯\r\n			help[x1][y1 + 1] = 0;\r\n			points[1] -=1;\r\n		}\r\n		\r\n		return f1 || f2 || f3 || f4;\r\n	}\r\n    ```\r\n\r\n2. 用DFS求连通块--种子填充(Flood Fill)\r\n    * 输入一个m行n列的字符矩阵，统计字符“@”组成多少个八连块。\r\n    * 如果两个字符“@”所在的格子相邻（横、竖或者对角线方向），就说它们属于同一个八连块。\r\n    * 解：\r\n    ```java\r\n    public static void main(String[] args) {\r\n		char[][] data = {\r\n			      \"*@@*@\".toCharArray(),\r\n			      \"**@*@\".toCharArray(),\r\n			      \"****@\".toCharArray(),\r\n			      \"@@@*@\".toCharArray(),\r\n			      \"@@@@@\".toCharArray(),\r\n			  };\r\n		int count = 0;\r\n		for (int i = 0; i < data.length; i++) {\r\n			for (int j = 0; j < data.length; j++) {\r\n				if (data[i][j] != \'*\'){\r\n					dfs(data, i, j);\r\n					count++;\r\n				}\r\n			}\r\n		}\r\n		\r\n		System.out.println(count);\r\n	}\r\n	\r\n	public static void dfs(char[][] graph, int x, int y){\r\n		//如果下标越界直接退出\r\n		if (x < 0 || x >= graph.length || y < 0 || y >= graph[0].length){\r\n			return;\r\n		}\r\n		//如果已经访问过则退出\r\n		if (graph[x][y] == \'*\'){\r\n			return;\r\n		}\r\n		//标记访问\r\n		graph[x][y] = \'*\';\r\n		//深搜\r\n		dfs(graph, x - 1, y);\r\n		dfs(graph, x + 1, y);\r\n		dfs(graph, x, y - 1);\r\n		dfs(graph, x, y + 1);\r\n		dfs(graph, x - 1, y - 1);\r\n		dfs(graph, x - 1, y + 1);\r\n		dfs(graph, x + 1, y - 1);\r\n		dfs(graph, x + 1, y + 1);\r\n	}\r\n    ```\r\n\r\n3. 拓扑排序\r\n\r\n* 拓扑排序:将DAG中的顶点以线性方式进行排序。即对于任何自顶点u到顶点v的有向边u->v ,在最后的排序结果中,顶点u总是\r\n在顶点v的前面。这样的排序结果,称为拓扑序。有环图,不存在拓扑排序。\r\n\r\n	```java\r\n	//顶点\r\n	static char[] v = {\'a\', \'b\', \'c\', \'d\', \'e\'};\r\n	//图\r\n	static int[][] graph = {\r\n			{0, 1, 0, 1, 0},\r\n			{0, 0, 1, 0, 0},\r\n			{0, 0, 0, 1, 0},\r\n			{0, 0, 0, 0, 1},\r\n			{0, 0, 1, 0, 0},\r\n	};\r\n	//记录顶点是否已访问\r\n	static int[] visited = new int[v.length];\r\n	//拓扑排序结果\r\n	static int[] res = new int[v.length];\r\n	//结果集下标\r\n	static int n = res.length - 1;\r\n	public static void main(String[] args) {\r\n		//对每个顶点进行dfs\r\n		for (int i = 0; i < v.length; i++) {\r\n			//如果顶点访问过则跳过\r\n			if (visited[i] == 1){\r\n				continue;\r\n			}\r\n			//判断有向图是否有环\r\n			boolean f = dfs(i);\r\n			//有环则直接退出\r\n			if (!f)	return;\r\n		}\r\n		//打印排序结果\r\n		for (int i = 0; i < visited.length; i++) {\r\n			System.out.println(v[res[i]]);\r\n		}\r\n	}\r\n\r\n	private static boolean dfs(int i) {\r\n		//标记节点正在访问\r\n		visited[i] = -1;\r\n		\r\n		for (int j = 0; j < graph.length; j++) {\r\n			//找到顶点i的出度顶点\r\n			if (graph[i][j] == 1){\r\n				//如果正在访问则证明有环 返回有环\r\n				if (visited[j] == -1){\r\n					return false;\r\n				}\r\n				//如果顶点未被访问\r\n				if (visited[j] == 0){\r\n					//递归进行dfs\r\n					boolean t = dfs(j);\r\n					if (!t){\r\n						return false;\r\n					}\r\n				}\r\n			}\r\n		}\r\n		//标记顶点已访问\r\n		visited[i] = 1;\r\n		//加入排序结果集\r\n		res[n--] = i;\r\n		return true;\r\n	}\r\n	```\r\n\r\n4. 欧拉道路与七桥问题\r\n\r\n* 柯尼斯堡七桥问题( Seven Bridges of Konigsberg )是图论中的著名问题。这个问题是基于一个现实生活中的事例:当时东普鲁士\r\n柯尼斯堡(今日俄罗斯加里宁格勒)市区跨普列戈利亚河两岸,河中心有两个小岛。小岛与河的两岸有七条桥连接。在所有桥都只能\r\n走一遍的前提下,如何才能把这个地方所有的桥都走遍? \r\n* 能否从无向图中的一个结点出发走出一条道路,每条边恰好经过一次，这样的路线称为欧拉道路(一笔画)。\r\n\r\n* 如果一个无向图是连通的,且最多只有两个奇点(度数为奇数) ,则一定存在欧拉道路\r\n* 如果有两个奇点,它们必须是起点和终点\r\n* 如果奇点不存在,可以从任意点出发,最终一-定会回到该点 ,称为欧拉回路\r\n* 对于有向图,欧拉道路存在的充要条件是:最多只能有两个点的入度不等于出度，而且必须是其中一个点的出度恰好比入度大1 (起\r\n点) ,另一个的入度比出度大1 (终点)\r\n\r\n	```java\r\n	//顶点\r\n	static char[] v = {\'a\', \'b\', \'c\', \'d\'};\r\n	//图\r\n	static int[][] graph = {\r\n			{0, 1, 2, 1},\r\n			{1, 0, 0, 0},\r\n			{2, 0, 0, 1},\r\n			{1, 0, 1, 0},\r\n	};\r\n	static int[][] visited = new int[4][4];\r\n	//记录路径\r\n	static Stack<String> path = new Stack<>();\r\n	public static void main(String[] args) {\r\n		//从奇数点开始\r\n		dfs(2);\r\n		//打印路径\r\n		while (!path.isEmpty()){\r\n			System.out.println(path.pop());\r\n		}\r\n	}\r\n	private static void dfs(int i) {\r\n		for (int j = 0; j < graph.length; j++) {\r\n			//如果i-j之间有道路 且走过的次数小于道路树\r\n			if (graph[i][j] > 0 && visited[i][j] < graph[i][j]){\r\n				//记录访问过的道路\r\n				visited[i][j]++;\r\n				visited[j][i]++;\r\n				//从j点开始\r\n				dfs(j);\r\n				//这里添加路径放在递归之后是因为\r\n				//只有走到底才能知道这条路径可不可行\r\n				//所以在调用栈弹出之前添加路径\r\n				path.push(v[i] + \"-->\" + v[j]);\r\n			}\r\n		}\r\n	}\r\n	```\r\n\r\n5. 二分图->图的着色问题\r\n\r\n* 给定一一个具有n个顶点的图,要给图上每个顶点染色,并且要使相邻的顶点的颜色不同、问是否最多用2种颜色进行染色?没有重边\r\n和自环。\r\n* 把相邻顶点染成不同颜色的问题叫做图的着色问题。\r\n* 对图进行染色所需的最小颜色数,称为最小着色数。最小着色数为2的图称为二分图。\r\n\r\n	```java\r\n	public static void main(String[] args) {\r\n		GraphNode n1 = new GraphNode(1);\r\n		GraphNode n2 = new GraphNode(2);\r\n		GraphNode n3 = new GraphNode(3);\r\n		GraphNode n4 = new GraphNode(4);\r\n		\r\n		n1.neighbor.add(n2);\r\n		n1.neighbor.add(n4);\r\n		\r\n		n2.neighbor.add(n3);\r\n		n2.neighbor.add(n1);\r\n		\r\n		n3.neighbor.add(n2);\r\n		n3.neighbor.add(n4);\r\n		\r\n		n4.neighbor.add(n1);\r\n		n4.neighbor.add(n3);\r\n		\r\n		System.out.println(dfs(n1, 1));\r\n	}\r\n	//判断是否为二分图\r\n	public static boolean dfs(GraphNode node, int color){\r\n		//顶点染色\r\n		node.color = color;\r\n		//遍历邻居\r\n		for (int i = 0; i < node.neighbor.size(); i++) {\r\n			GraphNode neighbor = node.neighbor.get(i);\r\n			//如果和邻居颜色冲突则直接返回\r\n			if (neighbor.color == color){\r\n				return false;\r\n			}\r\n			//如果邻居没有染色\r\n			if (neighbor.color == 0){\r\n				//给邻居染色\r\n				boolean f = dfs(neighbor, -color);\r\n				if (!f){\r\n					return false;\r\n				}\r\n			}\r\n		}\r\n		\r\n		return true;\r\n	}\r\n	```\r\n\r\n6. 最小生成树\r\n\r\n* 连通图去一条边就是树\r\n* 所有生成树中边的权重和最小的，称之为最小生成树( Minimal Spanning Tree )\r\n* 常用于网络构建等建设性问题的优化\r\n\r\n* 并查集(Union Find)\r\n并查集，在一些有N个元素的集合应用问题中，我们通常是在开始时让每个元素构成一个单元素的集合，然后按一定顺序将属于同一组的元素所在的集合合并，其间要反复查找一个元素在哪个集合中。\r\n并查集是一种树型的数据结构，用于处理一些不相交集合（Disjoint Sets）的合并及查询问题。常常在使用中以森林来表示。\r\n\r\n* Edge List\r\n\r\n```java\r\n/**\r\n * 边集数组 edge list\r\n * @author 96047\r\n *\r\n */\r\npublic class Edge<T> implements Comparable<Edge<T>> {\r\n	//起始顶点\r\n	private T start;\r\n	//结束顶点\r\n	private T end;\r\n	//距离\r\n	private int distance;\r\n	public Edge(T start, T end, int distance) {\r\n		super();\r\n		this.start = start;\r\n		this.end = end;\r\n		this.distance = distance;\r\n	}\r\n	public Edge() {\r\n	}\r\n	public T getStart() {\r\n		return start;\r\n	}\r\n	public void setStart(T start) {\r\n		this.start = start;\r\n	}\r\n	public T getEnd() {\r\n		return end;\r\n	}\r\n	public void setEnd(T end) {\r\n		this.end = end;\r\n	}\r\n	public int getDistance() {\r\n		return distance;\r\n	}\r\n	public void setDistance(int distance) {\r\n		this.distance = distance;\r\n	}\r\n	@Override\r\n	public String toString() {\r\n		return \"Edge [start=\" + start + \", end=\" + end + \", distance=\" + distance + \"]\";\r\n	}\r\n	@Override\r\n	public int compareTo(Edge<T> o) {\r\n		return this.distance - o.distance;\r\n	}\r\n}\r\n```\r\n\r\n* 并查集\r\n\r\n```java\r\n/**\r\n * 并查集\r\n * @author 96047\r\n *\r\n */\r\npublic class UnionFind {\r\n	public static void union(UFNode x, UFNode y){\r\n		find(y).parent = find(x);\r\n	}\r\n	\r\n	public static UFNode find(UFNode x){\r\n		UFNode p = x;\r\n		Set<UFNode> set = new HashSet<>();\r\n		//向上找到根节点\r\n		while (p.parent != null){\r\n			set.add(p);\r\n			p = p.parent;\r\n		}\r\n		//所有节点并入到根节点\r\n		for (UFNode uf: set){\r\n			uf.parent = p;\r\n		}\r\n		\r\n		return p;\r\n	}\r\n}\r\n\r\nclass UFNode{\r\n	UFNode parent;\r\n}\r\n```\r\n\r\n* kurskal\r\n\r\n```java\r\n/**\r\n * 最小生成树-克鲁兹卡尔\r\n * @author 96047\r\n *\r\n */\r\npublic class Kurskal {\r\n	//边集\r\n	private List<Edge<String>> lists;\r\n	//顶点总数\r\n	private int n;\r\n	//边和并查集的映射\r\n	Map<String, UFNode> edgeAndUF = new HashMap<>();\r\n	//最小生成树集合\r\n	Set<Edge<String>> T = new HashSet<>();\r\n	\r\n	public Kurskal(List<Edge<String>> lists, int n) {\r\n		super();\r\n		this.lists = lists;\r\n		this.n = n;\r\n		//按照顶点初始化并查集\r\n		for (Edge<String> edge : lists) {\r\n			String start = edge.getStart();\r\n			String end = edge.getEnd();\r\n			edgeAndUF.put(start, new UFNode());\r\n			edgeAndUF.put(end, new UFNode());\r\n		}\r\n	}\r\n	\r\n	public Set<Edge<String>> getT(){\r\n		//对边集排序\r\n		Collections.sort(lists);\r\n		for (Edge<String> edge : lists) {\r\n			String start = edge.getStart();\r\n			String end = edge.getEnd();\r\n			//如果两个点在同一个集合\r\n			if (UnionFind.find(edgeAndUF.get(start)).equals(UnionFind.find(edgeAndUF.get(end)))){\r\n				//跳过这条边\r\n				continue;\r\n			}else{\r\n				//选中这条边\r\n				T.add(edge);\r\n				//将边中顶点并入集合\r\n				UnionFind.union(edgeAndUF.get(start), edgeAndUF.get(end));\r\n			}\r\n			//判断mst是否已经生成\r\n			if (T.size() == n - 1){\r\n				break;\r\n			}\r\n		}\r\n		\r\n		return T;\r\n	}\r\n	\r\n	public static void main(String[] args) {\r\n		List<Edge<String>> l = new ArrayList<>();\r\n	    l.add(new Edge<String>(\"C\", \"D\", 1));\r\n	    l.add(new Edge<String>(\"C\", \"A\", 1));\r\n	    l.add(new Edge<String>(\"C\", \"E\", 8));\r\n	    l.add(new Edge<String>(\"A\", \"B\", 3));\r\n	    l.add(new Edge<String>(\"D\", \"E\", 3));\r\n	    l.add(new Edge<String>(\"B\", \"C\", 5));\r\n	    l.add(new Edge<String>(\"B\", \"E\", 6));\r\n	    l.add(new Edge<String>(\"B\", \"D\", 7));\r\n	    l.add(new Edge<String>(\"A\", \"D\", 2));\r\n	    l.add(new Edge<String>(\"A\", \"E\", 9));\r\n	    \r\n	    Kurskal kurskal = new Kurskal(l, 5);\r\n	    System.out.println(kurskal.getT());\r\n	}\r\n}\r\n```\r\n\r\n### bfs及相关问题\r\n\r\n#### 最短路径问题\r\n\r\n* 最短路径：给定两个顶点,在以这两个点为起点和终点的路径中,边的权值和最小的路径。考虑权值为点之间的距离。单源最短路问题\r\n\r\n##### Bellman-Ford算法\r\n\r\n`记从起点s出发到顶点的最短距离为d[i]。则下述等式成立。\r\nd[i]=min {d[j]+(从j到i的边的权值)e=(j,i)∈E}\r\n如果给定的图是一个DAG， 就可以按拓扑序给顶点编号，并利用用这条递推关系式计算出d。但\r\n是，如果图中有圈，就无法依赖这样的顺序进行计算。在这种情况下，记当前到顶点的最短路\r\n长度为d[i]，并设初值a[s]=0, d[i]=INF ( 足够大的常数)，再不断使用这条递推关系式更新d的值，\r\n就可以算出新的d。只要图中不存在负圈，这样的更新操作就是有限的。结束之后的d就是所求的\r\n最短距离了。`\r\n\r\n* 总结：有e(i, j)边 如果d[i]可达 有d[j] = min(d[j], d[j] + |e(i, j)|)\r\n\r\n```java\r\n/**\r\n* 源点s到各顶点的最短路径\r\n* @param s 起点\r\n* @return\r\n*/\r\nstatic int[][] graph = {\r\n			{0, 2, 5, 0, 0, 0, 0},\r\n			{2, 0, 4, 6, 10, 0, 0},\r\n			{5, 4, 0, 2, 0, 0, 0},\r\n			{0, 6, 2, 0, 0, 1, 0},\r\n			{0, 10, 0, 0, 0, 3, 5},\r\n			{0, 0, 0, 1, 3, 0, 9},\r\n			{0, 0, 0, 0, 5, 9, 0}\r\n		};\r\n\r\npublic static int[] shortestPath(int s){\r\n	//s到各顶点距离\r\n	int[] d = new int[graph.length];\r\n	//到自己距离为0\r\n	d[s] = 0;\r\n	//到其他顶点距离初始化为无穷大\r\n	for (int i = 1; i < d.length; i++) {\r\n		d[i] = Integer.MAX_VALUE;\r\n	}\r\n	\r\n	while (true){\r\n		boolean update = false;\r\n		//到i点的距离\r\n		for (int i = 0; i < graph.length; i++) {\r\n			//如果s-i距离未算出 则直接跳过\r\n			if (d[i] == Integer.MAX_VALUE){\r\n				continue;\r\n			}\r\n			//i--j\r\n			for (int j = 0; j < graph.length; j++) {\r\n				//如果i--j点有边\r\n				if (graph[i][j] > 0){\r\n					int cost = graph[i][j];\r\n					//判断从s-i-j的距离是否小于s-j的距离\r\n					if (d[i] + cost < d[j]){\r\n						//如果小于则更新距离\r\n						d[j] = d[i] + cost;\r\n						//设置更新状态\r\n						update = true;\r\n					}\r\n				}\r\n			}\r\n		}\r\n		//如果\r\n		if (!update)	break;\r\n	}\r\n	\r\n	return d;\r\n}\r\n\r\npublic static void main(String[] args) {\r\n	System.out.println(Arrays.toString(shortestPath(0)));\r\n}\r\n```\r\n\r\n* 优化：使用edge list结构减少循环次数，复杂度为O(|V|*|E|)\r\n\r\n```java\r\n/**\r\n* 源点s到各顶点的最短路径\r\n* @param s 起点\r\n* @return\r\n*/\r\npublic static int[] shortestPath(int s){\r\n	//s到各顶点距离\r\n	int[] d = new int[graph.length];\r\n	//到自己距离为0\r\n	d[s] = 0;\r\n	//到其他顶点距离初始化为无穷大\r\n	for (int i = 1; i < d.length; i++) {\r\n		d[i] = Integer.MAX_VALUE;\r\n	}\r\n	List<Edge<Integer>> list = getEdges(graph);\r\n	//更新距离\r\n	while (true){\r\n		boolean update = false;\r\n		//遍历边集\r\n		for (int i = 0; i < list.size(); i++) {\r\n			Edge<Integer> edge = list.get(i);\r\n			int j = edge.getStart();\r\n			int k = edge.getEnd();\r\n			int cost = edge.getDistance();\r\n			//如果到j的距离未更新则直接跳过\r\n			if (d[j] == Integer.MAX_VALUE){\r\n				continue;\r\n			}\r\n			//如果s-j-k<s-k\r\n			if (d[j] + cost < d[k]){\r\n				//更新到k的距离\r\n				d[k] = d[j] + cost;\r\n				update = true;\r\n			}\r\n		}\r\n		//如果遍历边集后未更新距离则退出\r\n		if (!update)	break;\r\n	}\r\n	\r\n	return d;\r\n}\r\n\r\n/**\r\n	* 将邻接矩阵转换为edge list\r\n	* @param graph\r\n	* @return\r\n	*/\r\npublic static List<Edge<Integer>> getEdges(int[][] graph){\r\n	List<Edge<Integer>> list = new ArrayList<Edge<Integer>>();\r\n	for (int i = 0; i < graph.length; i++) {\r\n		for (int j = 0; j < graph.length; j++) {\r\n			if (graph[i][j] > 0){\r\n				list.add(new Edge<>(i, j, graph[i][j]));\r\n			}\r\n		}\r\n	}\r\n	\r\n	return list;\r\n}\r\n\r\nstatic int[][] graph = {\r\n			{0, 2, 5, 0, 0, 0, 0},\r\n			{2, 0, 4, 6, 10, 0, 0},\r\n			{5, 4, 0, 2, 0, 0, 0},\r\n			{0, 6, 2, 0, 0, 1, 0},\r\n			{0, 10, 0, 0, 0, 3, 5},\r\n			{0, 0, 0, 1, 3, 0, 9},\r\n			{0, 0, 0, 0, 5, 9, 0}\r\n		};\r\n\r\npublic static void main(String[] args) {\r\n	System.out.println(Arrays.toString(shortestPath(0)));\r\n}\r\n```\r\n\r\n* 如果在图中不存在从s可达的的负圈,那么最短路不会经过同一个顶点两次(也就是说，最多通过IV-1条边), while(true)的循环最多执行|V|-1次， 因此，复杂度是O(|V|x|E|)。反之，如果存在从s可达的负圈，那么在第|V|次循环中也会更新d的值，因此也可以用这个性质来检查负圈。如果一开始对所有的顶点i,都把的d[j]初始化为0，那么可以检查出所有的负圈。\r\n\r\n```java\r\nstatic boolean findNagativeLoop(List<Edge> edges){\r\n	int[] d = new int[graph.length];\r\n	\r\n	for (int i = 0; i < graph.length; i++) {\r\n		for (int j = 0; j < edges.size(); j++) {\r\n			Edge e = edges.get(j);\r\n			if (d[e.end] > d[e.start] + e.cost){\r\n				d[e.end] = d[e.start] + e.cost;\r\n				\r\n				if (i == graph.length - 1)	return true;\r\n			}\r\n		}\r\n	}\r\n	return false;\r\n}\r\n```\r\n\r\n##### Dijkstra算法\r\n\r\n`让我们考虑一- 下没有负边的情况。在Bellman-Ford算法中，如果d[i]还不是最短距离的话,那么即\r\n使进行dj]=d[j]+(从i到j的边的权值)的更新，d[j]也不会 变成最短距离。而且，即使d[i]没有变化，\r\n每一次循环也要检查- -遍 从出发的所有边。这显然是很浪费时间的。因此可以对算法做如下修改。\r\n(1)找到最短距离已经确定的顶点，从它出发更新相邻顶点的最短距离。\r\n(2)此后不需要再关心1中的“最短距离已经确定的顶点”。\r\n在(1)和(2)中提到的“最短距离已经确定的顶点”要怎么得到是问题的关键。在最开始时，只有\r\n起点的最短距离是确定的。而在尚未使用过的顶点中，距离a[i]最小的顶点就是最短距离已经确\r\n定的顶点。这是因为由于不存在负边，所以d[i]不会在之后的更新中变小。这个算法叫做Djkstra\r\n算法。`\r\n\r\n```java\r\n//这里特指从A到其他点的最短路径\r\npublic static void main(String[] args) {\r\n	char[] v = {\'A\', \'B\', \'C\', \'D\', \'E\', \'F\', \'G\'};\r\n	int[][] graph = {\r\n				{0, 2, 5, 0, 0, 0, 0},\r\n				{2, 0, 4, 6, 10, 0, 0},\r\n				{5, 4, 0, 2, 0, 0, 0},\r\n				{0, 6, 2, 0, 0, 1, 0},\r\n				{0, 10, 0, 0, 0, 3, 5},\r\n				{0, 0, 0, 1, 3, 0, 9},\r\n				{0, 0, 0, 0, 5, 9, 0}\r\n	};\r\n	\r\n	//清除所有点的标记\r\n	int[] f = new int[v.length];\r\n	//\"父亲指针\"\r\n	int[] fa = new int[v.length];\r\n	//设d[0]=0,其他未inf\r\n	int[] d = new int[v.length];\r\n	d[0] = 0;\r\n	for (int i = 1; i < d.length; i++) {\r\n		d[i] = Integer.MAX_VALUE;\r\n	}\r\n	//记录已经找到最短路径的点\r\n	Set<Integer> set = new HashSet<>();\r\n	int count = 0;\r\n	//循环n次\r\n	while (set.size() < v.length){\r\n		//在所有未标号节点中，选出d值最小的节点x\r\n		int x = 0;\r\n		int min = Integer.MAX_VALUE;\r\n		for (int j = 0; j < d.length; j++) {\r\n			if (f[j] == 0 && d[j] <= min){\r\n				x = j;\r\n				min = d[j];\r\n			}\r\n		}\r\n		//给节点x标记\r\n		count++;\r\n		f[x] = 1;\r\n		set.add(x);\r\n		for (int j = 0; j < graph.length; j++) {\r\n			if (graph[x][j] > 0 && d[j] > d[x] + graph[x][j]){\r\n				d[j] = d[x] + graph[x][j];\r\n				fa[j] = x;\r\n			}\r\n		}\r\n	}\r\n	\r\n	//打印各个最短路径\r\n	for (int i = 0; i < d.length; i++) {\r\n		System.out.print(v[i] + \"<---\");\r\n		int j = fa[i];\r\n		while (j != 0){\r\n			System.out.print(v[j] + \"<---\");\r\n			j = fa[j];\r\n		}\r\n		System.out.println(v[0] + \":\" + d[i]);\r\n	}\r\n}\r\n```\r\n\r\n##### Floyd算法\r\n\r\n`求解所有两点间的最短路的问题叫做任意两点间的最短路问题。让我们试着用DP来求解任意两\r\n点间的最短路问题。只使用顶点0 k和i, j的情况下，记到j的最短路长度为d[k+1][i][]。k=-1时，\r\n认为只使用i和j，所以d[0][i[i]=cost[][i]。 接下来让我们把只使用顶点0~k的问题归约到只使用\r\n0~k-1的问题上。\r\n只使用0~ k时，我们分i到j的最短路正好经过顶点k- -次和完全不经过顶点k两种情况来讨论。不经\r\n过顶点k的情况下，d[k][][i]=d[k-1][i][i]。 通过顶点k的情况下，d[k][][i]=d[k-1 ][i][k]+a[k-1][k][]。\r\n合起来，就得到了\"d[k][][i]=min(d[k-1][][i], d[k-1][][k]+d[k-1][k][i])。这个DP也可以使用同-个\r\n数组，不断进行d[i][i]=min(d[i][], d[i][k]+d[k][i])的更新来实现。`\r\n\r\n```java\r\npublic static void main(String[] args) {\r\n	char[] v = {\'A\', \'B\', \'C\', \'D\', \'E\', \'F\', \'G\'};\r\n	int[][] graph = {\r\n				{0, 2, 5, 0, 0, 0, 0},\r\n				{2, 0, 4, 6, 10, 0, 0},\r\n				{5, 4, 0, 2, 0, 0, 0},\r\n				{0, 6, 2, 0, 0, 1, 0},\r\n				{0, 10, 0, 0, 0, 3, 5},\r\n				{0, 0, 0, 1, 3, 0, 9},\r\n				{0, 0, 0, 0, 5, 9, 0}\r\n	};\r\n	\r\n	int[][] d = new int[v.length][v.length];\r\n	for (int i = 0; i < d.length; i++) {\r\n		for (int j = 0; j < d.length; j++) {\r\n			d[i][j] = graph[i][j];\r\n		}\r\n	}\r\n	for (int i = 0; i < d.length; i++) {\r\n		for (int j = 0; j < d.length; j++) {\r\n			if (i ==  j){\r\n				d[i][j] = 0;\r\n				continue;\r\n			}\r\n			if (d[i][j] == 0){\r\n				d[i][j] = 1000;\r\n			}\r\n		}\r\n	}\r\n	for (int k = 0; k < d.length; k++) {\r\n		for (int i = 0; i < d.length; i++) {\r\n			for (int j = 0; j < d.length; j++) {\r\n				d[i][j] = Math.min(d[i][j], d[i][k] + d[k][j]);\r\n			}\r\n		}\r\n	}\r\n	for (int i = 0; i < v.length; i++) {\r\n		System.out.println(Arrays.toString(d[i]));\r\n	}\r\n}\r\n```\r\n\r\n### 题解\r\n\r\n#### Kurskal\r\n\r\n1. [POJ1287](http://poj.org/problem?id=1287)\r\n\r\n```java\r\npublic static void main(String[] args) {\r\n	List<Integer> res = new ArrayList<Integer>();\r\n	Scanner input = new Scanner(System.in);\r\n	while (true){\r\n		List<Edge<Integer>> list = new ArrayList<Edge<Integer>>();\r\n		int p = input.nextInt();\r\n		if (p == 0){\r\n			break;\r\n		}\r\n		int r = input.nextInt();\r\n		//电缆\r\n		for (int i = 0; i < r; i++) {\r\n			int start = input.nextInt();\r\n			int end = input.nextInt();\r\n			int dis = input.nextInt();\r\n			list.add(new Edge<Integer>(start, end, dis));\r\n		}\r\n		//得到最小电缆长度方案\r\n		Kurskal<Integer> kurskal = new Kurskal<Integer>(list, 6);\r\n		Set<Edge<Integer>> t = kurskal.getT();\r\n		//统计最小长度\r\n		int count = 0;\r\n		for (Edge<Integer> edge : t) {\r\n			count += edge.getDistance();\r\n		}\r\n		res.add(count);\r\n	}\r\n	\r\n	for (Integer i : res) {\r\n		System.out.println(i);\r\n	}\r\n}\r\n```\r\n\r\n2. 城市建设\r\n\r\n	问题描述\r\n	　　栋栋居住在一个繁华的C市中，然而，这个城市的道路大都年久失修。市长准备重新修一些路以方便市民，于是找到了栋栋，希望栋栋能帮助他。\r\n\r\n	　　C市中有n个比较重要的地点，市长希望这些地点重点被考虑。现在可以修一些道路来连接其中的一些地点，每条道路可以连接其中的两个地点。\r\n\r\n	另外由于C市有一条河从中穿过，也可以在其中的一些地点建设码头，所有建了码头的地点可以通过河道连接。\r\n\r\n	　　栋栋拿到了允许建设的道路的信息，包括每条可以建设的道路的花费，以及哪些地点可以建设码头和建设码头的花费。\r\n\r\n	　　市长希望栋栋给出一个方案，使得任意两个地点能只通过新修的路或者河道互达，同时花费尽量小。\r\n	输入格式\r\n	　　输入的第一行包含两个整数n, m，分别表示C市中重要地点的个数和可以建设的道路条数。所有地点从1到n依次编号。\r\n	　　接下来m行，每行三个整数a, b, c，表示可以建设一条从地点a到地点b的道路，花费为c。\r\n	若c为正，表示建设是花钱的，如果c为负，则表示建设了道路后还可以赚钱（比如建设收费道路）。\r\n	　　接下来一行，包含n个整数w_1, w_2, …, w_n。如果w_i为正数，则表示在地点i建设码头的花费，如果w_i为-1，则表示地点i无法建设码头。\r\n	　　输入保证至少存在一个方法使得任意两个地点能只通过新修的路或者河道互达。\r\n	输出格式\r\n	　　输出一行，包含一个整数，表示使得所有地点通过新修道路或者码头连接的最小花费。如果满足条件的情况下还能赚钱，那么你应该输出一个负数。\r\n	样例输入\r\n	5 5\r\n	1 2 4\r\n	1 3 -1\r\n	2 3 3\r\n	2 4 5\r\n	4 5 10\r\n	-1 10 10 1 1\r\n	样例输出\r\n	9\r\n	样例说明\r\n	　　建设第2、3、4条道路，在地点4、5建设码头，总的花费为9。\r\n	数据规模和约定\r\n	　　对于20%的数据，1<=n<=10，1<=m<=20，0<=c<=20，w_i<=20；\r\n	　　对于50%的数据，1<=n<=100，1<=m<=1000，-50<=c<=50，w_i<=50；\r\n	　　对于70%的数据，1<=n<=1000；\r\n	　　对于100%的数据，1 <= n <= 10000，1 <= m <= 100000，-1000<=c<=1000，-1<=w_i<=1000，w_i≠0。\r\n\r\n	* 解：\r\n	```java\r\n	public static void main(String[] args) {\r\n		List<Edge<Integer>> list = new ArrayList<Edge<Integer>>();\r\n		//道路\r\n		list.add(new Edge<Integer>(1, 2, 4));\r\n		list.add(new Edge<Integer>(1, 3, -1));\r\n		list.add(new Edge<Integer>(2, 3, 3));\r\n		list.add(new Edge<Integer>(2, 4, 5));\r\n		list.add(new Edge<Integer>(4, 5, 10));\r\n		//每个地点建设码头的开销\r\n		list.add(new Edge<Integer>(0, 2, 10));\r\n		list.add(new Edge<Integer>(0, 3, 10));\r\n		list.add(new Edge<Integer>(0, 4, 1));\r\n		list.add(new Edge<Integer>(0, 5, 1));\r\n		//得到最小花费的建设方案\r\n		Kurskal<Integer> kurskal = new Kurskal<>(list, 6);\r\n		Set<Edge<Integer>> t = kurskal.getT();\r\n		//统计最小开销\r\n		int count = 0;\r\n		for (Edge<Integer> edge : t) {\r\n			count += edge.getDistance();\r\n		}\r\n		System.out.println(count);\r\n		System.out.println(t);\r\n	}\r\n	```\r\n\r\n#### 没有明显节点的图\r\n\r\n1. 分酒\r\n有4个红酒瓶子，它们的容量分别是：9升, 7升, 4升, 2升\r\n 开始的状态是 [9,0,0,0]，也就是说：第一个瓶子满着，其它的都空着。\r\n\r\n 允许把酒从一个瓶子倒入另一个瓶子，但只能把一个瓶子倒满或把一个瓶子倒空，不能有中间状态。\r\n 这样的一次倒酒动作称为1次操作。\r\n\r\n 假设瓶子的容量和初始状态不变，对于给定的目标状态，至少需要多少次操作才能实现？\r\n 本题就是要求你编程实现最小操作次数的计算。\r\n\r\n 输入：最终状态（空格分隔）\r\n 输出：最小操作次数（如无法实现，则输出-1）\r\n\r\n 例如：\r\n 输入：\r\n 9 0 0 0\r\n 应该输出：\r\n 0\r\n\r\n 输入：\r\n 6 0 0 3\r\n 应该输出：\r\n -1\r\n\r\n 输入：\r\n 7 2 0 0\r\n 应该输出：\r\n 2\r\n\r\n```java\r\npublic class 分酒 {\r\n	//容量\r\n	static int[] v = {9, 7, 4, 2};\r\n	\r\n	public static void main(String[] args) {\r\n		//定义开始状态\r\n		Integer[] s = {9, 0, 0, 0};\r\n		State start = new State(s, 0);\r\n		//得到输入的最终状态\r\n		Scanner input = new Scanner(System.in);\r\n		Integer[] e = new Integer[v.length];\r\n		for (int i = 0; i < v.length; i++) {\r\n			e[i] = input.nextInt();\r\n		}\r\n		State end = new State(e, 0);\r\n		//队列记录状态转移中间过程 bfs\r\n		Queue<State> q = new LinkedList<State>();\r\n		//set判断状态是否重叠  避免重复添加状态\r\n		Set<State> set = new HashSet<>();\r\n		//状态初始化\r\n		set.add(start);\r\n		q.add(start);\r\n		//遍历状态\r\n		while (!q.isEmpty()){\r\n			//得到一个状态\r\n			State t = q.poll();\r\n			//判断是否到达最终状态\r\n			if (t.equals(end)){\r\n				//打印状态转移的次数\r\n				System.out.println(t.depth);\r\n				return;\r\n			}\r\n			//备份t状态\r\n			Integer[] temp = t.t.clone();\r\n			//加入t转移状态后的n个状态\r\n			//从i杯倒入j杯\r\n			for (int i = 0; i < temp.length; i++) {\r\n				//如果i杯没有酒直接跳过\r\n				if (temp[i] == 0)	continue;\r\n				for (int j = 0; j < temp.length; j++) {\r\n					//每次都是从t状态之间转移 所以需要还原t状态\r\n					temp = t.t.clone();\r\n					//如果i杯导入i杯则跳过\r\n					if (i == j)	continue;\r\n					//j杯剩余容量\r\n					int surplus = v[j] - temp[j];\r\n					//i杯能倒完\r\n					if (surplus >= temp[i]){\r\n						temp[j] += temp[i];\r\n						temp[i] = 0;\r\n					}\r\n					//j杯能倒满\r\n					else if (temp[i] > surplus){\r\n						temp[j] += surplus;\r\n						temp[i] -= surplus;\r\n					}\r\n					//得到转移后的状态\r\n					State next = new State(temp, t.depth + 1);\r\n					//判断此状态之前是否已经加入\r\n					if (!set.contains(next)){\r\n						//加入状态\r\n						set.add(next);\r\n						q.add(next);\r\n					}\r\n				}\r\n			}\r\n		}\r\n		System.out.println(-1);\r\n	}\r\n}\r\n//定义状态\r\nclass State{\r\n	//酒杯状态\r\n	Integer[] t;\r\n	//转移次数\r\n	int depth;\r\n	public State(Integer[] t, int count) {\r\n		super();\r\n		this.t = t;\r\n		this.depth = count;\r\n	}\r\n	@Override\r\n	public String toString() {\r\n		return \"State [t=\" + Arrays.toString(t) + \", count=\" + depth + \"]\";\r\n	}\r\n	@Override\r\n	public int hashCode() {\r\n		final int prime = 31;\r\n		int result = 1;\r\n		result = prime * result + Arrays.hashCode(t);\r\n		return result;\r\n	}\r\n	//判断状态是否相同根据酒杯状态是否相同\r\n	@Override\r\n	public boolean equals(Object obj) {\r\n		if (this == obj)\r\n			return true;\r\n		if (obj == null)\r\n			return false;\r\n		if (getClass() != obj.getClass())\r\n			return false;\r\n		State other = (State) obj;\r\n		if (!Arrays.equals(t, other.t))\r\n			return false;\r\n		return true;\r\n	}\r\n}\r\n```\r\n\r\n2. 迷宫\r\n\r\n...11111111111111111111111111111\r\n11.111111........1111111111.1111\r\n11.111111..111.11111111.....1111\r\n11.11111111111.1111111111.111111\r\n11.111111.................111111\r\n11.111111.11111111111.11111.1111\r\n11.111111.11111111111.11111..111\r\n11..........111111111.11111.1111\r\n11111.111111111111111.11....1111\r\n11111.111111111111111.11.11.1111\r\n11111.111111111111111.11.11.1111\r\n111...111111111111111.11.11.1111\r\n111.11111111111111111....11.1111\r\n111.11111111111111111111111.1111\r\n111.1111.111111111111111......11\r\n111.1111.......111111111.1111.11\r\n111.1111.11111.111111111.1111.11\r\n111......11111.111111111.1111111\r\n11111111111111.111111111.111...1\r\n11111111111111...............1.1\r\n111111111111111111111111111111..\r\n\r\n如上图的迷宫，入口，出口分别：左上角，右下角\r\n\"1\"是墙壁，\".\"是通路\r\n求最短需要走多少步？\r\n\r\n```java\r\npublic static void main(String[] args) {\r\n	char[][] graph = { \r\n			\"...111\".toCharArray(), \r\n			\".1.111\".toCharArray(), \r\n			\".....1\".toCharArray(),\r\n			\"...1..\".toCharArray(), };\r\n	//标识\r\n	int[][] visited = new int[graph.length][graph[0].length];\r\n\r\n	Queue<Node1> q = new LinkedList<Node1>();\r\n	//初始化起点\r\n	q.add(new Node1(0, 0, 0));\r\n\r\n	while (!q.isEmpty()) {\r\n		Node1 Node1 = q.poll();\r\n		int x = Node1.x;\r\n		int y = Node1.y;\r\n		//终点为右下角\r\n		if (x == graph.length - 1 && y == graph[0].length - 1) {\r\n			System.out.println(Node1.depth);\r\n			break;\r\n		}\r\n		//加入四周的点\r\n		if (x - 1 >= 0 && graph[x - 1][y] != \'1\' && visited[x - 1][y] == 0) {\r\n			visited[x - 1][y] = 1;\r\n			q.add(new Node1(x - 1, y, Node1.depth + 1));\r\n		}\r\n		if (x + 1 < graph.length && graph[x + 1][y] != \'1\' && visited[x + 1][y] == 0) {\r\n			visited[x + 1][y] = 1;\r\n			q.add(new Node1(x + 1, y, Node1.depth + 1));\r\n		}\r\n		if (y - 1 >= 0 && graph[x][y - 1] != \'1\' && visited[x][y - 1] == 0) {\r\n			visited[x][y - 1] = 1;\r\n			q.add(new Node1(x, y - 1, Node1.depth + 1));\r\n		}\r\n		if (y + 1 < graph[0].length && graph[x][y + 1] != \'1\' && visited[x][y + 1] == 0) {\r\n			visited[x][y + 1] = 1;\r\n			q.add(new Node1(x, y + 1, Node1.depth + 1));\r\n		}\r\n	}\r\n}\r\nclass Node1 {\r\n	int x;\r\n	int y;\r\n	int depth;\r\n\r\n	public Node1(int x, int y, int depth) {\r\n		this.x = x;\r\n		this.y = y;\r\n		this.depth = depth;\r\n	}\r\n}\r\n```\r\n\r\n#### 最短路径\r\n\r\n* [POJ-1502](http://poj.org/problem?id=1502)\r\n\r\n```java\r\npublic static void main(String[] args) {\r\n	Scanner input = new Scanner(System.in);\r\n	int n = input.nextInt();\r\n	int[][] graph = new int[n][n];\r\n	for (int i = 1; i < graph.length; i++) {\r\n		for (int j = 0; j < i; j++) {\r\n			try{\r\n			int x = Integer.parseInt(input.next());\r\n			graph[i][j] = x;\r\n			graph[j][i] = x;\r\n			}catch (Exception e){\r\n				graph[i][j] =0;\r\n				graph[j][i] =0;\r\n			}\r\n		}\r\n	}\r\n	\r\n	int[] d = 单源最短路径_Bellman_ford优化.shortestPath(graph, 0);\r\n\r\n	//所需的最短通信时间为最大值\r\n	int max = d[1];\r\n	for (int i = 2; i < d.length; i++) {\r\n		if (d[i] > max){\r\n			max = d[i];\r\n		}\r\n	}\r\n	System.out.println(max);\r\n}\r\n```', '2020-06-24 11:21:33', '0', '图基础树与图没有圈的连通图,就是树没有圈的非连通图,就是森林一棵树的边数等于顶点数-1边数等于顶点数', '/static/img/rand/12.jpg', '图结构', '0', 'post', '0', '2020-06-24 11:21:33', '1592968893', null);
INSERT INTO `plog_article` VALUES ('159', '14', '<p>嘻嘻嘻嘻嘻嘻嘻嘻嘻嘻嘻嘻嘻嘻嘻嘻嘻嘻嘻</p>', '嘻嘻嘻嘻嘻嘻嘻嘻嘻嘻嘻嘻嘻嘻嘻嘻嘻嘻嘻', '2020-06-24 11:55:45', '0', null, '/static/img/rand/1.jpg', '这是啥', null, 'page', '0', '2020-06-24 11:55:45', 'zhe-shi-sha', null);

-- ----------------------------
-- Table structure for plog_article_category
-- ----------------------------
DROP TABLE IF EXISTS `plog_article_category`;
CREATE TABLE `plog_article_category` (
  `article_id` int(20) NOT NULL,
  `category_id` bigint(20) NOT NULL,
  KEY `plog_ARTILE_ID` (`article_id`) USING BTREE,
  KEY `plog_ARTILE_CATEGORY_ID` (`category_id`) USING BTREE
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

-- ----------------------------
-- Records of plog_article_category
-- ----------------------------
INSERT INTO `plog_article_category` VALUES ('154', '21');
INSERT INTO `plog_article_category` VALUES ('155', '21');
INSERT INTO `plog_article_category` VALUES ('156', '23');
INSERT INTO `plog_article_category` VALUES ('157', '22');
INSERT INTO `plog_article_category` VALUES ('158', '22');
INSERT INTO `plog_article_category` VALUES ('153', '21');

-- ----------------------------
-- Table structure for plog_article_tag
-- ----------------------------
DROP TABLE IF EXISTS `plog_article_tag`;
CREATE TABLE `plog_article_tag` (
  `article_id` int(20) NOT NULL,
  `tag_id` bigint(20) NOT NULL,
  KEY `plog_ARTILE_ID` (`article_id`) USING BTREE,
  KEY `plog_ARTILE_TAG_ID` (`tag_id`) USING BTREE
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

-- ----------------------------
-- Records of plog_article_tag
-- ----------------------------
INSERT INTO `plog_article_tag` VALUES ('154', '21');
INSERT INTO `plog_article_tag` VALUES ('155', '22');
INSERT INTO `plog_article_tag` VALUES ('153', '21');
INSERT INTO `plog_article_tag` VALUES ('153', '23');

-- ----------------------------
-- Table structure for plog_attachment
-- ----------------------------
DROP TABLE IF EXISTS `plog_attachment`;
CREATE TABLE `plog_attachment` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `picture_name` varchar(255) DEFAULT NULL COMMENT '图片名称',
  `picture_path` varchar(255) DEFAULT NULL COMMENT '图片路径',
  `picture_small_path` varchar(255) DEFAULT NULL COMMENT '略缩图',
  `picture_type` varchar(255) DEFAULT NULL COMMENT '图片类型',
  `picture_create_date` varchar(255) DEFAULT NULL COMMENT '上传时间',
  `picture_size` varchar(255) DEFAULT NULL COMMENT '文件大小',
  `picture_suffix` varchar(255) DEFAULT NULL COMMENT '后缀',
  `picture_wh` varchar(255) DEFAULT NULL COMMENT '尺寸',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=252 DEFAULT CHARSET=utf8;

-- ----------------------------
-- Records of plog_attachment
-- ----------------------------
INSERT INTO `plog_attachment` VALUES ('250', '99146020200625170742148.jpg', '/upload/2020/6/99146020200625170742148.jpg', '/upload/2020/6/99146020200625170742148_small.jpg', 'image/jpeg', '2020-06-25 17:07:42.945', '340KB', '.jpg', '1920x1080');
INSERT INTO `plog_attachment` VALUES ('251', '1ea1a0e6bca73a1a1fec58d3a38e7c0120200625192306815.jpeg', '/upload/2020/6/1ea1a0e6bca73a1a1fec58d3a38e7c0120200625192306815.jpeg', '/upload/2020/6/1ea1a0e6bca73a1a1fec58d3a38e7c0120200625192306815_small.jpeg', 'image/jpeg', '2020-06-25 19:23:06.26', '230KB', '.jpeg', '932x1024');

-- ----------------------------
-- Table structure for plog_category
-- ----------------------------
DROP TABLE IF EXISTS `plog_category`;
CREATE TABLE `plog_category` (
  `category_id` int(11) NOT NULL AUTO_INCREMENT,
  `category_name` varchar(255) DEFAULT NULL COMMENT '分类名称',
  `category_url` varchar(255) DEFAULT NULL COMMENT '分类路径',
  `category_describe` varchar(255) DEFAULT NULL COMMENT '描述',
  PRIMARY KEY (`category_id`)
) ENGINE=InnoDB AUTO_INCREMENT=27 DEFAULT CHARSET=utf8;

-- ----------------------------
-- Records of plog_category
-- ----------------------------
INSERT INTO `plog_category` VALUES ('21', 'java', '/java', 'java se');
INSERT INTO `plog_category` VALUES ('22', '数据结构', '/ds', '数据结构基础');
INSERT INTO `plog_category` VALUES ('23', '算法', '/al', '算法基础');
INSERT INTO `plog_category` VALUES ('24', 'javaweb', '/javaweb', 'javaweb基础');
INSERT INTO `plog_category` VALUES ('25', 'javaee', '/javaee', 'javaee基础');
INSERT INTO `plog_category` VALUES ('26', 'linux', '/linux', 'linux操作系统');

-- ----------------------------
-- Table structure for plog_link
-- ----------------------------
DROP TABLE IF EXISTS `plog_link`;
CREATE TABLE `plog_link` (
  `link_id` int(11) NOT NULL AUTO_INCREMENT,
  `link_name` varchar(255) DEFAULT NULL COMMENT '名称',
  `link_url` varchar(255) DEFAULT NULL COMMENT '路径',
  `link_logo` varchar(255) DEFAULT NULL COMMENT '链接logo',
  `link_describe` varchar(255) DEFAULT NULL COMMENT '描述',
  PRIMARY KEY (`link_id`)
) ENGINE=InnoDB AUTO_INCREMENT=50 DEFAULT CHARSET=utf8;

-- ----------------------------
-- Records of plog_link
-- ----------------------------
INSERT INTO `plog_link` VALUES ('48', 'stacksg', 'https://stacksg.club', '', '');
INSERT INTO `plog_link` VALUES ('49', 'github', 'https://github.com', '', '');

-- ----------------------------
-- Table structure for plog_logs
-- ----------------------------
DROP TABLE IF EXISTS `plog_logs`;
CREATE TABLE `plog_logs` (
  `log_id` int(11) NOT NULL AUTO_INCREMENT,
  `log_title` varchar(255) DEFAULT NULL COMMENT '标题',
  `log_content` varchar(255) DEFAULT NULL COMMENT '内容',
  `log_ip` varchar(255) DEFAULT NULL COMMENT 'ip',
  `log_date` datetime DEFAULT NULL COMMENT '时间',
  PRIMARY KEY (`log_id`)
) ENGINE=InnoDB AUTO_INCREMENT=969 DEFAULT CHARSET=utf8;

-- ----------------------------
-- Records of plog_logs
-- ----------------------------
INSERT INTO `plog_logs` VALUES ('902', '安装plog', '操作成功', '0:0:0:0:0:0:0:1', '2020-06-23 16:33:56');
INSERT INTO `plog_logs` VALUES ('903', '登录后台', '登录成功', '0:0:0:0:0:0:0:1', '2020-06-23 17:18:53');
INSERT INTO `plog_logs` VALUES ('904', '登录后台', '登录成功', '0:0:0:0:0:0:0:1', '2020-06-23 20:24:28');
INSERT INTO `plog_logs` VALUES ('905', '登录后台', '登录成功', '0:0:0:0:0:0:0:1', '2020-06-24 10:38:24');
INSERT INTO `plog_logs` VALUES ('906', '上传附件', '上传成功', '0:0:0:0:0:0:0:1', '2020-06-24 10:48:17');
INSERT INTO `plog_logs` VALUES ('907', '发表文章', '操作成功', '0:0:0:0:0:0:0:1', '2020-06-24 10:49:00');
INSERT INTO `plog_logs` VALUES ('908', '发表文章', '操作成功', '0:0:0:0:0:0:0:1', '2020-06-24 10:51:28');
INSERT INTO `plog_logs` VALUES ('909', '更新文章', '操作成功', '0:0:0:0:0:0:0:1', '2020-06-24 10:52:09');
INSERT INTO `plog_logs` VALUES ('910', '发表文章', '操作成功', '0:0:0:0:0:0:0:1', '2020-06-24 10:58:13');
INSERT INTO `plog_logs` VALUES ('911', '发表文章', '操作成功', '0:0:0:0:0:0:0:1', '2020-06-24 11:08:10');
INSERT INTO `plog_logs` VALUES ('912', '发表文章', '操作成功', '0:0:0:0:0:0:0:1', '2020-06-24 11:20:40');
INSERT INTO `plog_logs` VALUES ('913', '发表文章', '操作成功', '0:0:0:0:0:0:0:1', '2020-06-24 11:21:33');
INSERT INTO `plog_logs` VALUES ('914', '登录后台', '登录成功', '0:0:0:0:0:0:0:1', '2020-06-24 11:54:15');
INSERT INTO `plog_logs` VALUES ('915', '发布页面', '操作成功', '0:0:0:0:0:0:0:1', '2020-06-24 11:55:45');
INSERT INTO `plog_logs` VALUES ('916', '登录后台', '登录成功', '0:0:0:0:0:0:0:1', '2020-06-24 14:14:22');
INSERT INTO `plog_logs` VALUES ('917', '上传附件', '上传成功', '0:0:0:0:0:0:0:1', '2020-06-24 14:27:56');
INSERT INTO `plog_logs` VALUES ('918', '登录后台', '登录成功', '0:0:0:0:0:0:0:1', '2020-06-24 15:24:23');
INSERT INTO `plog_logs` VALUES ('919', '登录后台', '登录成功', '0:0:0:0:0:0:0:1', '2020-06-24 15:48:39');
INSERT INTO `plog_logs` VALUES ('920', '登录后台', '登录成功', '0:0:0:0:0:0:0:1', '2020-06-24 15:49:30');
INSERT INTO `plog_logs` VALUES ('921', '登录后台', '登录成功', '0:0:0:0:0:0:0:1', '2020-06-24 15:51:22');
INSERT INTO `plog_logs` VALUES ('922', '登录后台', '登录成功', '0:0:0:0:0:0:0:1', '2020-06-24 15:58:44');
INSERT INTO `plog_logs` VALUES ('923', '登录后台', '登录成功', '0:0:0:0:0:0:0:1', '2020-06-24 16:08:53');
INSERT INTO `plog_logs` VALUES ('924', '登录后台', '登录成功', '0:0:0:0:0:0:0:1', '2020-06-24 16:31:09');
INSERT INTO `plog_logs` VALUES ('925', '登录后台', '登录成功', '0:0:0:0:0:0:0:1', '2020-06-24 16:33:25');
INSERT INTO `plog_logs` VALUES ('926', '登录后台', '登录成功', '0:0:0:0:0:0:0:1', '2020-06-24 16:36:32');
INSERT INTO `plog_logs` VALUES ('927', '登录后台', '登录成功', '0:0:0:0:0:0:0:1', '2020-06-24 16:41:55');
INSERT INTO `plog_logs` VALUES ('928', '登录后台', '登录成功', '0:0:0:0:0:0:0:1', '2020-06-24 16:44:49');
INSERT INTO `plog_logs` VALUES ('929', '登录后台', '登录成功', '0:0:0:0:0:0:0:1', '2020-06-24 16:47:32');
INSERT INTO `plog_logs` VALUES ('930', '登录后台', '登录成功', '0:0:0:0:0:0:0:1', '2020-06-24 16:53:37');
INSERT INTO `plog_logs` VALUES ('931', '登录后台', '登录成功', '0:0:0:0:0:0:0:1', '2020-06-24 16:56:05');
INSERT INTO `plog_logs` VALUES ('932', '登录后台', '登录成功', '0:0:0:0:0:0:0:1', '2020-06-24 17:04:57');
INSERT INTO `plog_logs` VALUES ('933', '登录后台', '登录失败', '0:0:0:0:0:0:0:1', '2020-06-24 17:15:33');
INSERT INTO `plog_logs` VALUES ('934', '登录后台', '登录成功', '0:0:0:0:0:0:0:1', '2020-06-24 17:15:42');
INSERT INTO `plog_logs` VALUES ('935', '登录后台', '登录成功', '0:0:0:0:0:0:0:1', '2020-06-24 19:01:10');
INSERT INTO `plog_logs` VALUES ('936', '登录后台', '登录成功', '0:0:0:0:0:0:0:1', '2020-06-25 14:06:05');
INSERT INTO `plog_logs` VALUES ('937', '登录后台', '登录成功', '0:0:0:0:0:0:0:1', '2020-06-25 14:07:33');
INSERT INTO `plog_logs` VALUES ('938', '登录后台', '登录成功', '0:0:0:0:0:0:0:1', '2020-06-25 14:13:39');
INSERT INTO `plog_logs` VALUES ('939', '登录后台', '登录成功', '0:0:0:0:0:0:0:1', '2020-06-25 14:24:02');
INSERT INTO `plog_logs` VALUES ('940', '登录后台', '登录成功', '0:0:0:0:0:0:0:1', '2020-06-25 14:36:06');
INSERT INTO `plog_logs` VALUES ('941', '登录后台', '登录成功', '0:0:0:0:0:0:0:1', '2020-06-25 14:40:06');
INSERT INTO `plog_logs` VALUES ('942', '登录后台', '登录成功', '0:0:0:0:0:0:0:1', '2020-06-25 14:40:27');
INSERT INTO `plog_logs` VALUES ('943', '上传附件', '上传成功', '0:0:0:0:0:0:0:1', '2020-06-25 14:41:26');
INSERT INTO `plog_logs` VALUES ('944', '登录后台', '登录成功', '0:0:0:0:0:0:0:1', '2020-06-25 14:41:39');
INSERT INTO `plog_logs` VALUES ('945', '登录后台', '登录成功', '0:0:0:0:0:0:0:1', '2020-06-25 14:42:55');
INSERT INTO `plog_logs` VALUES ('946', '上传附件', '上传成功', '0:0:0:0:0:0:0:1', '2020-06-25 14:44:12');
INSERT INTO `plog_logs` VALUES ('947', '登录后台', '登录成功', '0:0:0:0:0:0:0:1', '2020-06-25 14:44:24');
INSERT INTO `plog_logs` VALUES ('948', '登录后台', '登录成功', '0:0:0:0:0:0:0:1', '2020-06-25 14:48:57');
INSERT INTO `plog_logs` VALUES ('949', '登录后台', '登录成功', '0:0:0:0:0:0:0:1', '2020-06-25 14:50:19');
INSERT INTO `plog_logs` VALUES ('950', '登录后台', '登录成功', '0:0:0:0:0:0:0:1', '2020-06-25 15:03:12');
INSERT INTO `plog_logs` VALUES ('951', '登录后台', '登录成功', '0:0:0:0:0:0:0:1', '2020-06-25 15:12:21');
INSERT INTO `plog_logs` VALUES ('952', '登录后台', '登录成功', '0:0:0:0:0:0:0:1', '2020-06-25 17:01:09');
INSERT INTO `plog_logs` VALUES ('953', '上传附件', '上传成功', '0:0:0:0:0:0:0:1', '2020-06-25 17:07:43');
INSERT INTO `plog_logs` VALUES ('954', '登录后台', '登录成功', '0:0:0:0:0:0:0:1', '2020-06-25 17:08:07');
INSERT INTO `plog_logs` VALUES ('955', '更新文章', '操作成功', '0:0:0:0:0:0:0:1', '2020-06-25 17:13:03');
INSERT INTO `plog_logs` VALUES ('956', '登录后台', '登录成功', '0:0:0:0:0:0:0:1', '2020-06-25 17:16:49');
INSERT INTO `plog_logs` VALUES ('957', '登录后台', '登录成功', '0:0:0:0:0:0:0:1', '2020-06-25 17:20:16');
INSERT INTO `plog_logs` VALUES ('958', '登录后台', '登录成功', '0:0:0:0:0:0:0:1', '2020-06-25 18:58:03');
INSERT INTO `plog_logs` VALUES ('959', '登录后台', '登录成功', '0:0:0:0:0:0:0:1', '2020-06-25 19:10:02');
INSERT INTO `plog_logs` VALUES ('960', '登录后台', '登录成功', '0:0:0:0:0:0:0:1', '2020-06-25 19:13:05');
INSERT INTO `plog_logs` VALUES ('961', '登录后台', '登录成功', '0:0:0:0:0:0:0:1', '2020-06-25 19:20:50');
INSERT INTO `plog_logs` VALUES ('962', '上传附件', '上传成功', '0:0:0:0:0:0:0:1', '2020-06-25 19:23:06');
INSERT INTO `plog_logs` VALUES ('963', '登录后台', '登录成功', '0:0:0:0:0:0:0:1', '2020-06-25 19:23:32');
INSERT INTO `plog_logs` VALUES ('964', '登录后台', '登录成功', '0:0:0:0:0:0:0:1', '2020-06-25 19:40:38');
INSERT INTO `plog_logs` VALUES ('965', '登录后台', '登录成功', '0:0:0:0:0:0:0:1', '2020-06-25 19:45:07');
INSERT INTO `plog_logs` VALUES ('966', '登录后台', '登录成功', '0:0:0:0:0:0:0:1', '2020-06-25 19:46:46');
INSERT INTO `plog_logs` VALUES ('967', '登录后台', '登录成功', '0:0:0:0:0:0:0:1', '2020-06-25 19:50:54');
INSERT INTO `plog_logs` VALUES ('968', '登录后台', '登录成功', '0:0:0:0:0:0:0:1', '2020-06-25 22:16:21');

-- ----------------------------
-- Table structure for plog_menu
-- ----------------------------
DROP TABLE IF EXISTS `plog_menu`;
CREATE TABLE `plog_menu` (
  `menu_id` int(11) NOT NULL AUTO_INCREMENT,
  `menu_icon` varchar(255) DEFAULT NULL COMMENT '菜单图标',
  `menu_name` varchar(255) DEFAULT NULL COMMENT '菜单名称',
  `menu_sort` int(11) DEFAULT NULL COMMENT '排序',
  `menu_target` varchar(255) DEFAULT NULL COMMENT '打开方式',
  `menu_url` varchar(255) DEFAULT NULL COMMENT '菜单路径',
  PRIMARY KEY (`menu_id`)
) ENGINE=InnoDB AUTO_INCREMENT=42 DEFAULT CHARSET=utf8;

-- ----------------------------
-- Records of plog_menu
-- ----------------------------
INSERT INTO `plog_menu` VALUES ('38', null, '首页', '1', '_self', '/');
INSERT INTO `plog_menu` VALUES ('39', null, '归档', '2', '_self', '/archives');
INSERT INTO `plog_menu` VALUES ('40', null, '友链', '3', '_self', '/links');
INSERT INTO `plog_menu` VALUES ('41', '', '这是啥', '4', '_self', '/zhe-shi-sha');

-- ----------------------------
-- Table structure for plog_options
-- ----------------------------
DROP TABLE IF EXISTS `plog_options`;
CREATE TABLE `plog_options` (
  `option_name` varchar(255) NOT NULL COMMENT '设置名',
  `option_value` longtext COMMENT '设置内容',
  PRIMARY KEY (`option_name`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

-- ----------------------------
-- Records of plog_options
-- ----------------------------
INSERT INTO `plog_options` VALUES ('attachment_location', 'server');
INSERT INTO `plog_options` VALUES ('blog_footer', '哈哈哈');
INSERT INTO `plog_options` VALUES ('blog_logo', '/upload/2020/6/99146020200625170742148.jpg');
INSERT INTO `plog_options` VALUES ('blog_name', 'stacksg');
INSERT INTO `plog_options` VALUES ('blog_start', '2020-06-23');
INSERT INTO `plog_options` VALUES ('blog_statistics', 'zzzzzzzzzzzzzzzzzzzzzzzzz');
INSERT INTO `plog_options` VALUES ('blog_url', 'http://localhost:8000');
INSERT INTO `plog_options` VALUES ('comment_gitalk_admin', 'stackSg');
INSERT INTO `plog_options` VALUES ('comment_gitalk_clientid', '6f44d03c27cfe81f3b78');
INSERT INTO `plog_options` VALUES ('comment_gitalk_clientSecret', '23e79fea93dc1c0a86f685f22c1964de5fba0f55');
INSERT INTO `plog_options` VALUES ('comment_gitalk_owner', 'stackSg');
INSERT INTO `plog_options` VALUES ('comment_gitalk_repo', 'plog-comments');
INSERT INTO `plog_options` VALUES ('comment_valine_appid', '');
INSERT INTO `plog_options` VALUES ('comment_valine_appkey', '');
INSERT INTO `plog_options` VALUES ('comment_valine_hint', '');
INSERT INTO `plog_options` VALUES ('comment_valine_portrait', 'identicon');
INSERT INTO `plog_options` VALUES ('email_username', 'lpf@mail.stacksg.club');
INSERT INTO `plog_options` VALUES ('ico_logo', '/upload/2020/6/99146020200625170742148.jpg');
INSERT INTO `plog_options` VALUES ('is_install', 'true');
INSERT INTO `plog_options` VALUES ('pinghsu_email', '6666');
INSERT INTO `plog_options` VALUES ('pinghsu_github', '222');
INSERT INTO `plog_options` VALUES ('pinghsu_qq', '555');
INSERT INTO `plog_options` VALUES ('pinghsu_rss', 'rss_open');
INSERT INTO `plog_options` VALUES ('pinghsu_twitter', '444');
INSERT INTO `plog_options` VALUES ('pinghsu_weibo', '111');
INSERT INTO `plog_options` VALUES ('pinghsu_zhihu', '333');
INSERT INTO `plog_options` VALUES ('platform_comment', 'gitalk');

-- ----------------------------
-- Table structure for plog_tag
-- ----------------------------
DROP TABLE IF EXISTS `plog_tag`;
CREATE TABLE `plog_tag` (
  `tag_id` int(11) NOT NULL AUTO_INCREMENT,
  `tag_name` varchar(255) DEFAULT NULL COMMENT '标签名称',
  `tag_url` varchar(255) DEFAULT NULL COMMENT '标签路径',
  PRIMARY KEY (`tag_id`)
) ENGINE=InnoDB AUTO_INCREMENT=27 DEFAULT CHARSET=utf8;

-- ----------------------------
-- Records of plog_tag
-- ----------------------------
INSERT INTO `plog_tag` VALUES ('21', '多线程', '/juc');
INSERT INTO `plog_tag` VALUES ('22', '集合框架', '/collections');
INSERT INTO `plog_tag` VALUES ('23', 'jvm虚拟机', '/jvm');
INSERT INTO `plog_tag` VALUES ('24', 'io', '/io');
INSERT INTO `plog_tag` VALUES ('25', 'jdbc', '/jdbc');
INSERT INTO `plog_tag` VALUES ('26', 'mysql', '/mysql');

-- ----------------------------
-- Table structure for plog_theme
-- ----------------------------
DROP TABLE IF EXISTS `plog_theme`;
CREATE TABLE `plog_theme` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `theme_name` varchar(255) DEFAULT NULL COMMENT '主题名(url)',
  `theme_describe` varchar(255) DEFAULT NULL COMMENT '主题描述',
  `theme_img` varchar(255) DEFAULT NULL COMMENT '主题预览图',
  `theme_status` int(11) DEFAULT '0' COMMENT '0未启用1已启用',
  `create_time` datetime DEFAULT NULL COMMENT '创建时间',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=28 DEFAULT CHARSET=utf8;

-- ----------------------------
-- Records of plog_theme
-- ----------------------------
INSERT INTO `plog_theme` VALUES ('27', 'pinghsu', 'pinghsu', '/static/img/pinghsu.jpg', '1', '2020-06-23 16:33:56');

-- ----------------------------
-- Table structure for plog_user
-- ----------------------------
DROP TABLE IF EXISTS `plog_user`;
CREATE TABLE `plog_user` (
  `user_id` int(11) NOT NULL AUTO_INCREMENT,
  `login_enable` varchar(255) DEFAULT '0' COMMENT '是否禁用登录',
  `login_error` int(11) DEFAULT NULL COMMENT '登录失败次数',
  `login_last_time` datetime DEFAULT NULL COMMENT '最后登录时间',
  `user_portrait` varchar(255) DEFAULT NULL COMMENT '头像',
  `user_explain` varchar(255) DEFAULT NULL COMMENT '说明',
  `user_display_name` varchar(255) DEFAULT NULL COMMENT '显示名称',
  `user_email` varchar(255) DEFAULT NULL COMMENT '邮箱',
  `user_name` varchar(255) DEFAULT NULL COMMENT '用户名',
  `user_pwd` varchar(255) DEFAULT NULL COMMENT '密码',
  PRIMARY KEY (`user_id`)
) ENGINE=InnoDB AUTO_INCREMENT=15 DEFAULT CHARSET=utf8;

-- ----------------------------
-- Records of plog_user
-- ----------------------------
INSERT INTO `plog_user` VALUES ('14', 'false', '0', '2020-06-25 22:16:21', '/upload/2020/6/1ea1a0e6bca73a1a1fec58d3a38e7c0120200625192306815.jpeg', '', '哈哈', 'lpf@mail.stacksg.club', 'stacksg', 'e99a18c428cb38d5f260853678922e03');
